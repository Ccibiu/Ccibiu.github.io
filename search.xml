<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis的Java应用</title>
      <link href="/posts/54251.html"/>
      <url>/posts/54251.html</url>
      
        <content type="html"><![CDATA[<h2 id="将Token保存到Redis中"><a href="#将Token保存到Redis中" class="headerlink" title="将Token保存到Redis中"></a>将Token保存到Redis中</h2><p><img src="/img/2022-12-15-00-27-57-image.png"></p><p><img src="/img/2022-12-15-00-42-36-image.png"></p><p><img src="/img/2022-12-15-21-17-41-image.png"></p><h3 id="将手机号码-String-为key-验证码-String-为value存入Redis"><a href="#将手机号码-String-为key-验证码-String-为value存入Redis" class="headerlink" title="将手机号码(String)为key, 验证码(String)为value存入Redis"></a>将手机号码(String)为key, 验证码(String)为value存入Redis</h3><p>key,  value均是字符串的方法:</p><p>stringRedisTemplate.opsForValue().set(String key, String value, long timeout, TimeUnit unit)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.不合法返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不合法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.合法发送验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomString(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.保存验证码到redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.发送成功</span></span><br><span class="line">    log.debug(<span class="string">&quot;验证码是:&quot;</span> + code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="以Token-String-为key-用户-Map-为value存入Redis"><a href="#以Token-String-为key-用户-Map-为value存入Redis" class="headerlink" title="以Token(String)为key, 用户(Map)为value存入Redis"></a>以Token(String)为key, 用户(Map)为value存入Redis</h3><p>key为String, value为Map的方法:</p><p>stringRedisTemplate.opsForHash().putAll(String key, Map<?, ?> m)</p><p>设置存在时长:</p><p>stringRedisTemplate.expire(String key, long timeout, TimeUnit unit)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.判断手机号是否相等</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">        <span class="keyword">if</span>(code == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不一致&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//2.判断验证码是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(!(code.equals(loginForm.getCode()))) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.根据手机号在数据库中查询用户</span></span><br><span class="line">         <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.查询失败新建用户</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            user = createUserByPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.用户保存到redis中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY +token;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                        .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.返回ok</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="前端拦截器"><a href="#前端拦截器" class="headerlink" title="前端拦截器"></a>前端拦截器</h3><p>前端将会拦截每一次请求, 在每次请求头中加入Token</p><p><img title="" src="/img/2022-12-16-18-14-08-IMG_20221216_181250.png" alt="" width="573"><img src="/img/2022-12-16-18-17-12-image.png"></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><img src="/img/2022-12-15-21-18-21-image.png"></p><h3 id="全部拦截"><a href="#全部拦截" class="headerlink" title="全部拦截"></a>全部拦截</h3><p>访问完毕后需要将ThreadLocal中的信息删除</p><h4 id="RefreshTokenInterceptor类"><a href="#RefreshTokenInterceptor类" class="headerlink" title="RefreshTokenInterceptor类"></a>RefreshTokenInterceptor类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.LOGIN_USER_KEY;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.LOGIN_USER_TTL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;  <span class="comment">//这里不采用注解注入, 使用构造器注入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span>  LOGIN_USER_KEY + token;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据token判断用户是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//不能返回false, 应该放行交给登录拦截器处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.根据token在redis中获取用户</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断用户是否为空, 为空的原因可能有token过期</span></span><br><span class="line">        <span class="keyword">if</span>(userMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将userDTO保存到ThreadLocal中供其他方法使用</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登录拦截"><a href="#登录拦截" class="headerlink" title="登录拦截"></a>登录拦截</h3><h4 id="LoginInterceptor类"><a href="#LoginInterceptor类" class="headerlink" title="LoginInterceptor类"></a>LoginInterceptor类</h4><p>用于登录拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hmdp.dto.UserDTO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.从ThreadLocal中获取用户信息</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.用户不存在,拦截</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.用户存在,放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对ThreadLocal的管理"><a href="#对ThreadLocal的管理" class="headerlink" title="对ThreadLocal的管理"></a>对ThreadLocal的管理</h3><h4 id="UserHolder类"><a href="#UserHolder类" class="headerlink" title="UserHolder类"></a>UserHolder类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启用登录拦截器"><a href="#启用登录拦截器" class="headerlink" title="启用登录拦截器"></a>启用登录拦截器</h3><p>拦截的优先级可用order(int num)来指定, num越小优先级越高, 若不设置默认为0, 按添加的顺序拦截.</p><h4 id="MvcConfig类"><a href="#MvcConfig类" class="headerlink" title="MvcConfig类"></a>MvcConfig类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hmdp.utils.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.RefreshTokenInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>, <span class="string">&quot;shop-type/**&quot;</span>, <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>, <span class="string">&quot;/user/code&quot;</span>, <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">        ).order(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h2><p><img src="/img/2022-12-15-21-24-47-image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 根据id在redis中查询</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopStr)) &#123;</span><br><span class="line">        <span class="comment">//3. 存在直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 不存在在数据库中查询</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 数据库中查询不到则返回错误信息401</span></span><br><span class="line">    <span class="keyword">if</span>(shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 数据库查询到保存到redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 返回Shop</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p><img src="/img/2022-12-15-21-30-14-image.png"></p><p><img src="/img/2022-12-15-21-29-51-image.png"></p><img title="" src="/img/2022-12-15-21-31-26-image.png" alt="" data-align="inline"><p><img src="/img/2022-12-15-21-32-33-image.png"></p><p>根据分析可得对于较为<strong>频繁</strong>访问的数据采用<strong>主动更新</strong>的策略, 更新时选择<strong>先操作数据库, 再删除缓存</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 判断该商品是否存在</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 不存在返回错误</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商品不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 存在更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 删除Redis</span></span><br><span class="line">    stringRedisTemplate.delete(CACHE_SHOP_KEY + id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="/img/2022-12-15-22-02-24-image.png"></p><p>因为布隆过滤器实现较为复杂, 在此选择实现<strong>缓存空对象</strong></p><p><img src="/img/2022-12-15-22-03-08-image.png"></p><p>在<strong>商铺缓存</strong>中采用<strong>缓存空对象</strong>来解决<strong>缓存击穿</strong>的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 根据id在redis中查询</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopStr)) &#123;  <span class="comment">//isNotBlank()能检测null、&quot;&quot;和&quot;\n\t&quot;</span></span><br><span class="line">        <span class="comment">//3. 存在直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 判断从Redis中查到的值是否为&quot;&quot;, 是则直接返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span>(shopStr != <span class="literal">null</span>) &#123;  <span class="comment">//如果不是null表明是&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺信息出错~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 不存在在数据库中查询</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 数据库中查询不到则返回错误信息401.</span></span><br><span class="line">    <span class="comment">//   并且为了防止缓存穿透, 将一个空值存入Redis中, 设置短TTL</span></span><br><span class="line">    <span class="keyword">if</span>(shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 数据库查询到保存到redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 返回Shop</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><img src="/img/2022-12-15-22-20-46-image.png"></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="/img/2022-12-15-22-45-20-image.png"></p><p><img src="/img/2022-12-15-22-46-19-image.png"></p><p><img src="/img/2022-12-15-22-46-37-image.png"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img src="/img/2022-12-15-22-47-08-image.png"></p><h4 id="用Redis实现锁"><a href="#用Redis实现锁" class="headerlink" title="用Redis实现锁"></a>用Redis实现锁</h4><p>redis的SETNX命令（SET if Not eXists）</p><p>　　语法：SETNX key value</p><p>　　功能：当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用递归实现互斥锁"><a href="#用递归实现互斥锁" class="headerlink" title="用递归实现互斥锁"></a>用递归实现互斥锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 根据id在redis中查询</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopStr)) &#123;  <span class="comment">//isNotBlank()能检测null、&quot;&quot;和&quot;\n\t&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 存在直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 判断从Redis中查到的值是否为&quot;&quot;, 是则直接返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span>(shopStr != <span class="literal">null</span>) &#123;  <span class="comment">//如果不是null表明是&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺信息出错~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 尝试获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 判断是否获得互斥锁</span></span><br><span class="line">    <span class="keyword">if</span>(tryLock(lockKey)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.1.1 如果有锁就根据id查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.1.2 数据库中查询不到则返回错误信息401.</span></span><br><span class="line">        <span class="comment">//      并且为了防止缓存穿透, 将一个空值存入Redis中, 设置短TTL</span></span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.1.3 数据库查询到保存到redis中</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.1.4 释放锁</span></span><br><span class="line">        unLock(lockKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.1.5 返回Shop</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2.1 无锁则休眠一段时间</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJSON</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//5.2.2 休眠过后再次在Redis中查询店铺缓存</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(shopJSON)) &#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJSON, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.2.3 未命中就递归</span></span><br><span class="line">        <span class="keyword">return</span> queryShopById(id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        unLock(String key)</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用while循环实现互斥锁"><a href="#用while循环实现互斥锁" class="headerlink" title="用while循环实现互斥锁"></a>用while循环实现互斥锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//1. 根据id在redis中查询</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopStr)) &#123;  <span class="comment">//isNotBlank()能检测null、&quot;&quot;和&quot;\n\t&quot;</span></span><br><span class="line">            <span class="comment">//3. 存在直接返回</span></span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 判断从Redis中查到的值是否为&quot;&quot;, 是则直接返回错误信息</span></span><br><span class="line">        <span class="keyword">if</span>(shopStr != <span class="literal">null</span>) &#123;  <span class="comment">//如果不是null表明是&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺信息出错~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 尝试获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 判断是否获得互斥锁</span></span><br><span class="line">        <span class="keyword">if</span>(tryLock(lockKey)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//5.1.1 如果有锁就根据id查询数据库</span></span><br><span class="line">                <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>); <span class="comment">//模拟查询操作进行了200ms</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.1.2 数据库中查询不到则返回错误信息401.</span></span><br><span class="line">            <span class="comment">//      并且为了防止缓存穿透, 将一个空值存入Redis中, 设置短TTL</span></span><br><span class="line">            <span class="keyword">if</span>(shop == <span class="literal">null</span>) &#123;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.1.3 数据库查询到保存到redis中</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.1.4 释放锁</span></span><br><span class="line">            unLock(lockKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.1.5 返回Shop</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//5.2.1 无锁则休眠一段时间后继续while循环</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;睡出事了~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p><img src="/img/2022-12-16-18-18-57-image.png"></p><h4 id="RedisData类"><a href="#RedisData类" class="headerlink" title="RedisData类"></a>RedisData类</h4><p>需要在原先类上加上一个逻辑过期日期, 为了避免改源代码, 所以有两种方法, 让RedisData类继承原始类, 或者设置一个Object类型的变量, 这里选择后者.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServiceImpl类"><a href="#ServiceImpl类" class="headerlink" title="ServiceImpl类"></a>ServiceImpl类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByIdByExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 从Redis中查商铺缓存</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopJSON</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 判断是否命中</span></span><br><span class="line">            <span class="keyword">if</span>(StrUtil.isBlank(shopJSON)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//3. 未命中返回空(因为是热点Key, 不存在不命中的情况, 如果不命中表明这不是热点Key, 直接返回空)</span></span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 命中判断逻辑是否过期</span></span><br><span class="line">            <span class="type">RedisData</span> <span class="variable">shopData</span> <span class="operator">=</span> JSONUtil.toBean(shopJSON, RedisData.class);</span><br><span class="line">            <span class="keyword">if</span>(!shopData.getExpireTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">                <span class="comment">//4.1 未过期则返回店铺信息</span></span><br><span class="line">                <span class="keyword">return</span> Result.ok(shopData.getData());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.2 过期则尝试获取互斥锁</span></span><br><span class="line">            <span class="comment">//4.3 判断是否获取锁</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!tryLock(lockKey)) &#123;</span><br><span class="line">                <span class="comment">//4.3.1 获取不到锁直接返回店铺信息</span></span><br><span class="line">                <span class="keyword">return</span> Result.ok(shopData.getData());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.3.2.1 获取到判断逻辑日期是否过期</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopJSON2</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="type">RedisData</span> <span class="variable">shopData2</span> <span class="operator">=</span> JSONUtil.toBean(shopJSON2, RedisData.class);</span><br><span class="line">            <span class="keyword">if</span>(shopData2.getExpireTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//4.3.2.3 未过期返回结果</span></span><br><span class="line">                <span class="keyword">return</span> Result.ok(shopData2.getData());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.3.2.2 过期开启独立线程</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//4.3.2.2.1 根据id查询数据库, 将查询到的店铺数据写入Redis, 并设置逻辑过期时间</span></span><br><span class="line">                    <span class="built_in">this</span>.saveByExpire(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//4.3.2.2.2 释放互斥锁</span></span><br><span class="line">                    unLock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h2><h3 id="初始化与方法"><a href="#初始化与方法" class="headerlink" title="初始化与方法"></a>初始化与方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;  <span class="comment">//不采用注解注入, 采用构造器注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存与逻辑缓存-String"><a href="#缓存与逻辑缓存-String" class="headerlink" title="缓存与逻辑缓存(String)"></a>缓存与逻辑缓存(String)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">objectRedisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>&lt;&gt;(LocalDateTime.now().plusSeconds(unit.toSeconds(timeout)), value);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(objectRedisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 根据id在redis中查询</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 判断是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;  <span class="comment">//isNotBlank()能检测null、&quot;&quot;和&quot;\n\t&quot;</span></span><br><span class="line">                <span class="comment">//3. 存在直接返回</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> JSONUtil.toBean(json, type);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 判断从Redis中查到的值是否为&quot;&quot;, 是则直接返回错误信息</span></span><br><span class="line">            <span class="keyword">if</span>(json != <span class="literal">null</span>) &#123;  <span class="comment">//如果不是null表明是&quot;&quot;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.1.2 数据库中查询不到则返回错误信息401.</span></span><br><span class="line">            <span class="comment">//    并且为了防止缓存穿透, 将一个空值存入Redis中, 设置短TTL</span></span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">null</span>) &#123;</span><br><span class="line">                set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.1.3 数据库查询到保存到redis中</span></span><br><span class="line">            set(key, result, timeout, unit);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.1.5 返回Shop</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存穿透-缓存击穿-while互斥锁"><a href="#缓存穿透-缓存击穿-while互斥锁" class="headerlink" title="缓存穿透+缓存击穿(while互斥锁)"></a>缓存穿透+缓存击穿(while互斥锁)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThroughAndLock</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 根据id在redis中查询</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 判断是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;  <span class="comment">//isNotBlank()能检测null、&quot;&quot;和&quot;\n\t&quot;</span></span><br><span class="line">                <span class="comment">//3. 存在直接返回</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> JSONUtil.toBean(json, type);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 判断从Redis中查到的值是否为&quot;&quot;, 是则直接返回错误信息</span></span><br><span class="line">            <span class="keyword">if</span>(json != <span class="literal">null</span>) &#123;  <span class="comment">//如果不是null表明是&quot;&quot;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 尝试获取互斥锁</span></span><br><span class="line">            <span class="comment">//5. 判断是否获得互斥锁</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">            <span class="keyword">if</span>(tryLock(lockKey)) &#123;</span><br><span class="line">                <span class="comment">//5.1.1 如果有锁就根据id查询数据库</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//5.1.2 数据库中查询不到则返回错误信息401.</span></span><br><span class="line">                <span class="comment">//      并且为了防止缓存穿透, 将一个空值存入Redis中, 设置短TTL</span></span><br><span class="line">                <span class="keyword">if</span>(result == <span class="literal">null</span>) &#123;</span><br><span class="line">                    set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//5.1.3 数据库查询到保存到redis中</span></span><br><span class="line">                set(key, result, timeout, unit);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//5.1.4 释放锁</span></span><br><span class="line">                unLock(lockKey);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//5.1.5 返回Shop</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//5.2.1 无锁则休眠一段时间后继续while循环</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;睡出事了~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存击穿-逻辑过期"><a href="#缓存击穿-逻辑过期" class="headerlink" title="缓存击穿(逻辑过期)"></a>缓存击穿(逻辑过期)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*R result = dbFallback.apply(id);</span></span><br><span class="line"><span class="comment">        setWithLogicalExpire(key, result, timeout, unit);</span></span><br><span class="line"><span class="comment">        return result;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 从Redis中查商铺缓存</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 判断是否命中</span></span><br><span class="line">            <span class="keyword">if</span>(StrUtil.isBlank(json)) &#123;</span><br><span class="line">                <span class="comment">//3. 未命中返回空(因为是热点Key, 不存在不命中的情况, 如果不命中表明这不是热点Key, 直接返回空)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 命中判断逻辑是否过期</span></span><br><span class="line">            <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">            <span class="keyword">if</span>(redisData.getExpireTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">                <span class="comment">//4.1 未过期则返回店铺信息</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.2 过期则尝试获取互斥锁</span></span><br><span class="line">            <span class="comment">//4.3 判断是否获取锁</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">            <span class="keyword">if</span>(!tryLock(lockKey)) &#123;</span><br><span class="line">                <span class="comment">//4.3.1 获取不到锁直接返回店铺信息</span></span><br><span class="line">                <span class="keyword">return</span> (R)redisData.getData();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.3.2.1 获取到判断逻辑日期是否过期</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json2</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="type">RedisData</span> <span class="variable">redisData2</span> <span class="operator">=</span> JSONUtil.toBean(json2, RedisData.class);</span><br><span class="line">            <span class="keyword">if</span>(redisData2.getExpireTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">                <span class="comment">//4.3.2.3 未过期返回结果</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.3.2.2 过期开启独立线程</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//4.3.2.2.1 根据id查询数据库, 将查询到的店铺数据写入Redis, 并设置逻辑过期时间</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                setWithLogicalExpire(key, r, timeout, unit);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//4.3.2.2.2 释放互斥锁</span></span><br><span class="line">                unLock(lockKey);</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="工具类的调用"><a href="#工具类的调用" class="headerlink" title="工具类的调用"></a>工具类的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByIdByLock</span><span class="params">(Long id)</span> &#123; <span class="comment">/**lambda表达式: id -&gt; getById(id) = this.getById*/</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByIdByExpire</span><span class="params">(Long id)</span> &#123; <span class="comment">/**lambda表达式: id -&gt; getById(id) = this.getById*/</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, <span class="number">30L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺为空~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于Redis的全局ID生成器"><a href="#基于Redis的全局ID生成器" class="headerlink" title="基于Redis的全局ID生成器"></a>基于Redis的全局ID生成器</h2><p><img src="/img/2022-12-18-23-20-15-image.png"></p><p><img src="/img/2022-12-18-23-20-32-image.png"></p><p><img src="/img/2022-12-18-23-20-46-image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1664582400L</span>; <span class="comment">//开始时间戳, 由main函数得到</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 生成序列号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; <span class="number">32</span> | count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到当前时间戳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2022</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">second</span> <span class="operator">=</span> time.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        System.out.println(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁 &amp; 悲观锁"></a>乐观锁 &amp; 悲观锁</h2><p><img src="/img/2022-12-18-23-23-11-image.png"></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="版本号法"><a href="#版本号法" class="headerlink" title="版本号法"></a>版本号法</h4><p><img src="/img/2022-12-18-23-22-39-image.png"></p><h4 id="CAS法"><a href="#CAS法" class="headerlink" title="CAS法"></a>CAS法</h4><p><img src="/img/2022-12-18-23-24-37-image.png"></p><h3 id="用CAS法-乐观锁-解决超卖问题"><a href="#用CAS法-乐观锁-解决超卖问题" class="headerlink" title="用CAS法(乐观锁)解决超卖问题"></a>用CAS法(乐观锁)解决超卖问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查询优惠券, 判断是否存在</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="keyword">if</span>(voucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠券不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">//秒杀尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">//秒杀已经结束</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 扣减库存(乐观锁)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)  <span class="comment">//set stock = stock - 1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId) <span class="comment">//where voucher_id = voucherId</span></span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)  <span class="comment">//where stock&gt;0  (乐观锁)</span></span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span>(!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用悲观锁解决一人一卖问题"><a href="#用悲观锁解决一人一卖问题" class="headerlink" title="用悲观锁解决一人一卖问题"></a>用悲观锁解决一人一卖问题</h3><p>注意: 事务的有效性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查询优惠券, 判断是否存在</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="keyword">if</span>(voucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠券不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">//秒杀尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">//秒杀已经结束</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;  <span class="comment">//userId.toString().intern()保证了只对同一个对象上锁</span></span><br><span class="line">        <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//根据用户id和优惠券id查询该用户是否购买过该优惠券</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;每位用户限购一张&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 扣减库存(乐观锁)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)  <span class="comment">//set stock = stock - 1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId) <span class="comment">//where voucher_id = voucherId</span></span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)  <span class="comment">//where stock&gt;0</span></span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span>(!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><p>pom文件需要加入以下依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>前边用悲观锁实现的一人一卖存在的问题: 不同的JVM获取的不是同一把锁, 因为NGINX是负载均衡的, 当一个用户同时访问页面会被分配到不同的服务器, 不同的服务器之间的锁不共用, 从而出现错误. 而分布式锁可以解决这个问题.</p><p><img src="/img/2022-12-19-23-10-37-image.png"></p><p><img src="/img/2022-12-19-23-16-20-image.png"></p><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h3><img title="" src="/img/2022-12-19-23-51-46-image.png" alt="" data-align="center"><p><img src="/img/2022-12-19-23-51-14-image.png"></p><h4 id="如果释放锁时不判断锁标识是否是自己"><a href="#如果释放锁时不判断锁标识是否是自己" class="headerlink" title="如果释放锁时不判断锁标识是否是自己"></a>如果释放锁时不判断锁标识是否是自己</h4><p><img src="/img/2022-12-19-23-52-55-image.png"></p><h4 id="用Redis分布式锁解决一人一卖"><a href="#用Redis分布式锁解决一人一卖" class="headerlink" title="用Redis分布式锁解决一人一卖"></a>用Redis分布式锁解决一人一卖</h4><h5 id="SimpleRedisLock类"><a href="#SimpleRedisLock类" class="headerlink" title="SimpleRedisLock类"></a>SimpleRedisLock类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.lang.UUID;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;  <span class="comment">//标识不同进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeout, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(tryLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">        <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="VoucherOrderServiceImpl类"><a href="#VoucherOrderServiceImpl类" class="headerlink" title="VoucherOrderServiceImpl类"></a>VoucherOrderServiceImpl类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="type">SimpleRedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="keyword">if</span>(!isLock) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;黄牛滚啊[○･｀Д´･ ○]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    redisLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p><img src="/img/2022-12-20-00-00-39-image.png"></p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p><img src="/img/2022-12-20-00-01-27-image.png"></p><p>官网地址： <a href="https://redisson.org/">https://redisson.org</a></p><p>GitHub地址： <a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p><p><img src="/img/2022-12-20-00-42-42-image.png"></p><h4 id="Redisson配置"><a href="#Redisson配置" class="headerlink" title="Redisson配置"></a>Redisson配置</h4><p>注意: 不推荐使用在创建项目时SpringBoot选中Redisson</p><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;    </span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="配置Redisson客户端"><a href="#配置Redisson客户端" class="headerlink" title="配置Redisson客户端"></a>配置Redisson客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 配置类</span></span><br><span class="line">       <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">       config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>).setPassowrd(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">       <span class="comment">// 创建客户端</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Redisson分布式锁解决一人一卖"><a href="#使用Redisson分布式锁解决一人一卖" class="headerlink" title="使用Redisson分布式锁解决一人一卖"></a>使用Redisson分布式锁解决一人一卖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span>(!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;黄牛滚啊[○･｀Д´･ ○]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="Redisson分布式锁原理"><a href="#Redisson分布式锁原理" class="headerlink" title="Redisson分布式锁原理"></a>Redisson分布式锁原理</h4><p><img src="/img/2022-12-20-00-38-56-image.png"></p><h4 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a>Redisson可重入锁原理</h4><p><img src="/img/2022-12-20-00-37-52-image.png"></p><h5 id="获取锁的Lua脚本"><a href="#获取锁的Lua脚本" class="headerlink" title="获取锁的Lua脚本"></a>获取锁的Lua脚本</h5><p><img src="/img/2022-12-20-00-39-37-image.png"></p><h5 id="释放锁的Lua脚本"><a href="#释放锁的Lua脚本" class="headerlink" title="释放锁的Lua脚本"></a>释放锁的Lua脚本</h5><p><img src="/img/2022-12-20-00-41-21-image.png"></p><h4 id="Redisson分布式锁主从一致性"><a href="#Redisson分布式锁主从一致性" class="headerlink" title="Redisson分布式锁主从一致性"></a>Redisson分布式锁主从一致性</h4><p>需要所有Redis服务器<strong>同时获得锁</strong>才可以执行业务代码</p><p><img src="/img/2022-12-20-00-43-40-image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RLock lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonClient2.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonClient3.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建联锁</span></span><br><span class="line">    lock = redissonClient.getMultiLock(lock1, lock2, lock3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis在点赞业务中的应用"><a href="#Redis在点赞业务中的应用" class="headerlink" title="Redis在点赞业务中的应用"></a>Redis在点赞业务中的应用</h2><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原始文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成新文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存文件</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String <span class="title function_">createNewFileName</span><span class="params">(String originalFilename)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取后缀</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> StrUtil.subAfter(originalFilename, <span class="string">&quot;.&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成目录</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> name.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> hash &amp; <span class="number">0xF</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> (hash &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断目录是否存在</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, StrUtil.format(<span class="string">&quot;/blogs/&#123;&#125;/&#123;&#125;&quot;</span>, d1, d2));</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">        dir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成文件名</span></span><br><span class="line">    <span class="keyword">return</span> StrUtil.format(<span class="string">&quot;/blogs/&#123;&#125;/&#123;&#125;/&#123;&#125;.&#123;&#125;&quot;</span>, d1, d2, name, suffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TableField-exist-x3D-false-注解"><a href="#TableField-exist-x3D-false-注解" class="headerlink" title="@TableField(exist &#x3D; false)注解"></a>@TableField(exist &#x3D; false)注解</h3><p><code>@TableField(exist = false)</code> 注解可以解决表中表的问题，加载bean属性上，<strong>表示当前属性不是数据库的字段</strong>，<strong>但在项目中必须使用</strong>，这样可以用来把一个数据表当作一个字段来输出，用来实现表中表数据输出。这样设置在新增等使用bean的时候，mybatis-plus就会忽略这个，不会报错</p><h4 id="点赞高亮"><a href="#点赞高亮" class="headerlink" title="点赞高亮"></a>点赞高亮</h4><p>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</p><h5 id="Blog类"><a href="#Blog类" class="headerlink" title="Blog类"></a>Blog类</h5><p>包含用<code>@TableField(exist = false)</code>注解的属性<code>isLike</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure><h5 id="BlogServiceImpl类"><a href="#BlogServiceImpl类" class="headerlink" title="BlogServiceImpl类"></a>BlogServiceImpl类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getBlogById</span><span class="params">(Long blogId)</span> &#123;</span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(blogId);</span><br><span class="line">    <span class="keyword">if</span>(blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;Blog不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isLike(blog);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isLike</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + blog.getId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">    <span class="comment">//(score == null) ? blog.setIsLike(false) : blog.setIsLike(true); 我的猪鼻写法</span></span><br><span class="line">    blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis在点赞业务中的应用-1"><a href="#Redis在点赞业务中的应用-1" class="headerlink" title="Redis在点赞业务中的应用"></a>Redis在点赞业务中的应用</h3><p><img src="/img/2022-12-22-01-57-36-image.png"></p><h4 id="Redis数据结构的选择"><a href="#Redis数据结构的选择" class="headerlink" title="Redis数据结构的选择"></a>Redis数据结构的选择</h4><p><img src="/img/2022-12-22-01-55-14-image.png"></p><h4 id="点赞的实现"><a href="#点赞的实现" class="headerlink" title="点赞的实现"></a>点赞的实现</h4><ul><li><p>将当前时间的毫秒数作为得分(score), 点赞越早得分越高</p></li><li><p>将指定前缀和BlogId拼接起来作为key</p></li><li><p>将已点赞的用id集合作为value</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long blogId)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取Blog对象</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(blogId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断Blog对象是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;Blog不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 存在则通过Thread获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 判断该用户是否点过赞</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + blogId;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 点过赞则取消点赞(数据库), 将用户从Blog的点赞Redis中删除</span></span><br><span class="line">    <span class="keyword">if</span>(score != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">cancel</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, blogId).update();</span><br><span class="line">        <span class="keyword">if</span>(cancel) &#123;</span><br><span class="line">            stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">            blog.setIsLike(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;点赞出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 未点过赞则点赞(数据库), 将用户加入Blog的点赞Redis</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, blogId).update();</span><br><span class="line">    <span class="keyword">if</span>(!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;点赞出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">    blog.setIsLike(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="点赞排行榜的实现"><a href="#点赞排行榜的实现" class="headerlink" title="点赞排行榜的实现"></a>点赞排行榜的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryLikes</span><span class="params">(Long blogId)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 得到blog, 判断是否存在</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(blogId);</span><br><span class="line">    <span class="keyword">if</span>(blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;blog不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 得到Key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + blogId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 得到点赞集合</span></span><br><span class="line">    Set&lt;String&gt; strings = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 判断集合是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(strings == <span class="literal">null</span> || strings.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//5. 为空则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 不为空, 则解析出其中的用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = strings.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 根据用户Id查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)</span><br><span class="line">            .stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//4. 返回前五名</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis消息队列实现异步秒杀"><a href="#Redis消息队列实现异步秒杀" class="headerlink" title="Redis消息队列实现异步秒杀"></a>Redis消息队列实现异步秒杀</h2><p>!!!注意: 因为Redis Stream 是 Redis 5.0 版本新增加的数据结构, 因此需要Redis版本至少为5.0, 不然就会疯狂报错o(╥﹏╥)o</p><p>写在前面: 虽然主流的消息队列技术是MQ等, 这些技术与Redis的消息队列思想大同小异, 并且有些小企业因为业务较小, 不搭建MQ集群, 选择使用Redis来完成消息队列功能, 因此该技术的学习还是很有必要的.</p><h3 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h3><p>当前我们采用串行的方法执行一人一单, 下单流程如下:</p><p>当用户发起请求，此时会请求 nginx，nginx 会访问到 tomcat，而 tomcat 中的程序，会进行串行操作，分成如下几个步骤</p><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、查询订单</p><p>4、校验是否是一人一单</p><p>5、扣减库存</p><p>6、创建订单</p><p><img src="/img/2022-12-22-02-32-44-image.png"></p><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>将订单资格判断放入到 Redis 中，只要资格通过就返回一个订单消息, 并且将下单任务添加到消息队列中.</p><p>后台有一个线程时刻读取并执行消息队列中的任务, 当队列中没有任务时就阻塞等待, 直到有新任务进入队列.</p><p>该方案将判断订单资格和将订单写入数据库分开执行, 用户在很短时间内就可以得到下单成功与否的反馈, 而写入数据库的操作可以慢慢完成.</p><p><img src="/img/2022-12-22-02-34-06-image.png"></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><img src="/img/2022-12-22-02-20-46-image.png"></p><h3 id="消息队列数据结构的选择"><a href="#消息队列数据结构的选择" class="headerlink" title="消息队列数据结构的选择"></a>消息队列数据结构的选择</h3><p><img src="/img/2022-12-22-13-59-44-image.png"></p><h4 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h4><p><img src="/img/2022-12-22-02-25-57-image.png"></p><p><img src="/img/2022-12-22-02-26-31-image.png"></p><p><img src="/img/2022-12-22-02-27-05-image.png"></p><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p><img src="/img/2022-12-22-13-55-49-image.png"></p><p><img src="/img/2022-12-22-14-04-56-image.png"></p><h3 id="基于Stream的异步秒杀实现"><a href="#基于Stream的异步秒杀实现" class="headerlink" title="基于Stream的异步秒杀实现"></a>基于Stream的异步秒杀实现</h3><ol><li><p>创建一个Stream类型的消息队列，名为stream.orders.</p></li><li><p>新增秒杀优惠券的同时，将优惠券信息保存到 Redis 中.</p></li><li><p>基于<strong>Lua 脚本</strong>，判断秒杀库存、一人一单，决定用户是否抢购成功. 成功直接向stream.orders中添加消息，内容包含<strong>voucherId、userId、orderId</strong>(因为整个过程需要保证<strong>原子性</strong>, 所以需要使用Lua脚本).</p></li><li><p>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单. 实现抢购与下单异步.</p></li></ol><p><img src="/img/2022-12-22-02-47-09-image.png"></p><h4 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h4><p>用Lua脚本实现资格判断和向消息队列中添加信息</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stoc:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="VoucherOrderServiceImpl类-1"><a href="#VoucherOrderServiceImpl类-1" class="headerlink" title="VoucherOrderServiceImpl类"></a>VoucherOrderServiceImpl类</h4><h5 id="异步处理线程池"><a href="#异步处理线程池" class="headerlink" title="异步处理线程池"></a>异步处理线程池</h5><p>@<strong>PostConstruct</strong>注解: 被注解的方法，在对象加载完依赖注入后执行。</p><p>此注解是在Java EE5规范中加入的，在Servlet生命周期中有一定作用，它通常都是一些初始化的操作，但初始化可能依赖于注入的其他组件，所以要等依赖全部加载完再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程处理业务"><a href="#线程处理业务" class="headerlink" title="线程处理业务"></a>线程处理业务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    SreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用Lua脚本"><a href="#调用Lua脚本" class="headerlink" title="调用Lua脚本"></a>调用Lua脚本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));<span class="comment">//在Resource文件里调用Lua脚本, 脚本文件名:seckill.lua</span></span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IVoucherOrderService proxy;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.获取代理对象</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加秒杀券业务-amp-创建订单业务"><a href="#添加秒杀券业务-amp-创建订单业务" class="headerlink" title="添加秒杀券业务 &amp; 创建订单业务"></a>添加秒杀券业务 &amp; 创建订单业务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">// 在数据库中扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在数据库中创建订单</span></span><br><span class="line">        save(voucherOrder);</span><br></pre></td></tr></table></figure><h2 id="Redis实现共同关注"><a href="#Redis实现共同关注" class="headerlink" title="Redis实现共同关注"></a>Redis实现共同关注</h2><h3 id="数据结构的选择"><a href="#数据结构的选择" class="headerlink" title="数据结构的选择"></a>数据结构的选择</h3><ul><li><p>Redis中的<strong>集合元素</strong>可以做<strong>并差交</strong>集操作, 同时有具有唯一性, 所以数据结构上选择集合.</p></li><li><p>没有有序性的需求, 所以选择无序的<strong>set集合</strong>.</p></li></ul><h3 id="业务步骤"><a href="#业务步骤" class="headerlink" title="业务步骤"></a>业务步骤</h3><ol><li><p>在关注时以关注人id为key, 被关注人id为value放到一个set集合中.</p></li><li><p>取关用户时将被取关人id从set集合中删除.</p></li><li><p>将当前用户与被关注人的关注列表求交集, 即可得到共同关注列表.</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="关注业务"><a href="#关注业务" class="headerlink" title="关注业务"></a>关注业务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获得登录用户的id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断是否关注</span></span><br><span class="line">    <span class="keyword">if</span>(BooleanUtil.isTrue(isFollow)) &#123;</span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span>(save) &#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().add(LIKE_COMMON_KEY + userId, followUserId.toString()); <span class="comment">//存入redis</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">remove</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span>(remove) &#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().remove(LIKE_COMMON_KEY + userId, followUserId.toString());<span class="comment">//从redis中删除</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="共同关注业务"><a href="#共同关注业务" class="headerlink" title="共同关注业务"></a>共同关注业务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long followId)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 求交集</span></span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet(</span><br><span class="line">            .intersect(LIKE_COMMON_KEY + userId, LIKE_COMMON_KEY + followId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//为空返回一个空集合</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 处理数据</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    List&lt;UserDTO&gt; commonUsers = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(commonUsers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis实现关注推送"><a href="#Redis实现关注推送" class="headerlink" title="Redis实现关注推送"></a>Redis实现关注推送</h2><p><img src="/img/2022-12-23-15-53-04-image.png"></p><h3 id="Feed流模式"><a href="#Feed流模式" class="headerlink" title="Feed流模式"></a>Feed流模式</h3><p><img src="/img/2022-12-23-15-54-07-image.png"></p><h4 id="Feed流的三种实现方案"><a href="#Feed流的三种实现方案" class="headerlink" title="Feed流的三种实现方案"></a>Feed流的三种实现方案</h4><h5 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h5><p><img src="/img/2022-12-23-15-55-41-image.png"></p><h5 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h5><p><img src="/img/2022-12-23-15-56-28-image.png"></p><h5 id="推拉结合模式"><a href="#推拉结合模式" class="headerlink" title="推拉结合模式"></a>推拉结合模式</h5><p><img src="/img/2022-12-23-15-56-53-image.png"></p><h5 id="三种模式的比较"><a href="#三种模式的比较" class="headerlink" title="三种模式的比较"></a>三种模式的比较</h5><p><img src="/img/2022-12-23-15-57-29-image.png">  </p><p>在此我们选择实现最容易的<strong>推模式</strong></p><h3 id="基于推模式实现关注推送功能"><a href="#基于推模式实现关注推送功能" class="headerlink" title="基于推模式实现关注推送功能"></a>基于推模式实现关注推送功能</h3><h4 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h4><p><img src="/img/2022-12-23-16-00-29-image.png"></p><h5 id="滚动分页VS角标分页"><a href="#滚动分页VS角标分页" class="headerlink" title="滚动分页VS角标分页"></a>滚动分页VS角标分页</h5><p>滚动分页更好更人性化. 可以参考刷朋友圈, 角标分页可能会出现向下滚动分页时出现了两条作者和内容都相同的朋友圈., 而滚动分页就不会出现这样的情况. 当需要阅读新发布的一条朋友圈时可以滑到最前面查看.</p><h6 id="角标分页"><a href="#角标分页" class="headerlink" title="角标分页"></a>角标分页</h6><p><img src="/img/2022-12-23-16-08-49-image.png"></p><h6 id="滚动分页"><a href="#滚动分页" class="headerlink" title="滚动分页"></a>滚动分页</h6><p>当出现<strong>时间戳一样</strong>的情况时, 需要借助<strong>偏移量offset</strong>来实现</p><p><img src="/img/2022-12-23-16-09-26-image.png"></p><h4 id="业务步骤-1"><a href="#业务步骤-1" class="headerlink" title="业务步骤"></a>业务步骤</h4><img src="/img/2022-12-23-16-19-29-image.png" title="" alt="" width="959"><ol><li><p>需要满足时间戳排序和滚动分页, 可以使用ZSet集合存放关注列表发布的Blog</p></li><li><p>作者发布Blog时需要获取其粉丝列表</p></li><li><p>发布成功后需要将BlogId推送至粉丝的ZSet集合中</p></li><li><p>当用户查看点击关注按钮时获取其ZSet集合中的BlogId集合</p></li><li><p>将BlogId集合转化为Blog集合, 再加上minTime和offset形成一个新的类对象返回给前端实现分页</p></li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="发布博客业务"><a href="#发布博客业务" class="headerlink" title="发布博客业务"></a>发布博客业务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    blog.setUserId(userId);</span><br><span class="line">    <span class="comment">// 保存探店博文</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!save) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;发布博客失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该用户粉丝列表</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, userId).list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将博文Id推送到每个粉丝的Redis ZSet集合中</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">followId</span> <span class="operator">=</span> follow.getId();</span><br><span class="line">        stringRedisTemplate.opsForZSet()</span><br><span class="line">                .add(FEED_KEY + followId, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查看关注列表博客"><a href="#查看关注列表博客" class="headerlink" title="查看关注列表博客"></a>查看关注列表博客</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getLikeBlog</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获得当前用户Id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 在Redis中获得关注列表的BlogId集合</span></span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(FEED_KEY + userId, <span class="number">0</span>, max, offset, PRE_BLOG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 解析数据</span></span><br><span class="line">    ArrayList&lt;Object&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size()); <span class="comment">//不采用自动扩容, 提高效率</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 获得博客id</span></span><br><span class="line">        ids.add(Long.valueOf(typedTuple.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 获得分数(时间戳)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typedTuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime) &#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 防止出现多页最小时间相同的情况  1 1 1 1 1 1 5 5</span></span><br><span class="line">    <span class="keyword">if</span>(max == minTime) &#123;</span><br><span class="line">        os += offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8. 将blogId集合转化成blog集合</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogList = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;order by field(id, &quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogList) &#123;</span><br><span class="line">        isLike(blog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//9. 返回封装类</span></span><br><span class="line">    <span class="type">LikeBlogs</span> <span class="variable">blogs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LikeBlogs</span>();</span><br><span class="line">    blogs.setList(blogList);</span><br><span class="line">    blogs.setLastId(minTime);</span><br><span class="line">    blogs.setOffset(os);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(blogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis实现附近商铺功能"><a href="#Redis实现附近商铺功能" class="headerlink" title="Redis实现附近商铺功能"></a>Redis实现附近商铺功能</h2><h3 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h3><p><img src="/img/2022-12-23-23-28-37-image.png">  </p><h3 id="附近商铺搜索"><a href="#附近商铺搜索" class="headerlink" title="附近商铺搜索"></a>附近商铺搜索</h3><p><img src="/img/2022-12-23-23-30-44-image.png"></p><h4 id="将店铺存入GEO集合"><a href="#将店铺存入GEO集合" class="headerlink" title="将店铺存入GEO集合"></a>将店铺存入GEO集合</h4><p><img src="/img/2022-12-23-23-34-30-image.png"></p><p>这里选择在for循环里将商铺位置放到集合中, 最后在将集合存到Redis里.</p><p>而不选择在for循环中将商铺一个一个存入Redis, 因为这样每次都要与Redis建立连接,  效率不如直接将集合存入Redis.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 查询店铺信息</span></span><br><span class="line">List&lt;Shop&gt; list = list();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 将店铺按照typeId分组, 相同typeId的放到一组</span></span><br><span class="line">Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 分批写入redis</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">//3.1 获取类型id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;shop:geo:&quot;</span> + typeId;</span><br><span class="line">    <span class="comment">//3.2 获取相同类型店铺集合</span></span><br><span class="line">    List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">    List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">    <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">      <span class="comment">//不选择:</span></span><br><span class="line">      <span class="comment">//stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString));</span></span><br><span class="line">        locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                shop.getId().toString(), <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>spring-data-redis 2.3.9 版本并不支持 Redis 6.2 提供的 GEOSEARCH 命令，因此我们需要提升版本，修改自己的 POM文件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">6.1</span><span class="number">.6</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="实现类方法"><a href="#实现类方法" class="headerlink" title="实现类方法"></a>实现类方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopp</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">        Page&lt;Shop&gt; page = query()</span><br><span class="line">                .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 返回数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.计算分页参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">            .search(</span><br><span class="line">                    key,</span><br><span class="line">                    GeoReference.fromCoordinate(x, y),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                    RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解析出id</span></span><br><span class="line">    <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">        <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">    Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">    list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">        <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">        ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">        <span class="comment">// 4.3.获取距离</span></span><br><span class="line">        <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">        distanceMap.put(shopIdStr, distance);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">    <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis实现签到功能"><a href="#Redis实现签到功能" class="headerlink" title="Redis实现签到功能"></a>Redis实现签到功能</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p><img src="/img/2022-12-24-14-35-43-image.png"></p><p><img src="/img/2022-12-24-14-36-32-image.png"></p><h4 id="BitMap的用法"><a href="#BitMap的用法" class="headerlink" title="BitMap的用法"></a>BitMap的用法</h4><p><img src="/img/2022-12-24-14-37-16-image.png"></p><h3 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h3><p><img src="/img/2022-12-24-14-37-51-image.png"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获得当前用户id, 作为key的中间部分</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获得当前年月作为key的后缀</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获得今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 写入Redis setbit key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="string">&quot;签到成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><p><img src="/img/2022-12-24-15-08-33-image.png"></p><h4 id="实现签到统计功能"><a href="#实现签到统计功能" class="headerlink" title="实现签到统计功能"></a>实现签到统计功能</h4><p><img src="/img/2022-12-24-15-09-35-image.png"></p><h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获得当前用户id, 作为key的中间部分</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获得当前年月作为key的后缀</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获得今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 从Redis中获得签到表</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create().get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 非空/非零判断</span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 循环</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((num.intValue() &amp; <span class="number">1</span>) == <span class="number">1</span> ) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="string">&quot;已连续签到&quot;</span> + count + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis实现UV统计"><a href="#Redis实现UV统计" class="headerlink" title="Redis实现UV统计"></a>Redis实现UV统计</h2><p><img src="/img/2022-12-24-15-28-07-image.png"></p><h3 id="HyperLogLog用法"><a href="#HyperLogLog用法" class="headerlink" title="HyperLogLog用法"></a>HyperLogLog用法</h3><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</p><p>相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a></p><p>Redis中的HLL是基于<strong>string结构</strong>实现的，单个HLL的内存<strong>永远小于16kb</strong>，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于0.81％的误差。不过对于UV统计来说，这完全可以忽略。</p><p><img src="/img/2022-12-24-15-29-36-image.png"></p><h3 id="实现UV统计"><a href="#实现UV统计" class="headerlink" title="实现UV统计"></a>实现UV统计</h3><p>在这里我们直接在UserController类里加入一个uv统计接口，向HyperLogLog中添加100万条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/uv&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">uv</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] values = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        j = i % <span class="number">1000</span>;  <span class="comment">//为防止数组越界, j的值为0-999</span></span><br><span class="line">        values[j] = <span class="string">&quot;user_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">999</span>) &#123;</span><br><span class="line">            <span class="comment">//每一千次写入一次</span></span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">&quot;h12&quot;</span>, values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="string">&quot;h12&quot;</span>); <span class="comment">//统计数量</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12-24-15-40-59-image.png"></p><p>可见结果与实际十分接近, 用计算器求得误差为: 0.2407%</p><p><img src="/img/2022-12-24-15-46-54-image.png"></p><p>并且内存占用很少!!!</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO流</title>
      <link href="/posts/54252.html"/>
      <url>/posts/54252.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h2><h3 id="字节流和字符流的概念"><a href="#字节流和字符流的概念" class="headerlink" title="字节流和字符流的概念"></a>字节流和字符流的概念</h3><p>Java对于文件处理是按照流的方式进行操作的（和C++ 类似 都会用到一个缓冲区），按照处理数据的单位可以分为字节流和字符流。</p><p>按照输入输出的方向可以分为输入流和输出流。</p><p><strong>字节流</strong>：每次读入或输出的是8位二进制。</p><p><strong>字符流</strong>：每次读入或输出的是16位二进制，即两个字节。</p><p><strong>根据Java API规范</strong>：</p><p>FileOutputStream用于写入原始字节流，例如图像数据。</p><p>FileWriter,用于编写字符流,例如写文本。</p><p><img src="/img/20151109094131390.jpg"></p><h2 id="节点流与处理流"><a href="#节点流与处理流" class="headerlink" title="节点流与处理流"></a>节点流与处理流</h2><p><img src="/img/2022-10-15-19-30-40-image.png" alt="本地路径"></p><p><img src="/img/2022-10-15-19-34-04-image.png"></p><p><img src="/img/2022-10-15-19-33-11-image.png"></p><h2 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h2><p>创建文件对象相关构造器和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String pathname)                    <span class="comment">//根据路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(File paraent, String child)        <span class="comment">//根据父目录文件+子路径构建</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String parent, String child)        <span class="comment">//根据父目录-子路径构建</span></span><br></pre></td></tr></table></figure><p>在E盘下三种创建文件的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">第一种:</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\news1.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">file.createNewFile();</span><br><span class="line"></span><br><span class="line">第二种:</span><br><span class="line"><span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line"><span class="comment">//这里的 file 对象，在 java 程序中，只是一个对象</span></span><br><span class="line"><span class="comment">//只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileNa</span><br><span class="line">file.createNewFile();me);</span><br><span class="line"></span><br><span class="line">第三种:</span><br><span class="line"><span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news4.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentPath, fileName);</span><br><span class="line">file.createNewFile()</span><br></pre></td></tr></table></figure><p>获取文件的相关信息的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建文件对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\news1.txt&quot;</span>);</span><br><span class="line"><span class="comment">//调用相应的方法，得到对应信息</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件名字=&quot;</span> + file.getName());</span><br><span class="line"><span class="comment">//getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件绝对路径=&quot;</span> + file.getAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;文件父级目录=&quot;</span> + file.getParent());</span><br><span class="line">System.out.println(<span class="string">&quot;文件大小(字节)=&quot;</span> + file.length());</span><br><span class="line">System.out.println(<span class="string">&quot;文件是否存在=&quot;</span> + file.exists());<span class="comment">//T</span></span><br><span class="line">System.out.println(<span class="string">&quot;是不是一个文件=&quot;</span> + file.isFile());<span class="comment">//T</span></span><br><span class="line">System.out.println(<span class="string">&quot;是不是一个目录=&quot;</span> + file.isDirectory());<span class="comment">//F</span></span><br></pre></td></tr></table></figure><h2 id="FileInputStream-字节流-文件专属"><a href="#FileInputStream-字节流-文件专属" class="headerlink" title="FileInputStream(字节流,文件专属)"></a>FileInputStream(字节流,文件专属)</h2><p>使用FileInputStream读取hello.text文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">第一种:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 单个字节的读取，效率比较低</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//创建 FileInputStream 对象，用于读取 文件</span></span><br><span class="line">fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="comment">//从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。</span></span><br><span class="line"><span class="comment">//如果返回-1 , 表示读取完毕</span></span><br><span class="line"><span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>)readData);<span class="comment">//转成 char 显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件流，释放资源.</span></span><br><span class="line">fileInputStream.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二种:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 read(byte[] b) 读取文件，提高效率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line"><span class="comment">//字节数组</span></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>]; <span class="comment">//一次读取 8 个字节. int readLen = 0;</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="comment">//从该输入流读取最多 b.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。</span></span><br><span class="line"><span class="comment">//如果返回-1 , 表示读取完毕</span></span><br><span class="line"><span class="comment">//如果读取正常, 返回实际读取的字节数</span></span><br><span class="line"><span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));<span class="comment">//显示</span></span><br><span class="line">&#125;</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure><h2 id="FileOutputStream-字节流-文件专属"><a href="#FileOutputStream-字节流-文件专属" class="headerlink" title="FileOutputStream(字节流,文件专属)"></a>FileOutputStream(字节流,文件专属)</h2><p>使用 FileOutputStream 在 a.txt 文件，中写入 “hello，world”.</p><p>如果文件不存在，会创建文件(注意：前提是目录已经存在.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 FileOutputStream 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//得到 FileOutputStream 对象 对象</span></span><br><span class="line"><span class="comment">//1. new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容</span></span><br><span class="line"><span class="comment">//2. new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面</span></span><br><span class="line">fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个字节</span></span><br><span class="line">fileOutputStream.write(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hsp,world!&quot;</span>;</span><br><span class="line"><span class="comment">//str.getBytes() 可以把 字符串-&gt; 字节数组</span></span><br><span class="line"><span class="comment">//fileOutputStream.write(str.getBytes());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流</span></span><br><span class="line">fileOutputStream.write(str.getBytes(), <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><p>完成图片&#x2F;音乐的拷贝.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建文件的输入流 , 将文件读入到程序</span></span><br><span class="line"><span class="comment">//2. 创建文件的输出流， 将读取到的文件数据，写入到指定的文件.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\Koala.jpg&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\Koala3.jpg&quot;</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath);</span><br><span class="line">fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个字节数组,提高读取效果</span></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//读取到后，就写入到文件 通过 fileOutputStream</span></span><br><span class="line"><span class="comment">//即，是一边读，一边写</span></span><br><span class="line">    fileOutputStream.write(buf, <span class="number">0</span>, readLen);<span class="comment">//一定要使用这个方法</span></span><br><span class="line">&#125;</span><br><span class="line">fileInputStream.close();</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><p>网页图片的上传与下载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    MultipartFile是SpringMVC提供简化上传操作的工具类</span></span><br><span class="line"><span class="comment">    在不使用框架之前，都是使用原生的HttpServletRequest来接收上传的数据</span></span><br><span class="line"><span class="comment">    文件是以二进制流传递到后端的，然后需要我们自己转换为File类。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//将网页的上传的图片保存到服务器</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> UUID.randomUUID().toString() + substring;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">        <span class="comment">//判断目录是否存在,若不存在则创建</span></span><br><span class="line">        <span class="keyword">if</span>(!dir.exists()) &#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + filePath));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.success(filePath);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将从网页保存的图片回显到网页</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String name, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + name));</span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">            response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><h2 id="FileReader-字符流-文件专属"><a href="#FileReader-字符流-文件专属" class="headerlink" title="FileReader(字符流,文件专属)"></a>FileReader(字符流,文件专属)</h2><p>使用 FileReader 从 story.txt 读取内容，并显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">第一种:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    单个字符读取文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\story.txt&quot;</span>;</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1. 创建 FileReader 对象</span></span><br><span class="line">fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line"><span class="comment">//循环读取 使用 read, 单个字符读取</span></span><br><span class="line"><span class="keyword">while</span> ((data = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>) data);</span><br><span class="line">&#125;</span><br><span class="line">fileReader.close();</span><br><span class="line"></span><br><span class="line">第二种:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    字符数组读取文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\story.txt&quot;</span>;</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//1. 创建 FileReader 对象</span></span><br><span class="line">fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line"><span class="comment">//循环读取 使用 read(buf), 返回的是实际读取到的字符数</span></span><br><span class="line"><span class="comment">//如果返回-1, 说明到文件结束</span></span><br><span class="line"><span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen)); </span><br><span class="line">&#125;</span><br><span class="line">fileReader.close();</span><br></pre></td></tr></table></figure><h2 id="FileWriter-字符流-文件专属"><a href="#FileWriter-字符流-文件专属" class="headerlink" title="FileWriter(字符流,文件专属)"></a>FileWriter(字符流,文件专属)</h2><p>使用 FileWriter 将 “风雨之后，定见彩虹” 写入到 note.txt 文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\note.txt&quot;</span>;</span><br><span class="line"><span class="comment">//创建 FileWriter 对象</span></span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);<span class="comment">//默认是覆盖写入</span></span><br><span class="line"><span class="comment">// 3) write(int):写入单个字符</span></span><br><span class="line">fileWriter.write(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"><span class="comment">// 4) write(char[]):写入指定数组</span></span><br><span class="line">fileWriter.write(chars);</span><br><span class="line"><span class="comment">// 5) write(char[],off,len):写入指定数组的指定部分</span></span><br><span class="line">fileWriter.write(<span class="string">&quot;韩顺平教育&quot;</span>.toCharArray(), <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 6) write（string）：写入整个字符串</span></span><br><span class="line">fileWriter.write(<span class="string">&quot;风雨之后，定见彩虹&quot;</span>);</span><br><span class="line"><span class="comment">// 7) write(string,off,len):写入字符串的指定部分</span></span><br><span class="line">fileWriter.write(<span class="string">&quot;上海天津&quot;</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//fileWriter.flush();</span></span><br><span class="line"><span class="comment">//关闭文件流，等价 flush() + 关闭</span></span><br><span class="line">fileWriter.close();</span><br></pre></td></tr></table></figure><h2 id="BufferedReader和BufferedWriter-字符流"><a href="#BufferedReader和BufferedWriter-字符流" class="headerlink" title="BufferedReader和BufferedWriter(字符流)"></a>BufferedReader和BufferedWriter(字符流)</h2><p>综合使用BufferedReader和BufferedWriter完成文本文件拷贝,注意文件编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. BufferedReader 和 BufferedWriter 是安装字符操作</span></span><br><span class="line"><span class="comment">//2. 不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏</span></span><br><span class="line"><span class="comment">//BufferedInputStream</span></span><br><span class="line"><span class="comment">//BufferedOutputStream</span></span><br><span class="line"><span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a2.java&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">String line;<span class="comment">//按行读取, 效率高</span></span><br><span class="line"><span class="comment">//创建 bufferedReader, new BufferedReader(FileReader filerReader)</span></span><br><span class="line">br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFilePath));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 BufferedWriter, new BufferedWriter(FileWriter filerWriter)</span></span><br><span class="line"><span class="comment">//1. new FileWriter(filePath, true) 表示以追加的方式写入</span></span><br><span class="line"><span class="comment">//2. new FileWriter(filePath) , 表示以覆盖的方式写入</span></span><br><span class="line">bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFilePath));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. bufferedReader.readLine() 是按行读取文件</span></span><br><span class="line"><span class="comment">//2. 当返回 null 时，表示文件读取完</span></span><br><span class="line"><span class="comment">//3. readLine 读取一行内容，但是没有换行</span></span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//每读取一行，就写入</span></span><br><span class="line">    bw.write(line);</span><br><span class="line">    <span class="comment">//插入一个换行</span></span><br><span class="line">    bw.newLine();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;拷贝完毕...&quot;</span>);</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">br.close();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure><h2 id="BufferedOutputStream和BufferedInputStream-字节流"><a href="#BufferedOutputStream和BufferedInputStream-字节流" class="headerlink" title="BufferedOutputStream和BufferedInputStream(字节流)"></a>BufferedOutputStream和BufferedInputStream(字节流)</h2><p>在创建流对象时会创建一个内部缓冲区数组.</p><p>使用BufferedOutputStream和BufferedInputStream，完成二进制文件拷贝.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.jpg&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a3.jpg&quot;</span>;</span><br><span class="line"><span class="comment">//创建 BufferedOutputStream 对象 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为 FileInputStream 是 InputStream 子类</span></span><br><span class="line">bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath));</span><br><span class="line">bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath));</span><br><span class="line"><span class="comment">//循环的读取文件，并写入到 destFilePath</span></span><br><span class="line"><span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//当返回 -1 时，就表示文件读取完毕</span></span><br><span class="line"><span class="keyword">while</span> ((readLen = bis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    bos.write(buff, <span class="number">0</span>, readLen);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;文件拷贝完毕~~~&quot;</span>);</span><br><span class="line"><span class="comment">//关闭流 , 关闭外层的处理流即可，底层会去关闭节点流</span></span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><h2 id="BufferedStream与FileStream"><a href="#BufferedStream与FileStream" class="headerlink" title="BufferedStream与FileStream"></a>BufferedStream与FileStream</h2><p>谁快谁慢是根据实际情况来决定的，而不是说带了缓冲区就一定快；</p><ul><li>每次写入的数据量小的情况下，带缓冲区的<code>BufferedOutputStream</code>效率更快；</li><li>每次写入的数据量比较大时，不带缓冲区的 <code>FileOutputStream</code> 效率更快；</li></ul><p>所以，大家在选择的时候就需要根据实际情况来决定使用哪种IO流了，而大部分情况下，<code>FileOutputStream</code> 就已经足够了，只需要将写入的数据量大一点即可；</p><h2 id="对象流-ObjectInputStream-和-ObjectOutputStream"><a href="#对象流-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="对象流-ObjectInputStream 和 ObjectOutputStream"></a>对象流-ObjectInputStream 和 ObjectOutputStream</h2><p>功能：提供了对基本类型或对象类型的序列化和反序列化的方法</p><p>    ObjectOutputStream 提供 序列化功能</p><p>    ObjectInputStream 提供 反序列化功能</p><p><img src="/img/2022-10-15-20-15-10-image.png"></p><p><img src="/img/2022-10-15-20-15-32-image.png"></p><p>演示 ObjectOutputStream 的使用, 完成数据的序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\data.dat&quot;</span>;</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line"><span class="comment">//序列化数据到 e:\data.dat</span></span><br><span class="line">oos.writeInt(<span class="number">100</span>);<span class="comment">// int -&gt; Integer (实现了 Serializable)</span></span><br><span class="line">oos.writeBoolean(<span class="literal">true</span>);<span class="comment">// boolean -&gt; Boolean (实现了 Serializable)</span></span><br><span class="line">oos.writeChar(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Character (实现了 Serializable)</span></span><br><span class="line">oos.writeDouble(<span class="number">9.5</span>);<span class="comment">// double -&gt; Double (实现了 Serializable)</span></span><br><span class="line">oos.writeUTF(<span class="string">&quot;韩顺平教育&quot;</span>);<span class="comment">//String</span></span><br><span class="line"><span class="comment">//保存一个 dog 对象</span></span><br><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>, <span class="string">&quot;日本&quot;</span>, <span class="string">&quot;白色&quot;</span>));</span><br><span class="line">oos.close();</span><br><span class="line">System.out.println(<span class="string">&quot;数据保存完毕(序列化形式)&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用ObjectInputStream读取data.dat并反序列化恢复数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建流对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\data.dat&quot;</span>));</span><br><span class="line"><span class="comment">// 2.读取， 注意顺序</span></span><br><span class="line">System.out.println(ois.readInt());</span><br><span class="line">System.out.println(ois.readBoolean());</span><br><span class="line">System.out.println(ois.readChar());</span><br><span class="line">System.out.println(ois.readDouble());</span><br><span class="line">System.out.println(ois.readUTF());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line"><span class="comment">// 3.关闭</span></span><br><span class="line">ois.close();</span><br><span class="line">System.out.println(<span class="string">&quot;以反序列化的方式读取(恢复)ok~&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/img/2022-10-15-20-20-37-image.png"></p><h2 id="转换流-InputStreamReader-和-OutputStreamWriter"><a href="#转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader 和 OutputStreamWriter"></a>转换流-InputStreamReader 和 OutputStreamWriter</h2><p><img src="/img/2022-10-15-20-27-50-image.png"></p><p>将字节流FileInputStream包装成(转换成)字符流InputStreamReader,对文件进行读取(按照utf-8&#x2F;gdk格式),进而再包装成BufferedReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line"><span class="comment">//1. 把 FileInputStream 转成 InputStreamReader</span></span><br><span class="line"><span class="comment">//2. 指定编码 gbk</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;);</span></span><br><span class="line"><span class="comment">//3. 把 InputStreamReader 传入 BufferedReader</span></span><br><span class="line"><span class="comment">//BufferedReader br = new BufferedReader(isr);</span></span><br><span class="line"><span class="comment">//将 2 和 3 合在一起</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line"><span class="comment">//4. 读取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">System.out.println(<span class="string">&quot;读取内容=&quot;</span> + s);</span><br><span class="line"><span class="comment">//5. 关闭外层流</span></span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><p>将字节流FileOutputStream包装成(转换成)字符流OutputStreamWriter,对文件进行读取(按照utf-8&#x2F;gdk格式),进而再包装成BufferedWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建流对象</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\a.txt&quot;</span>), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">// 2.写入</span></span><br><span class="line">osw.write(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line"><span class="comment">// 3.关闭</span></span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure><h2 id="Properti类"><a href="#Properti类" class="headerlink" title="Properti类"></a>Properti类</h2><p><img src="/img/2022-10-15-20-49-17-image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 Properties 类来读取 mysql.properties 文件</span></span><br><span class="line"><span class="comment">//1. 创建 Properties 对象</span></span><br><span class="line">P<span class="comment">//roperties properties = new Properties();</span></span><br><span class="line"><span class="comment">//2. 加载指定配置文件</span></span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line"><span class="comment">//3. 把 k-v 显示控制台</span></span><br><span class="line">properties.list(System.out);</span><br><span class="line"><span class="comment">//4. 根据 key 获取对应的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"><span class="comment">//5.使用 Properties 类来创建 配置文件, 修改配置文件内容</span></span><br><span class="line">properties.setProperty(<span class="string">&quot;charset&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);<span class="comment">//注意保存时，是中文的 unicode 码值</span></span><br><span class="line">properties.setProperty(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;888888&quot;</span>);</span><br><span class="line"><span class="comment">//将 k-v 存储文件中即可</span></span><br><span class="line">properties.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql2.properties&quot;</span>), <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议栈与WEB服务器</title>
      <link href="/posts/4268.html"/>
      <url>/posts/4268.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/2022-11-08-21-14-50-image.png"></p><h2 id="数据包结构定义"><a href="#数据包结构定义" class="headerlink" title="数据包结构定义"></a>数据包结构定义</h2><p><img src="/img/2022-11-08-21-15-07-image.png"></p><h4 id="包结构定义"><a href="#包结构定义" class="headerlink" title="包结构定义"></a>包结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XNET_CFG_PACKET_MAX_SIZE        1516        <span class="comment">// 收发数据包的最大大小</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 网络数据结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xnet_packet_t</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> size;                              <span class="comment">// 包中有效数据大小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> * data;                             <span class="comment">// 包的数据起始地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> payload[XNET_CFG_PACKET_MAX_SIZE];  <span class="comment">// 最大负载数据量</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xnet_packet_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_packet_t</span> * <span class="title function_">xnet_alloc_for_send</span><span class="params">(<span class="type">uint16_t</span> data_size)</span>;  <span class="comment">//定义包发送函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_packet_t</span> * <span class="title function_">xnet_alloc_for_read</span><span class="params">(<span class="type">uint16_t</span> data_size)</span>;  <span class="comment">//定义包读取函数</span></span><br></pre></td></tr></table></figure><h4 id="实现包发送和读取函数"><a href="#实现包发送和读取函数" class="headerlink" title="实现包发送和读取函数"></a>实现包发送和读取函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">xnet_packet_t</span> tx_packet, rx_packet;                      <span class="comment">// 接收与发送缓冲区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 分配一个网络数据包用于发送数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param data_size 数据空间大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 分配得到的包结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_packet_t</span> * <span class="title function_">xnet_alloc_for_send</span><span class="params">(<span class="type">uint16_t</span> data_size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从tx_packet的后端往前分配，因为前边要预留作为各种协议的头部数据存储空间</span></span><br><span class="line"></span><br><span class="line">    tx_packet.data = tx_packet.payload + XNET_CFG_PACKET_MAX_SIZE - data_size;</span><br><span class="line"></span><br><span class="line">    tx_packet.size = data_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;tx_packet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 分配一个网络数据包用于读取</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param data_size 数据空间大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 分配得到的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_packet_t</span> * <span class="title function_">xnet_alloc_for_read</span><span class="params">(<span class="type">uint16_t</span> data_size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最开始进行分配，用于最底层的网络数据帧读取</span></span><br><span class="line"></span><br><span class="line">    rx_packet.data = rx_packet.payload;</span><br><span class="line"></span><br><span class="line">    rx_packet.size = data_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;rx_packet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对包的一些操作函数"><a href="#对包的一些操作函数" class="headerlink" title="对包的一些操作函数"></a>对包的一些操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b)               ((a) &gt; (b) ? (b) : (a))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 为发包添加一个头部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待处理的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param header_size 增加的头部大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_header</span><span class="params">(<span class="type">xnet_packet_t</span> *packet, <span class="type">uint16_t</span> header_size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    packet-&gt;data -= header_size;</span><br><span class="line"></span><br><span class="line">    packet-&gt;size += header_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 为接收向上处理移去头部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待处理的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param header_size 移去的头部大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_header</span><span class="params">(<span class="type">xnet_packet_t</span> *packet, <span class="type">uint16_t</span> header_size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    packet-&gt;data += header_size;</span><br><span class="line"></span><br><span class="line">    packet-&gt;size -= header_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 将包的长度截断为size大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待处理的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param size 最终大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">truncate_packet</span><span class="params">(<span class="type">xnet_packet_t</span> *packet, <span class="type">uint16_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    packet-&gt;size = min(packet-&gt;size, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><h5 id="app-c"><a href="#app-c" class="headerlink" title="app.c"></a>app.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xnet_tiny.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    xnet_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xnet running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        xnet_poll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="xnet-tiny-h"><a href="#xnet-tiny-h" class="headerlink" title="xnet_tiny.h"></a>xnet_tiny.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XNET_TINY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNET_TINY_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNET_CFG_PACKET_MAX_SIZE        1516        <span class="comment">// 收发数据包的最大大小</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 网络数据结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xnet_packet_t</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> size;                              <span class="comment">// 包中有效数据大小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> * data;                             <span class="comment">// 包的数据起始地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> payload[XNET_CFG_PACKET_MAX_SIZE];  <span class="comment">// 最大负载数据量</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xnet_packet_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_packet_t</span> * <span class="title function_">xnet_alloc_for_send</span><span class="params">(<span class="type">uint16_t</span> data_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">xnet_packet_t</span> * <span class="title function_">xnet_alloc_for_read</span><span class="params">(<span class="type">uint16_t</span> data_size)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xnet_init</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xnet_poll</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// XNET_TINY_H</span></span></span><br></pre></td></tr></table></figure><h5 id="xnet-tiny-c"><a href="#xnet-tiny-c" class="headerlink" title="xnet_tiny.c"></a>xnet_tiny.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xnet_tiny.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b)               ((a) &gt; (b) ? (b) : (a))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xnet_packet_t</span> tx_packet, rx_packet;                      <span class="comment">// 接收与发送缓冲区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 分配一个网络数据包用于发送数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param data_size 数据空间大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 分配得到的包结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_packet_t</span> * <span class="title function_">xnet_alloc_for_send</span><span class="params">(<span class="type">uint16_t</span> data_size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从tx_packet的后端往前分配，因为前边要预留作为各种协议的头部数据存储空间</span></span><br><span class="line"></span><br><span class="line">    tx_packet.data = tx_packet.payload + XNET_CFG_PACKET_MAX_SIZE - data_size;</span><br><span class="line"></span><br><span class="line">    tx_packet.size = data_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;tx_packet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 分配一个网络数据包用于读取</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param data_size 数据空间大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 分配得到的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_packet_t</span> * <span class="title function_">xnet_alloc_for_read</span><span class="params">(<span class="type">uint16_t</span> data_size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最开始进行分配，用于最底层的网络数据帧读取</span></span><br><span class="line"></span><br><span class="line">    rx_packet.data = rx_packet.payload;</span><br><span class="line"></span><br><span class="line">    rx_packet.size = data_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;rx_packet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 为发包添加一个头部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待处理的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param header_size 增加的头部大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_header</span><span class="params">(<span class="type">xnet_packet_t</span> *packet, <span class="type">uint16_t</span> header_size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    packet-&gt;data -= header_size;</span><br><span class="line"></span><br><span class="line">    packet-&gt;size += header_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 为接收向上处理移去头部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待处理的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param header_size 移去的头部大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_header</span><span class="params">(<span class="type">xnet_packet_t</span> *packet, <span class="type">uint16_t</span> header_size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    packet-&gt;data += header_size;</span><br><span class="line"></span><br><span class="line">    packet-&gt;size -= header_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 将包的长度截断为size大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待处理的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param size 最终大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">truncate_packet</span><span class="params">(<span class="type">xnet_packet_t</span> *packet, <span class="type">uint16_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">    packet-&gt;size = min(packet-&gt;size, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 协议栈的初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xnet_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 轮询处理数据包，并在协议栈中处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xnet_poll</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h2><h3 id="以太网封装驱动"><a href="#以太网封装驱动" class="headerlink" title="以太网封装驱动"></a>以太网封装驱动</h3><h4 id="定义驱动的函数"><a href="#定义驱动的函数" class="headerlink" title="定义驱动的函数"></a>定义驱动的函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xnet_driver_open</span> <span class="params">(<span class="type">uint8_t</span> * mac_addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xnet_driver_send</span> <span class="params">(<span class="type">xnet_packet_t</span> * packet)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xnet_driver_read</span> <span class="params">(<span class="type">xnet_packet_t</span> ** packet)</span>;</span><br></pre></td></tr></table></figure><h4 id="实现驱动的函数"><a href="#实现驱动的函数" class="headerlink" title="实现驱动的函数"></a>实现驱动的函数</h4><p>port_pcap.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pcap_device.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xnet_tiny.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pcap_t</span> * pcap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pcap所用的网卡</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * ip_str = <span class="string">&quot;192.168.254.1&quot;</span>;      <span class="comment">// 根据实际电脑上存在的网卡地址进行修改</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> my_mac_addr[] = &#123;<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>, <span class="number">0x44</span>, <span class="number">0x55</span>, <span class="number">0x66</span>, <span class="number">0x77</span>, <span class="number">0x88</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 初始化网络驱动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 0成功，其它失败</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xnet_driver_open</span> <span class="params">(<span class="type">uint8_t</span> * mac_addr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(mac_addr, my_mac_addr, <span class="keyword">sizeof</span>(my_mac_addr));</span><br><span class="line"></span><br><span class="line">    pcap = pcap_device_open(ip_str, mac_addr, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pcap == (<span class="type">pcap_t</span> *)<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XNET_ERR_OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 发送数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param frame 数据起始地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param size 数据长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 0 - 成功，其它失败</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xnet_driver_send</span> <span class="params">(<span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pcap_device_send(pcap, packet-&gt;data, packet-&gt;size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 读取数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param frame 数据存储位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param size 数据长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 0 - 成功，其它失败</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xnet_driver_read</span> <span class="params">(<span class="type">xnet_packet_t</span> ** packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_packet_t</span> * r_packet = xnet_alloc_for_read(XNET_CFG_PACKET_MAX_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    size = pcap_device_read(pcap, r_packet-&gt;data, XNET_CFG_PACKET_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line"></span><br><span class="line">        r_packet-&gt;size = size;</span><br><span class="line"></span><br><span class="line">        *packet = r_packet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> XNET_ERR_OK;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XNET_ERR_IO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义枚举-xnet-err-t"><a href="#定义枚举-xnet-err-t" class="headerlink" title="定义枚举_xnet_err_t"></a>定义枚举_xnet_err_t</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">xnet_err_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    XNET_ERR_OK = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    XNET_ERR_IO = <span class="number">-1</span>,</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xnet_err_t</span>;</span><br></pre></td></tr></table></figure><h3 id="以太网输入输出处理"><a href="#以太网输入输出处理" class="headerlink" title="以太网输入输出处理"></a>以太网输入输出处理</h3><h4 id="以太网初始化"><a href="#以太网初始化" class="headerlink" title="以太网初始化"></a>以太网初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 以太网初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 初始化结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xnet_err_t</span> <span class="title function_">ethernet_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_err_t</span> err = xnet_driver_open(netif_mac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XNET_ERR_OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="以太网数据帧格式"><a href="#以太网数据帧格式" class="headerlink" title="以太网数据帧格式"></a>以太网数据帧格式</h4><p><img src="/img/2022-11-08-22-24-01-image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNET_IPV4_ADDR_SIZE             4           <span class="comment">// IP地址长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNET_MAC_ADDR_SIZE              6           <span class="comment">// MAC地址长度</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 以太网数据帧格式：RFC894</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xether_hdr_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> dest[XNET_MAC_ADDR_SIZE];           <span class="comment">// 目标mac地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> src[XNET_MAC_ADDR_SIZE];            <span class="comment">// 源mac地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> protocol;                          <span class="comment">// 协议/长度</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xether_hdr_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><h4 id="发送和接收以太网帧"><a href="#发送和接收以太网帧" class="headerlink" title="发送和接收以太网帧"></a>发送和接收以太网帧</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> netif_mac[XNET_MAC_ADDR_SIZE];                   <span class="comment">// mac地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swap_order16(v)   ((((v) &amp; 0xFF) <span class="string">&lt;&lt; 8) | (((v) &gt;</span>&gt; 8) &amp; 0xFF))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 发送一个以太网数据帧</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param protocol 上层数据协议，IP或ARP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param mac_addr 目标网卡的mac地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待发送的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 发送结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xnet_err_t</span> <span class="title function_">ethernet_out_to</span><span class="params">(<span class="type">xnet_protocol_t</span> protocol, <span class="type">const</span> <span class="type">uint8_t</span> *mac_addr, <span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xether_hdr_t</span>* ether_hdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加头部</span></span><br><span class="line"></span><br><span class="line">    add_header(packet, <span class="keyword">sizeof</span>(<span class="type">xether_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">    ether_hdr = (<span class="type">xether_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(ether_hdr-&gt;dest, mac_addr, XNET_MAC_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(ether_hdr-&gt;src, netif_mac, XNET_MAC_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    ether_hdr-&gt;protocol = swap_order16(protocol);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据发送</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xnet_driver_send(packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 以太网数据帧输入输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待处理的包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ethernet_in</span> <span class="params">(<span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 至少要比头部数据大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (packet-&gt;size &lt;= <span class="keyword">sizeof</span>(<span class="type">xether_hdr_t</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往上分解到各个协议处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xether_hdr_t</span>* hdr = (<span class="type">xether_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (swap_order16(hdr-&gt;protocol)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> XNET_PROTOCOL_ARP:   <span class="comment">//协议类型是ARP</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> XNET_PROTOCOL_IP: &#123;  <span class="comment">//协议类型是IP</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义枚举协议的类型"><a href="#定义枚举协议的类型" class="headerlink" title="定义枚举协议的类型"></a>定义枚举协议的类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">xnet_protocol_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    XNET_PROTOCOL_ARP = <span class="number">0x0806</span>,     <span class="comment">// ARP协议</span></span><br><span class="line"></span><br><span class="line">    XNET_PROTOCOL_IP = <span class="number">0x0800</span>,      <span class="comment">// IP协议</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xnet_protocol_t</span>;</span><br></pre></td></tr></table></figure><h4 id="轮询处理数据包"><a href="#轮询处理数据包" class="headerlink" title="轮询处理数据包"></a>轮询处理数据包</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 查询网络接口，看看是否有数据包，有则进行处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ethernet_poll</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_packet_t</span> * packet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xnet_driver_read(&amp;packet) == XNET_ERR_OK) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常情况下，在此打个断点，全速运行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后在对方端ping 192.168.254.2，会停在这里</span></span><br><span class="line"></span><br><span class="line">        ethernet_in(packet);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 协议栈的初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xnet_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ethernet_init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 轮询处理数据包，并在协议栈中处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xnet_poll</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ethernet_poll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="ARP的初始化"><a href="#ARP的初始化" class="headerlink" title="ARP的初始化"></a>ARP的初始化</h3><p>Q: 因为以太网包包头需要目的MAC地址, 已知目的IP地址如何获得目的MAC地址?</p><p>A: 发送一个广播包Broadcast, 询问目的MAC地址, 目的主机回复MAC地址.</p><p><img src="/img/2022-11-09-12-04-38-image.png"></p><p><img src="/img/2022-11-09-12-04-56-image.png"></p><h4 id="ARP表"><a href="#ARP表" class="headerlink" title="ARP表"></a>ARP表</h4><p><img src="/img/2022-11-09-12-09-54-image.png"></p><p><img src="/img/2022-11-09-12-12-06-image.png"></p><h4 id="ARP表结构定义"><a href="#ARP表结构定义" class="headerlink" title="ARP表结构定义"></a>ARP表结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XNET_IPV4_ADDR_SIZE             4           <span class="comment">// IP地址长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNET_MAC_ADDR_SIZE              6           <span class="comment">// MAC地址长度/**</span></span></span><br><span class="line"></span><br><span class="line"> * IP地址</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">xipaddr_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> <span class="built_in">array</span>[XNET_IPV4_ADDR_SIZE];     <span class="comment">// 以数组形式存储的ip</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> addr;                          <span class="comment">// 32位的ip地址</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xipaddr_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_ENTRY_FREE                0       <span class="comment">// ARP表项空闲</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ARP表项</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xarp_entry_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xipaddr_t</span> ipaddr;                       <span class="comment">// ip地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    macaddr[XNET_MAC_ADDR_SIZE];    <span class="comment">// mac地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    state;                          <span class="comment">// 状态位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> tmo;                           <span class="comment">// 当前超时</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    retry_cnt;                      <span class="comment">// 当前重试次数</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xarp_entry_t</span>;</span><br></pre></td></tr></table></figure><h4 id="初始化ARP表"><a href="#初始化ARP表" class="headerlink" title="初始化ARP表"></a>初始化ARP表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_ENTRY_FREE                0       <span class="comment">// ARP表项空闲</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_ENTRY_OK                1       <span class="comment">// ARP表项解析成功</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ARP初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xarp_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    arp_entry.state = XARP_ENTRY_FREE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 协议栈的初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xnet_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ethernet_init();</span><br><span class="line"></span><br><span class="line">    xarp_init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无回报ARP的生成"><a href="#无回报ARP的生成" class="headerlink" title="无回报ARP的生成"></a>无回报ARP的生成</h3><h4 id="无回报ARP包"><a href="#无回报ARP包" class="headerlink" title="无回报ARP包"></a>无回报ARP包</h4><p><img src="/img/2022-11-09-13-20-41-image.png"></p><h4 id="ARP数据包"><a href="#ARP数据包" class="headerlink" title="ARP数据包"></a>ARP数据包</h4><p><img src="https://ask.qcloudimg.com/http-save/yehe-8223537/4757e34e1dc635d23744d23cd656634f.png?imageView2/2/w/1620"></p><p><img src="/img/2022-11-09-13-22-24-image.png"></p><h4 id="ARP包结构定义"><a href="#ARP包结构定义" class="headerlink" title="ARP包结构定义"></a>ARP包结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_HW_ETHER               0x1         <span class="comment">// 以太网</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_REQUEST                0x1         <span class="comment">// ARP请求包</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_REPLY                  0x2         <span class="comment">// ARP响应包</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xarp_packet_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> hw_type, pro_type;                 <span class="comment">// 硬件类型和协议类型</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> hw_len, pro_len;                    <span class="comment">// 硬件地址长 + 协议地址长</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> opcode;                            <span class="comment">// 请求/响应</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> sender_mac[XNET_MAC_ADDR_SIZE];     <span class="comment">// 发送包硬件地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> sender_ip[XNET_IPV4_ADDR_SIZE];     <span class="comment">// 发送包协议地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> target_mac[XNET_MAC_ADDR_SIZE];     <span class="comment">// 接收方硬件地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> target_ip[XNET_IPV4_ADDR_SIZE];     <span class="comment">// 接收方协议地址</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xarp_packet_t</span>;</span><br></pre></td></tr></table></figure><h4 id="ARP请求函数"><a href="#ARP请求函数" class="headerlink" title="ARP请求函数"></a>ARP请求函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">xipaddr_t</span> netif_ipaddr = XNET_CFG_NETIF_IP;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> ether_broadcast[] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;  <span class="comment">//广播地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> netif_mac[XNET_MAC_ADDR_SIZE];                   <span class="comment">// mac地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xnet_packet_t</span> tx_packet, rx_packet;                      <span class="comment">// 接收与发送缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xarp_entry_t</span> arp_entry;                                  <span class="comment">// 节省内存，只使用一个ARP表项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">xnet_err_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    XNET_ERR_OK = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    XNET_ERR_IO = <span class="number">-1</span>,</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xnet_err_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">xarp_make_request</span><span class="params">(<span class="type">const</span> <span class="type">xipaddr_t</span> * ipaddr)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 产生一个ARP请求，请求网络指定ip地址的机器发回一个ARP响应</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param ipaddr 请求的IP地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 指向网络数据结构xnet_packet_t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param arp_packet 指向28字节ARP请求/应答包xarp_packet_t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 请求结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xarp_make_request</span><span class="params">(<span class="type">const</span> <span class="type">xipaddr_t</span> * ipaddr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xarp_packet_t</span>* arp_packet;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_packet_t</span> * packet = xnet_alloc_for_send(<span class="keyword">sizeof</span>(<span class="type">xarp_packet_t</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    arp_packet = (<span class="type">xarp_packet_t</span> *)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    arp_packet-&gt;hw_type = swap_order16(XARP_HW_ETHER);                                </span><br><span class="line"></span><br><span class="line">    arp_packet-&gt;pro_type = swap_order16(XNET_PROTOCOL_IP);                            </span><br><span class="line"></span><br><span class="line">    arp_packet-&gt;hw_len = XNET_MAC_ADDR_SIZE;                                          </span><br><span class="line"></span><br><span class="line">    arp_packet-&gt;pro_len = XNET_IPV4_ADDR_SIZE;                                        </span><br><span class="line"></span><br><span class="line">    arp_packet-&gt;opcode = swap_order16(XARP_REQUEST);                                  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(arp_packet-&gt;sender_mac, netif_mac, XNET_MAC_ADDR_SIZE);                    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(arp_packet-&gt;sender_ip, netif_ipaddr.<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE);          </span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(arp_packet-&gt;target_mac, <span class="number">0</span>, XNET_MAC_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(arp_packet-&gt;target_ip, ipaddr-&gt;<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ethernet_out_to(XNET_PROTOCOL_ARP, ether_broadcast, packet);  <span class="comment">//返回一个以太网帧</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="以太网初始化-1"><a href="#以太网初始化-1" class="headerlink" title="以太网初始化"></a>以太网初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">xipaddr_t</span> netif_ipaddr = XNET_CFG_NETIF_IP;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> ether_broadcast[] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;  <span class="comment">//广播地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> netif_mac[XNET_MAC_ADDR_SIZE];                   <span class="comment">// mac地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 以太网初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 初始化结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xnet_err_t</span> <span class="title function_">ethernet_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_err_t</span> err = xnet_driver_open(netif_mac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启抓包工具wireshark，能在窗口发现如下数据包抓取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1    0.000000    Dell_f9:e6:77    Broadcast    ARP    42    ARP Announcement for 192.168.254.2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xarp_make_request(&amp;netif_ipaddr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ARP输入处理"><a href="#ARP输入处理" class="headerlink" title="ARP输入处理"></a>ARP输入处理</h3><p>当收到一个ARP包时, 经如下步骤进行处理:</p><p><img src="/img/2022-11-09-21-28-55-image.png"></p><h4 id="ARP输入处理函数"><a href="#ARP输入处理函数" class="headerlink" title="ARP输入处理函数"></a>ARP输入处理函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xipaddr_is_equal_buf(addr, buf)      (memcmp((addr)-&gt;array, (buf), XNET_IPV4_ADDR_SIZE) == 0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ARP输入处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 输入的ARP包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xarp_in</span><span class="params">(<span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (packet-&gt;size &gt;= <span class="keyword">sizeof</span>(<span class="type">xarp_packet_t</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">xarp_packet_t</span> * arp_packet = (<span class="type">xarp_packet_t</span> *) packet-&gt;data;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint16_t</span> opcode = swap_order16(arp_packet-&gt;opcode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包的合法性检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((swap_order16(arp_packet-&gt;hw_type) != XARP_HW_ETHER) ||</span><br><span class="line"></span><br><span class="line">            (arp_packet-&gt;hw_len != XNET_MAC_ADDR_SIZE) ||</span><br><span class="line"></span><br><span class="line">            (swap_order16(arp_packet-&gt;pro_type) != XNET_PROTOCOL_IP) ||</span><br><span class="line"></span><br><span class="line">            (arp_packet-&gt;pro_len != XNET_IPV4_ADDR_SIZE)</span><br><span class="line"></span><br><span class="line">            || ((opcode != XARP_REQUEST) &amp;&amp; (opcode != XARP_REPLY))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只处理发给自己的请求或响应包</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!xipaddr_is_equal_buf(&amp;netif_ipaddr, arp_packet-&gt;target_ip)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据操作码进行不同的处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (swap_order16(arp_packet-&gt;opcode)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> XARP_REQUEST:  <span class="comment">// 请求，回送响应</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在对方机器Ping 自己，然后看wireshark，能看到ARP请求和响应</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接下来，很可能对方要与自己通信，所以更新一下</span></span><br><span class="line"></span><br><span class="line">                xarp_make_response(arp_packet);</span><br><span class="line"></span><br><span class="line">                update_arp_entry(arp_packet-&gt;sender_ip, arp_packet-&gt;sender_mac);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> XARP_REPLY:    <span class="comment">// 响应，更新自己的表</span></span><br><span class="line"></span><br><span class="line">                update_arp_entry(arp_packet-&gt;sender_ip, arp_packet-&gt;sender_mac);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在以太网层处理ARP"><a href="#在以太网层处理ARP" class="headerlink" title="在以太网层处理ARP"></a>在以太网层处理ARP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往上分解到各个协议处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xether_hdr_t</span>* hdr = (<span class="type">xether_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (swap_order16(hdr-&gt;protocol)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> XNET_PROTOCOL_ARP:</span><br><span class="line"></span><br><span class="line">            remove_header(packet, <span class="keyword">sizeof</span>(<span class="type">xether_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">            xarp_in(packet);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ARP响应函数"><a href="#ARP响应函数" class="headerlink" title="ARP响应函数"></a>ARP响应函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 生成一个ARP响应</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param arp_packet 指向接收到的ARP请求包xarp_packet_t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 指向网络数据结构xnet_packet_t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 生成结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="type">xnet_err_t</span> <span class="title function_">xarp_make_response</span><span class="params">(<span class="type">xarp_packet_t</span> * arp_packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xarp_packet_t</span>* response_packet;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_packet_t</span> * packet = xnet_alloc_for_send(<span class="keyword">sizeof</span>(<span class="type">xarp_packet_t</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    response_packet = (<span class="type">xarp_packet_t</span> *)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    response_packet-&gt;hw_type = swap_order16(XARP_HW_ETHER);</span><br><span class="line"></span><br><span class="line">    response_packet-&gt;pro_type = swap_order16(XNET_PROTOCOL_IP);</span><br><span class="line"></span><br><span class="line">    response_packet-&gt;hw_len = XNET_MAC_ADDR_SIZE;</span><br><span class="line"></span><br><span class="line">    response_packet-&gt;pro_len = XNET_IPV4_ADDR_SIZE;</span><br><span class="line"></span><br><span class="line">    response_packet-&gt;opcode= swap_order16(XARP_REPLY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(response_packet-&gt;target_mac, arp_packet-&gt;sender_mac, XNET_MAC_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(response_packet-&gt;target_ip, arp_packet-&gt;sender_ip, XNET_IPV4_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(response_packet-&gt;sender_mac, netif_mac, XNET_MAC_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(response_packet-&gt;sender_ip, netif_ipaddr.<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ethernet_out_to(XNET_PROTOCOL_ARP, ether_broadcast, packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新ARP表项"><a href="#更新ARP表项" class="headerlink" title="更新ARP表项"></a>更新ARP表项</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_ENTRY_FREE                0       <span class="comment">// ARP表项空闲</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_ENTRY_OK                1       <span class="comment">// ARP表项解析成功</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 更新ARP表项</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param src_ip 源IP地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param mac_addr 对应的mac地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_arp_entry</span><span class="params">(<span class="type">uint8_t</span> * src_ip, <span class="type">uint8_t</span> * mac_addr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(arp_entry.ipaddr.<span class="built_in">array</span>, src_ip, XNET_IPV4_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(arp_entry.macaddr, mac_addr, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    arp_entry.state = XARP_ENTRY_OK;</span><br></pre></td></tr></table></figure><h3 id="ARP表定时更新"><a href="#ARP表定时更新" class="headerlink" title="ARP表定时更新"></a>ARP表定时更新</h3><h4 id="获得当前时间"><a href="#获得当前时间" class="headerlink" title="获得当前时间"></a>获得当前时间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">xnet_time_t</span>;           <span class="comment">// 时间类型，返回当前系统跑了多少个100ms</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 获取自程序启动以来，过去了多长时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 程序的系统时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">xnet_time_t</span> <span class="title function_">xsys_get_time</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> pre = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">xnet_time_t</span>)(clock() / CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查是否超时"><a href="#检查是否超时" class="headerlink" title="检查是否超时"></a>检查是否超时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 检查是否超时</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param time 前一时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param sec 预期超时时间，值为0时，表示获取当前时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 0 - 未超时，1-超时</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">xnet_check_tmo</span><span class="params">(<span class="type">xnet_time_t</span> * time, <span class="type">uint32_t</span> sec)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_time_t</span> curr = xsys_get_time();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sec == <span class="number">0</span>) &#123;          <span class="comment">// 如果预期超时时间为0，取当前时间, 用于初始化</span></span><br><span class="line"></span><br><span class="line">        *time = curr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr - *time &gt;= sec) &#123;   <span class="comment">// 非0检查超时</span></span><br><span class="line"></span><br><span class="line">        *time = curr;       <span class="comment">// 当超时时，才更新时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ARP初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xarp_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    arp_entry.state = XARP_ENTRY_FREE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取初始时间</span></span><br><span class="line"></span><br><span class="line">    xnet_check_tmo(&amp;arp_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询是否超时-超时则重新请求"><a href="#查询是否超时-超时则重新请求" class="headerlink" title="查询是否超时, 超时则重新请求"></a>查询是否超时, 超时则重新请求</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">xnet_time_t</span> arp_timer;                                   <span class="comment">// ARP扫描定时</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_CFG_ENTRY_PENDING_TMO        (1)                 <span class="comment">// ARP表项挂起超时时间</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_CFG_MAX_RETRIES            4                   <span class="comment">// ARP表挂起时重试查询次数</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_ENTRY_FREE                0       <span class="comment">// ARP表项空闲</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_ENTRY_OK                1       <span class="comment">// ARP表项解析成功</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_ENTRY_RESOLVING        2       <span class="comment">// ARP表项正在解析</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_TIMER_PERIOD           1       <span class="comment">// ARP扫描周期，1s足够</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_CFG_ENTRY_OK_TMO            (5)                 <span class="comment">// ARP表项超时时间</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_CFG_ENTRY_PENDING_TMO        (1)                 <span class="comment">// ARP表项挂起超时时间</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XARP_CFG_MAX_RETRIES            4                   <span class="comment">// ARP表挂起时重试查询次数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ARP表项</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xarp_entry_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xipaddr_t</span> ipaddr;                       <span class="comment">// ip地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    macaddr[XNET_MAC_ADDR_SIZE];    <span class="comment">// mac地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    state;                          <span class="comment">// 状态位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> tmo;                           <span class="comment">// 当前超时</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    retry_cnt;                      <span class="comment">// 当前重试次数</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xarp_entry_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 查询ARP表项是否超时，超时则重新请求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xarp_poll</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xnet_check_tmo(&amp;arp_timer, XARP_TIMER_PERIOD)) &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (arp_entry.state) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> XARP_ENTRY_RESOLVING:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--arp_entry.tmo == <span class="number">0</span>) &#123;     <span class="comment">// 重试完毕，回收</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (arp_entry.retry_cnt-- == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        arp_entry.state = XARP_ENTRY_FREE;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 继续重试</span></span><br><span class="line"></span><br><span class="line">                        xarp_make_request(&amp;arp_entry.ipaddr);</span><br><span class="line"></span><br><span class="line">                        arp_entry.state = XARP_ENTRY_RESOLVING;</span><br><span class="line"></span><br><span class="line">                        arp_entry.tmo = XARP_CFG_ENTRY_PENDING_TMO;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> XARP_ENTRY_OK:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--arp_entry.tmo == <span class="number">0</span>) &#123;     <span class="comment">// 超时，重新请求</span></span><br><span class="line"></span><br><span class="line">                    xarp_make_request(&amp;arp_entry.ipaddr);</span><br><span class="line"></span><br><span class="line">                    arp_entry.state = XARP_ENTRY_RESOLVING;</span><br><span class="line"></span><br><span class="line">                    arp_entry.tmo = XARP_CFG_ENTRY_PENDING_TMO;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="IP层的输入处理"><a href="#IP层的输入处理" class="headerlink" title="IP层的输入处理"></a>IP层的输入处理</h3><h4 id="IP数据包结构"><a href="#IP数据包结构" class="headerlink" title="IP数据包结构"></a>IP数据包结构</h4><p><img src="https://img2020.cnblogs.com/blog/2138556/202009/2138556-20200924115602290-194749429.jpg" alt="IP包结构图"></p><p><img src="/img/2022-11-10-21-53-14-image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xip_hdr_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> hdr_len : <span class="number">4</span>;                <span class="comment">// 首部长, 4字节为单位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> version : <span class="number">4</span>;                <span class="comment">// 版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> tos;                        <span class="comment">// 服务类型</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> total_len;                    <span class="comment">// 总长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> id;                        <span class="comment">// 标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> flags_fragment;            <span class="comment">// 标志与分段</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> ttl;                        <span class="comment">// 存活时间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> protocol;                    <span class="comment">// 上层协议</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> hdr_checksum;              <span class="comment">// 首部校验和</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    src_ip[XNET_IPV4_ADDR_SIZE];        <span class="comment">// 源IP</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> dest_ip[XNET_IPV4_ADDR_SIZE];        <span class="comment">// 目标IP</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xip_hdr_t</span>;</span><br></pre></td></tr></table></figure><h4 id="检验和计算"><a href="#检验和计算" class="headerlink" title="检验和计算"></a>检验和计算</h4><p>IP首部的检验和采用下面的简单计算方法：在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有16位字再使用反码算术运算相加一次。将得到的和取反码， 即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0,于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 校验和计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param buf 校验数据区的起始地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param len 数据区的长度，以字节为单位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param pre_sum 累加的之前的值，用于多次调用checksum对不同的的数据区计算出一个校验和</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param complement 是否对累加和的结果进行取反</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 校验和结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">checksum16</span><span class="params">(<span class="type">uint16_t</span> * buf, <span class="type">uint16_t</span> len, <span class="type">uint16_t</span> pre_sum, <span class="type">int</span> complement)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> checksum = pre_sum;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> high;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        checksum += *buf++;</span><br><span class="line"></span><br><span class="line">        len -= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        checksum += *(<span class="type">uint8_t</span> *)buf;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，这里要不断累加。不然结果在某些情况下计算不正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((high = checksum &gt;&gt; <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        checksum = high + (checksum &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> complement ? (<span class="type">uint16_t</span>)~checksum : (<span class="type">uint16_t</span>)checksum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IP层的输入处理-1"><a href="#IP层的输入处理-1" class="headerlink" title="IP层的输入处理"></a>IP层的输入处理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xipaddr_is_equal_buf(addr, buf)      (memcmp((addr)-&gt;array, (buf), XNET_IPV4_ADDR_SIZE) == 0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xip_hdr_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> hdr_len : <span class="number">4</span>;                <span class="comment">// 首部长, 4字节为单位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> version : <span class="number">4</span>;                <span class="comment">// 版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> tos;                        <span class="comment">// 服务类型</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> total_len;                    <span class="comment">// 总长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> id;                        <span class="comment">// 标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> flags_fragment;            <span class="comment">// 标志与分段</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> ttl;                        <span class="comment">// 存活时间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> protocol;                    <span class="comment">// 上层协议</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> hdr_checksum;              <span class="comment">// 首部校验和</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    src_ip[XNET_IPV4_ADDR_SIZE];        <span class="comment">// 源IP</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> dest_ip[XNET_IPV4_ADDR_SIZE];        <span class="comment">// 目标IP</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xip_hdr_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * IP层的输入处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 输入的IP数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xip_in</span><span class="params">(<span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xip_hdr_t</span>* iphdr = (<span class="type">xip_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> total_size, header_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> pre_checksum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行一些必要性的检查：版本号要求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iphdr-&gt;version != XNET_VERSION_IPV4) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度要求检查</span></span><br><span class="line"></span><br><span class="line">    header_size = iphdr-&gt;hdr_len * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    total_size = swap_order16(iphdr-&gt;total_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((header_size &lt; <span class="keyword">sizeof</span>(<span class="type">xip_hdr_t</span>)) || ((total_size &lt; header_size) || (packet-&gt;size &lt; total_size))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验和要求检查</span></span><br><span class="line"></span><br><span class="line">    pre_checksum = iphdr-&gt;hdr_checksum;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;hdr_checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre_checksum != checksum16((<span class="type">uint16_t</span>*)iphdr, header_size, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只处理目标IP为自己的数据包，其它广播之类的IP全部丢掉</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!xipaddr_is_equal_buf(&amp;netif_ipaddr, iphdr-&gt;dest_ip)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多跟复用，分别交由ICMP、UDP、TCP处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(iphdr-&gt;protocol) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在以太网层处理IP"><a href="#在以太网层处理IP" class="headerlink" title="在以太网层处理IP"></a>在以太网层处理IP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往上分解到各个协议处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xether_hdr_t</span>* hdr = (<span class="type">xether_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (swap_order16(hdr-&gt;protocol)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> XNET_PROTOCOL_IP: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以下代码是从IP包头中提取IP地址，以及从以太网包头中提取mac地址</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后用其更新ARP表</span></span><br><span class="line"></span><br><span class="line">            <span class="type">xip_hdr_t</span> *iphdr = (<span class="type">xip_hdr_t</span> *) (packet-&gt;data + <span class="keyword">sizeof</span>(<span class="type">xether_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">            update_arp_entry(iphdr-&gt;src_ip, hdr-&gt;src);</span><br><span class="line"></span><br><span class="line">            remove_header(packet, <span class="keyword">sizeof</span>(<span class="type">xether_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">            xip_in(packet);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="IP层的输出处理"><a href="#IP层的输出处理" class="headerlink" title="IP层的输出处理"></a>IP层的输出处理</h3><h4 id="IP包的输出"><a href="#IP包的输出" class="headerlink" title="IP包的输出"></a>IP包的输出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xip_hdr_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> hdr_len : <span class="number">4</span>;                <span class="comment">// 首部长, 4字节为单位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> version : <span class="number">4</span>;                <span class="comment">// 版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> tos;                        <span class="comment">// 服务类型</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> total_len;                    <span class="comment">// 总长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> id;                        <span class="comment">// 标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> flags_fragment;            <span class="comment">// 标志与分段</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> ttl;                        <span class="comment">// 存活时间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> protocol;                    <span class="comment">// 上层协议</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> hdr_checksum;              <span class="comment">// 首部校验和</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>    src_ip[XNET_IPV4_ADDR_SIZE];        <span class="comment">// 源IP</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> dest_ip[XNET_IPV4_ADDR_SIZE];        <span class="comment">// 目标IP</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xip_hdr_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * IP包的输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param protocol 上层协议，ICMP、UDP或TCP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param dest_ip 目的IP地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 网络数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xip_out</span><span class="params">(<span class="type">xnet_protocol_t</span> protocol, <span class="type">xipaddr_t</span>* dest_ip, <span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> ip_packet_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">xip_hdr_t</span> * iphdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add_header(packet, <span class="keyword">sizeof</span>(<span class="type">xip_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">    iphdr = (<span class="type">xip_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;version = XNET_VERSION_IPV4;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;hdr_len = <span class="keyword">sizeof</span>(<span class="type">xip_hdr_t</span>) / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;tos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;total_len = swap_order16(packet-&gt;size);</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;id = swap_order16(ip_packet_id);</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;flags_fragment = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;ttl = XNET_IP_DEFAULT_TTL;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;protocol = protocol;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(iphdr-&gt;dest_ip, dest_ip-&gt;<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(iphdr-&gt;src_ip, netif_ipaddr.<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;hdr_checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;hdr_checksum = checksum16((<span class="type">uint16_t</span> *)iphdr, <span class="keyword">sizeof</span>(<span class="type">xip_hdr_t</span>), <span class="number">0</span>, <span class="number">1</span>);;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ip_packet_id++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ethernet_out(dest_ip, packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将IP数据包通过以太网发送出去"><a href="#将IP数据包通过以太网发送出去" class="headerlink" title="将IP数据包通过以太网发送出去"></a>将IP数据包通过以太网发送出去</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 将IP数据包通过以太网发送出去</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param dest_ip 目标IP地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待发送IP数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 发送结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xnet_err_t</span> <span class="title function_">ethernet_out</span> <span class="params">(<span class="type">xipaddr_t</span> * dest_ip, <span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_err_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> * mac_addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = xarp_resolve(dest_ip, &amp;mac_addr) == XNET_ERR_OK)) &#123; <span class="comment">//检查ip地址是否在ARP表中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ethernet_out_to(XNET_PROTOCOL_IP, mac_addr, packet);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p><img src="/img/2022-11-10-23-28-11-image.png"></p><h3 id="ICMP包数据格式"><a href="#ICMP包数据格式" class="headerlink" title="ICMP包数据格式"></a>ICMP包数据格式</h3><p><img src="/img/2022-11-10-23-28-41-image.png"></p><p><img src="/img/2022-11-10-23-40-26-image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ICMP数据包结构定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xicmp_hdr_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> type;           <span class="comment">// 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> code;            <span class="comment">// 代码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> checksum;        <span class="comment">// ICMP报文的校验和</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> id;            <span class="comment">// 标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> seq;           <span class="comment">// 序号</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xicmp_hdr_t</span>;</span><br></pre></td></tr></table></figure><h3 id="ICMP包输入处理"><a href="#ICMP包输入处理" class="headerlink" title="ICMP包输入处理"></a>ICMP包输入处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XICMP_CODE_ECHO_REQUEST             8           <span class="comment">// 回显请求</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XICMP_CODE_ECHO_REPLY               0           <span class="comment">// 回显响应</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ICMP包输入处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param src_ip 数据包来源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待处理的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xicmp_in</span><span class="params">(<span class="type">xipaddr_t</span> *src_ip, <span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xicmp_hdr_t</span>* icmphdr = (<span class="type">xicmp_hdr_t</span> *)packet-&gt;data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((packet-&gt;size &gt;= <span class="keyword">sizeof</span>(<span class="type">xicmp_hdr_t</span>)) &amp;&amp; (icmphdr-&gt;type == XICMP_CODE_ECHO_REQUEST)) &#123;</span><br><span class="line"></span><br><span class="line">        reply_icmp_request(icmphdr, src_ip, packet);  <span class="comment">//发送ICMP ECHO响应</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ICMP-ECHO响应"><a href="#ICMP-ECHO响应" class="headerlink" title="ICMP ECHO响应"></a>ICMP ECHO响应</h3><p>即回应ping</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XICMP_CODE_ECHO_REQUEST             8           <span class="comment">// 回显请求</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XICMP_CODE_ECHO_REPLY               0           <span class="comment">// 回显响应</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 发送ICMP ECHO响应，即回应ping</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param icmp_hdr 收到的icmp包头</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param src_ip 包的来源ip</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 收到的数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 处理结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xnet_err_t</span> <span class="title function_">reply_icmp_request</span><span class="params">(<span class="type">xicmp_hdr_t</span> * icmp_hdr, <span class="type">xipaddr_t</span>* src_ip, <span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xicmp_hdr_t</span> * replay_hdr;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_packet_t</span> * tx = xnet_alloc_for_send(packet-&gt;size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    replay_hdr = (<span class="type">xicmp_hdr_t</span> *)tx-&gt;data;</span><br><span class="line"></span><br><span class="line">    replay_hdr-&gt;type = XICMP_CODE_ECHO_REPLY;</span><br><span class="line"></span><br><span class="line">    replay_hdr-&gt;code = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    replay_hdr-&gt;id = icmp_hdr-&gt;id;</span><br><span class="line"></span><br><span class="line">    replay_hdr-&gt;seq = icmp_hdr-&gt;seq;</span><br><span class="line"></span><br><span class="line">    replay_hdr-&gt;checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(((<span class="type">uint8_t</span> *)replay_hdr) + <span class="keyword">sizeof</span>(<span class="type">xicmp_hdr_t</span>), ((<span class="type">uint8_t</span> *)icmp_hdr) + <span class="keyword">sizeof</span>(<span class="type">xicmp_hdr_t</span>),</span><br><span class="line"></span><br><span class="line">            packet-&gt;size - <span class="keyword">sizeof</span>(<span class="type">xicmp_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">    replay_hdr-&gt;checksum = checksum16((<span class="type">uint16_t</span>*)replay_hdr, tx-&gt;size, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xip_out(XNET_PROTOCOL_ICMP, src_ip, tx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">xnet_protocol_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    XNET_PROTOCOL_ARP = <span class="number">0x0806</span>,     <span class="comment">// ARP协议</span></span><br><span class="line"></span><br><span class="line">    XNET_PROTOCOL_IP = <span class="number">0x0800</span>,      <span class="comment">// IP协议</span></span><br><span class="line"></span><br><span class="line">    XNET_PROTOCOL_ICMP = <span class="number">1</span>,         <span class="comment">// ICMP协议</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xnet_protocol_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * IP包的输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param protocol 上层协议，ICMP、UDP或TCP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param dest_ip</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xip_out</span><span class="params">(<span class="type">xnet_protocol_t</span> protocol, <span class="type">xipaddr_t</span>* dest_ip, <span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> ip_packet_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">xip_hdr_t</span> * iphdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add_header(packet, <span class="keyword">sizeof</span>(<span class="type">xip_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">    iphdr = (<span class="type">xip_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;version = XNET_VERSION_IPV4;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;hdr_len = <span class="keyword">sizeof</span>(<span class="type">xip_hdr_t</span>) / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;tos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;total_len = swap_order16(packet-&gt;size);</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;id = swap_order16(ip_packet_id);</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;flags_fragment = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;ttl = XNET_IP_DEFAULT_TTL;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;protocol = protocol;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(iphdr-&gt;dest_ip, dest_ip-&gt;<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(iphdr-&gt;src_ip, netif_ipaddr.<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE);</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;hdr_checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr-&gt;hdr_checksum = checksum16((<span class="type">uint16_t</span> *)iphdr, <span class="keyword">sizeof</span>(<span class="type">xip_hdr_t</span>), <span class="number">0</span>, <span class="number">1</span>);;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ip_packet_id++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ethernet_out(dest_ip, packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IP层处理ICMP包"><a href="#IP层处理ICMP包" class="headerlink" title="IP层处理ICMP包"></a>IP层处理ICMP包</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(iphdr-&gt;protocol) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> XNET_PROTOCOL_ICMP:</span><br><span class="line"></span><br><span class="line">            remove_header(packet, header_size);</span><br><span class="line"></span><br><span class="line">            xicmp_in(&amp;src_ip, packet);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实现目标不可达的响应"><a href="#实现目标不可达的响应" class="headerlink" title="实现目标不可达的响应"></a>实现目标不可达的响应</h3><p>ICMP的一个规则是，ICMP差错报文必须包括生成该差错报文的数据报IP首部（包含任何选项），还必须至少包括跟在该IP首部后面的前8个字节（包含源端口和目的端口）。在我们的例子中，跟在IP首部后面的前8个字节包含UDP的首部。</p><img title="" src="file:///C:/Users/篮网总冠军/AppData/Roaming/marktext/images/2022-11-11-20-42-56-image.png" alt="" data-align="inline"><h4 id="发送ICMP端口不可达或协议不可达的响应"><a href="#发送ICMP端口不可达或协议不可达的响应" class="headerlink" title="发送ICMP端口不可达或协议不可达的响应"></a>发送ICMP端口不可达或协议不可达的响应</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XICMP_TYPE_UNREACH                  3           <span class="comment">// 目的不可达</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XICMP_CODE_PORT_UNREACH             3           <span class="comment">// 端口不可达</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XICMP_CODE_PRO_UNREACH              2           <span class="comment">// 协议不可达</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 发送ICMP端口不可达或协议不可达的响应</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param code 不可达的类型码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param ip_hdr 收到的ip包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 处理结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xicmp_dest_unreach</span><span class="params">(<span class="type">uint8_t</span> code, <span class="type">xip_hdr_t</span> *ip_hdr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xicmp_hdr_t</span> * icmp_hdr;</span><br><span class="line"></span><br><span class="line">    <span class="type">xipaddr_t</span> dest_ip;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_packet_t</span>* packet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要拷贝的ip数据量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> ip_hdr_size = ip_hdr-&gt;hdr_len * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> ip_data_size = swap_order16(ip_hdr-&gt;total_len) - ip_hdr_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RFC文档里写的是8字节。但实际测试windows上发现复制了不止8个字节</span></span><br><span class="line"></span><br><span class="line">    ip_data_size = ip_hdr_size + min(ip_data_size, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成数据包，然后发送</span></span><br><span class="line"></span><br><span class="line">    packet = xnet_alloc_for_send(ip_data_size + <span class="keyword">sizeof</span>(<span class="type">xicmp_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">    icmp_hdr = (<span class="type">xicmp_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    icmp_hdr-&gt;type = XICMP_TYPE_UNREACH;</span><br><span class="line"></span><br><span class="line">    icmp_hdr-&gt;code = code;</span><br><span class="line"></span><br><span class="line">    icmp_hdr-&gt;checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    icmp_hdr-&gt;id = icmp_hdr-&gt;seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(((<span class="type">uint8_t</span> *)icmp_hdr) + <span class="keyword">sizeof</span>(<span class="type">xicmp_hdr_t</span>), ip_hdr, ip_data_size);</span><br><span class="line"></span><br><span class="line">    icmp_hdr-&gt;checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    icmp_hdr-&gt;checksum = checksum16((<span class="type">uint16_t</span> *)icmp_hdr, packet-&gt;size, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    xipaddr_from_buf(&amp;dest_ip, ip_hdr-&gt;src_ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xip_out(XNET_PROTOCOL_ICMP, &amp;dest_ip, packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p><img src="/img/2022-11-11-22-26-05-image.png"></p><p><img src="/img/2022-11-11-22-26-32-image.png"></p><p><img src="/img/2022-11-11-22-27-00-image.png"></p><h3 id="UDP控制块"><a href="#UDP控制块" class="headerlink" title="UDP控制块"></a>UDP控制块</h3><p>控制块负责控制进程与端口之间的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XUDP_CFG_MAX_UDP                10                  <span class="comment">// 最大支持的UDP连接数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xudp_t</span> <span class="title">xudp_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xudp_t</span> udp_socket[XUDP_CFG_MAX_UDP];                     <span class="comment">// UDP连接块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">xnet_err_t</span> <span class="params">(*<span class="type">xudp_handler_t</span>)</span><span class="params">(<span class="type">xudp_t</span> * udp, <span class="type">xipaddr_t</span> * src_ip, <span class="type">uint16_t</span> src_port, <span class="type">xnet_packet_t</span> * packet)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">xudp_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        XUDP_STATE_FREE,            <span class="comment">// UDP未使用</span></span><br><span class="line"></span><br><span class="line">        XUDP_STATE_USED,            <span class="comment">// UDP已使用</span></span><br><span class="line"></span><br><span class="line">    &#125; state;                        <span class="comment">// 状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> local_port;            <span class="comment">// 本地端口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xudp_handler_t</span> handler;         <span class="comment">// 事件处理回调</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="UDP初始化"><a href="#UDP初始化" class="headerlink" title="UDP初始化"></a>UDP初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * UDP初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xudp_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(udp_socket, <span class="number">0</span>, <span class="keyword">sizeof</span>(udp_socket));      <span class="comment">// Free也是0，所以没什么问题</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制块基本操作接口"><a href="#控制块基本操作接口" class="headerlink" title="控制块基本操作接口"></a>控制块基本操作接口</h3><p> <img src="/img/2022-11-11-22-41-11-image.png"></p><h4 id="打开UDP结构"><a href="#打开UDP结构" class="headerlink" title="打开UDP结构"></a>打开UDP结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 打开UDP结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param handler 事件处理回调函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 打开的xudp_t结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xudp_t</span>* <span class="title function_">xudp_open</span><span class="params">(<span class="type">xudp_handler_t</span> handler)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xudp_t</span> * udp, * end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (udp = udp_socket, end = &amp;udp_socket[XUDP_CFG_MAX_UDP]; udp &lt; end; udp++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (udp-&gt;state == XUDP_STATE_FREE) &#123;</span><br><span class="line"></span><br><span class="line">            udp-&gt;state = XUDP_STATE_USED;</span><br><span class="line"></span><br><span class="line">            udp-&gt;local_port = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            udp-&gt;handler = handler;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> udp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">xudp_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭UDP连接"><a href="#关闭UDP连接" class="headerlink" title="关闭UDP连接"></a>关闭UDP连接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 关闭UDP连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param udp 待关闭的xudp_t结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xudp_close</span><span class="params">(<span class="type">xudp_t</span> *udp)</span> &#123;</span><br><span class="line"></span><br><span class="line">    udp-&gt;state = XUDP_STATE_FREE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找指定端口的UDP协议"><a href="#查找指定端口的UDP协议" class="headerlink" title="查找指定端口的UDP协议"></a>查找指定端口的UDP协议</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 查找指定端口对应的udp结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param port 待查找的端口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 找到的xudp_t结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xudp_t</span>* <span class="title function_">xudp_find</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xudp_t</span> * udp, * end = &amp;udp_socket[XUDP_CFG_MAX_UDP];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (udp = udp_socket; udp &lt; end; udp++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((udp-&gt;state != XUDP_STATE_FREE) &amp;&amp; (udp-&gt;local_port == port)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> udp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">xudp_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绑定控制块到端口"><a href="#绑定控制块到端口" class="headerlink" title="绑定控制块到端口"></a>绑定控制块到端口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 绑定xudp_t结构到指定端口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param udp 待绑定的结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param local_port 目标端口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 绑定结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xudp_bind</span><span class="params">(<span class="type">xudp_t</span> *udp, <span class="type">uint16_t</span> local_port)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xudp_t</span> * curr, * end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (local_port == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> XNET_ERR_PARAM;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (curr = udp_socket, end = &amp;udp_socket[XUDP_CFG_MAX_UDP]; curr &lt; end; curr++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((curr != udp) &amp;&amp; (curr-&gt;local_port == local_port)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> XNET_ERR_BINDED;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    udp-&gt;local_port = local_port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XNET_ERR_OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="协议栈初始化"><a href="#协议栈初始化" class="headerlink" title="协议栈初始化"></a>协议栈初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 协议栈的初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xnet_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ethernet_init();</span><br><span class="line"></span><br><span class="line">    xarp_init();</span><br><span class="line"></span><br><span class="line">    xip_init();</span><br><span class="line"></span><br><span class="line">    xicmp_init();</span><br><span class="line"></span><br><span class="line">    xudp_init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP数据包格式"><a href="#UDP数据包格式" class="headerlink" title="UDP数据包格式"></a>UDP数据包格式</h3><p><img src="/img/2022-11-12-09-40-49-image.png"></p><p><img src="https://img2018.cnblogs.com/i-beta/1806965/201911/1806965-20191129104138227-1985664312.png"></p><p><img src="https://img-blog.csdnimg.cn/2020063010003161.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xudp_hdr_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> src_port, dest_port;   <span class="comment">// 源端口 + 目标端口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> total_len;                <span class="comment">// 整个数据包的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> checksum;                <span class="comment">// 校验和</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xudp_hdr_t</span>;</span><br></pre></td></tr></table></figure><h3 id="UDP伪首部"><a href="#UDP伪首部" class="headerlink" title="UDP伪首部"></a>UDP伪首部</h3><p><img src="https://img-blog.csdnimg.cn/20200630105441329.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="计算UDP伪检验和"><a href="#计算UDP伪检验和" class="headerlink" title="计算UDP伪检验和"></a>计算UDP伪检验和</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 计算UDP伪校验和</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param src_ip 源IP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param dest_ip 目标IP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param protocol 协议</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param buf 数据区</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 校验和结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">checksum_peso</span><span class="params">(<span class="type">const</span> <span class="type">xipaddr_t</span> *src_ip, <span class="type">const</span> <span class="type">xipaddr_t</span> *dest_ip,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                              <span class="type">uint8_t</span> protocol, <span class="type">uint16_t</span> *buf, <span class="type">uint16_t</span> len)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> zero_protocol[<span class="number">2</span>] = &#123;<span class="number">0</span>, protocol&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> c_len = swap_order16(len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> sum = checksum16((<span class="type">uint16_t</span> *)src_ip-&gt;<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sum = checksum16((<span class="type">uint16_t</span> *)dest_ip-&gt;<span class="built_in">array</span>, XNET_IPV4_ADDR_SIZE, sum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sum = checksum16((<span class="type">uint16_t</span> *)zero_protocol, <span class="number">2</span>, sum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sum = checksum16((<span class="type">uint16_t</span> *)&amp;c_len, <span class="number">2</span>, sum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum16(buf, len, sum, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP输入处理"><a href="#UDP输入处理" class="headerlink" title="UDP输入处理"></a>UDP输入处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * UDP输入处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param udp 待处理的UDP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param src_ip 数据包来源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 数据包结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xudp_in</span><span class="params">(<span class="type">xudp_t</span> *udp, <span class="type">xipaddr_t</span> *src_ip,<span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xudp_hdr_t</span> * udp_hdr = (<span class="type">xudp_hdr_t</span> *)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> pre_checksum;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> src_port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((packet-&gt;size &lt; <span class="keyword">sizeof</span>(<span class="type">xudp_hdr_t</span>)) || (packet-&gt;size &lt; swap_order16(udp_hdr-&gt;total_len))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pre_checksum = udp_hdr-&gt;checksum;</span><br><span class="line"></span><br><span class="line">    udp_hdr-&gt;checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre_checksum != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint16_t</span> checksum = checksum_peso(src_ip, &amp;netif_ipaddr, XNET_PROTOCOL_UDP,    <span class="comment">//typedef XNET_PROTOCOL_UDP 17  </span></span><br><span class="line"></span><br><span class="line">                                          (<span class="type">uint16_t</span> *) udp_hdr, swap_order16(udp_hdr-&gt;total_len));</span><br><span class="line"></span><br><span class="line">        checksum = (checksum == <span class="number">0</span>) ? <span class="number">0xFFFF</span> : checksum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checksum != pre_checksum) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    src_port = swap_order16(udp_hdr-&gt;src_port);</span><br><span class="line"></span><br><span class="line">    remove_header(packet, <span class="keyword">sizeof</span>(<span class="type">xudp_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (udp-&gt;handler) &#123;</span><br><span class="line"></span><br><span class="line">        udp-&gt;handler(udp, src_ip, src_port, packet);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在IP层处理UDP"><a href="#在IP层处理UDP" class="headerlink" title="在IP层处理UDP"></a>在IP层处理UDP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(iphdr-&gt;protocol) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> XNET_PROTOCOL_UDP:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (packet-&gt;size &gt;= <span class="keyword">sizeof</span>(<span class="type">xudp_hdr_t</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">xudp_hdr_t</span> *udp_hdr = (<span class="type">xudp_hdr_t</span> *) (packet-&gt;data + header_size);</span><br><span class="line"></span><br><span class="line">                <span class="type">xudp_t</span> *udp = xudp_find(swap_order16(udp_hdr-&gt;dest_port));  <span class="comment">//获得与控制相应端口的控制块</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (udp) &#123;</span><br><span class="line"></span><br><span class="line">                    truncate_packet(packet, total_size);</span><br><span class="line"></span><br><span class="line">                    remove_header(packet, header_size);</span><br><span class="line"></span><br><span class="line">                    xudp_in(udp, &amp;src_ip, packet);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    xicmp_dest_unreach(XICMP_CODE_PORT_UNREACH, iphdr);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送UDP数据包"><a href="#发送UDP数据包" class="headerlink" title="发送UDP数据包"></a>发送UDP数据包</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 发送一个UDP数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param udp udp结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param dest_ip 目标ip</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param dest_port 目标端口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param packet 待发送的包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 发送结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">xudp_out</span><span class="params">(<span class="type">xudp_t</span>* udp, <span class="type">xipaddr_t</span> * dest_ip, <span class="type">uint16_t</span> dest_port, <span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xudp_hdr_t</span>* udp_hdr;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> checksum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add_header(packet, <span class="keyword">sizeof</span>(<span class="type">xudp_hdr_t</span>));</span><br><span class="line"></span><br><span class="line">    udp_hdr = (<span class="type">xudp_hdr_t</span>*)packet-&gt;data;</span><br><span class="line"></span><br><span class="line">    udp_hdr-&gt;src_port = swap_order16(udp-&gt;local_port);</span><br><span class="line"></span><br><span class="line">    udp_hdr-&gt;dest_port = swap_order16(dest_port);</span><br><span class="line"></span><br><span class="line">    udp_hdr-&gt;total_len = swap_order16(packet-&gt;size);</span><br><span class="line"></span><br><span class="line">    udp_hdr-&gt;checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    checksum = checksum_peso(&amp;netif_ipaddr, dest_ip, XNET_PROTOCOL_UDP, (<span class="type">uint16_t</span> *) udp_hdr, packet-&gt;size);</span><br><span class="line"></span><br><span class="line">    udp_hdr-&gt;checksum = (checksum == <span class="number">0</span>) ? <span class="number">0xFFFF</span> : checksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xip_out(XNET_PROTOCOL_UDP, dest_ip, packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间返回功能"><a href="#时间返回功能" class="headerlink" title="时间返回功能"></a>时间返回功能</h3><p>客户端向服务器通过发送一个UDP数据包申请获得当前时间, 服务器返回一个UDP数据包, 其中包含当前时间.</p><h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xnet_tiny.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSERVER_DATETIME_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef xnet_err_t (*xudp_handler_t)(xudp_t * udp, xipaddr_t * src_ip, uint16_t src_port, xnet_packet_t * packet);</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xserver_datetime_create</span><span class="params">(<span class="type">uint16_t</span> port)</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_STR_SIZE       128         <span class="comment">// 时间字符串存储长度</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xnet_err_t</span> <span class="title function_">datetime_handler</span> <span class="params">(<span class="type">xudp_t</span> * udp, <span class="type">xipaddr_t</span> * src_ip, <span class="type">uint16_t</span> src_port, <span class="type">xnet_packet_t</span> * packet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_packet_t</span> * tx_packet;</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> rawtime;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">timeinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> str_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tx_packet = xnet_alloc_for_send(TIME_STR_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参见：http://www.cplusplus.com/reference/ctime/localtime/</span></span><br><span class="line"></span><br><span class="line">    time (&amp;rawtime);</span><br><span class="line"></span><br><span class="line">    timeinfo = localtime (&amp;rawtime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// strftime参见：http://www.cplusplus.com/reference/ctime/strftime/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Weekday, Month Day, Year Time-Zone</span></span><br><span class="line"></span><br><span class="line">    str_size = strftime((<span class="type">char</span> *)tx_packet-&gt;data, TIME_STR_SIZE, <span class="string">&quot;%A, %B %d, %Y %T-%z&quot;</span>, timeinfo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xudp_out(udp, src_ip, src_port, tx_packet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过在main函数内调用 xserver_datetime_create(13); 将13端口与返回时间应用绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//到时候客户端只需要发送UDP到13端口就可以通过控制块控制13端口的时间应用返回时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xserver_datetime_create</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xnet_err_t</span> err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">xudp_t</span>* udp = xudp_open(datetime_handler);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (udp == (<span class="type">xudp_t</span>*)<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    err = xudp_bind(udp, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        xudp_close(udp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP控制块"><a href="#TCP控制块" class="headerlink" title="TCP控制块"></a>TCP控制块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XTCP_CFG_MAX_TCP                        40                  <span class="comment">// 最大支持的TCP连接数</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">xtcp_state_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    XTCP_STATE_FREE,</span><br><span class="line"></span><br><span class="line">    XTCP_STATE_CLOSED,</span><br><span class="line"></span><br><span class="line">    XTCP_STATE_LISTEN,</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xtcp_state_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">xtcp_conn_state_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    XTCP_CONN_CONNECTED,</span><br><span class="line"></span><br><span class="line">    XTCP_CONN_DATA_RECV,</span><br><span class="line"></span><br><span class="line">    XTCP_CONN_CLOSED,</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">xtcp_conn_state_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">xtcp_t</span> <span class="title">xtcp_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">xnet_err_t</span><span class="params">(*<span class="type">xtcp_handler_t</span>)</span><span class="params">(<span class="type">xtcp_t</span>* tcp, <span class="type">xtcp_conn_state_t</span> event)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">xtcp_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xtcp_state_t</span> state;                 <span class="comment">// 状态</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> local_port, remote_port;   <span class="comment">// 本地端口 + 源端口</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xipaddr_t</span> remote_ip;                <span class="comment">// 源IP</span></span><br><span class="line"></span><br><span class="line">    <span class="type">xtcp_handler_t</span> handler;             <span class="comment">// 事件处理回调</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TCP控制块基本操作接口"><a href="#TCP控制块基本操作接口" class="headerlink" title="TCP控制块基本操作接口"></a>TCP控制块基本操作接口</h3><p><img src="/img/2022-11-12-20-46-09-image.png"></p><h4 id="分配一个TCP控制块"><a href="#分配一个TCP控制块" class="headerlink" title="分配一个TCP控制块"></a>分配一个TCP控制块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 分配一个tcp连接块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return 分配结果，0-分配失败</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xtcp_t</span> * <span class="title function_">tcp_alloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xtcp_t</span> * tcp, * end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tcp = tcp_socket, end = tcp_socket + XTCP_CFG_MAX_TCP; tcp &lt; end; tcp++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp-&gt;state == XTCP_STATE_FREE) &#123;</span><br><span class="line"></span><br><span class="line">            tcp-&gt;state = XTCP_STATE_CLOSED;</span><br><span class="line"></span><br><span class="line">            tcp-&gt;local_port = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            tcp-&gt;remote_port = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            tcp-&gt;remote_ip.addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            tcp-&gt;handler = (<span class="type">xtcp_handler_t</span>)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> tcp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">xtcp_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放一个连接块"><a href="#释放一个连接块" class="headerlink" title="释放一个连接块"></a>释放一个连接块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 释放一个连接块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param tcp 待释放的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_free</span><span class="params">(<span class="type">xtcp_t</span>* tcp)</span> &#123;</span><br><span class="line"></span><br><span class="line">    tcp-&gt;state = XTCP_STATE_FREE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="寻找TCP控制块"><a href="#寻找TCP控制块" class="headerlink" title="寻找TCP控制块"></a>寻找TCP控制块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 根据远端的端口、ip找一个对应的tcp连接进行处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 优先找端口、IP全匹配的，其次找处于监听状态的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param remote_ip</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param remote_port</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param local_port</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">xtcp_t</span>* <span class="title function_">tcp_find</span><span class="params">(<span class="type">xipaddr_t</span> *remote_ip, <span class="type">uint16_t</span> remote_port, <span class="type">uint16_t</span> local_port)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xtcp_t</span> * tcp, * end;</span><br><span class="line"></span><br><span class="line">    <span class="type">xtcp_t</span> * founded_tcp = (<span class="type">xtcp_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tcp = tcp_socket, end = tcp_socket + XTCP_CFG_MAX_TCP; tcp &lt; end; tcp++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((tcp-&gt;state == XTCP_STATE_FREE) || (tcp-&gt;local_port != local_port)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xipaddr_is_equal(remote_ip, &amp;tcp-&gt;remote_ip) &amp;&amp; (remote_port == tcp-&gt;remote_port)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> tcp;     <span class="comment">// 优先，远程的端口和ip完全相同，立即返回</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp-&gt;state == XTCP_STATE_LISTEN) &#123;</span><br><span class="line"></span><br><span class="line">            founded_tcp = tcp;  <span class="comment">// 没有，默认使用监听端口</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> founded_tcp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP初始化"><a href="#TCP初始化" class="headerlink" title="TCP初始化"></a>TCP初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * TCP初始化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xtcp_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(tcp_socket, <span class="number">0</span>, <span class="keyword">sizeof</span>(tcp_socket));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打开TCP"><a href="#打开TCP" class="headerlink" title="打开TCP"></a>打开TCP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 打开TCP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xtcp_t</span> * <span class="title function_">xtcp_open</span><span class="params">(<span class="type">xtcp_handler_t</span> handler)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xtcp_t</span> * tcp = tcp_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tcp) <span class="keyword">return</span> (<span class="type">xtcp_t</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tcp-&gt;state = XTCP_STATE_CLOSED;</span><br><span class="line"></span><br><span class="line">    tcp-&gt;handler = handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP控制块绑定端口"><a href="#TCP控制块绑定端口" class="headerlink" title="TCP控制块绑定端口"></a>TCP控制块绑定端口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 建立tcp与指定本地端口的关联，使得其能够处理来自该端口的包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 以及通过该端口发送数据包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xtcp_bind</span><span class="params">(<span class="type">xtcp_t</span>* tcp, <span class="type">uint16_t</span> local_port)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">xtcp_t</span> * curr, * end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (curr = tcp_socket, end = &amp;tcp_socket[XTCP_CFG_MAX_TCP]; curr &lt; end; curr++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((curr != tcp) &amp;&amp; (curr-&gt;local_port == local_port)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> XNET_ERR_BINDED;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tcp-&gt;local_port = local_port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XNET_ERR_OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP进入监听状态"><a href="#TCP进入监听状态" class="headerlink" title="TCP进入监听状态"></a>TCP进入监听状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 控制tcp进入监听状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xtcp_listen</span><span class="params">(<span class="type">xtcp_t</span> * tcp)</span> &#123;</span><br><span class="line"></span><br><span class="line">    tcp-&gt;state = XTCP_STATE_LISTEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XNET_ERR_OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 关掉tcp连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">xnet_err_t</span> <span class="title function_">xtcp_close</span><span class="params">(<span class="type">xtcp_t</span> *tcp)</span> &#123;</span><br><span class="line"></span><br><span class="line">    tcp_free(tcp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XNET_ERR_OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理</title>
      <link href="/posts/22080.html"/>
      <url>/posts/22080.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="/img/2022-11-01-16-46-00-506CA7A165ACB668832737A5AE119918.jpg"></p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><img src="/img/2022-11-01-16-47-48-9681B42BE4BFC78AD86742BA041326BC.jpg"></p><p><img src="/img/2022-11-01-16-48-11-D9A8C781C09148F45DD93E887BE3FC96.jpg"></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><img src="/img/2022-11-01-16-48-28-6A4ACB3DF0C683AAE260D5901620C559.jpg"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/2022-11-01-16-48-46-5EDBCF505F51EE81B7E202E3B8D0B426.jpg"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p><img src="/img/2022-11-01-16-50-27-CD7649DD5342BE0CF59DB53FEAC0D894.jpg"></p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p><img src="/img/2022-11-01-16-51-05-88B89A4B65170873CDCB8432E5157655.jpg"></p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="/img/2022-11-01-16-51-27-F9F82A7D98542091D6319F2596C7B26C.jpg"></p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p><img src="/img/2022-11-01-16-51-54-18928721CD6B2D2E66B59C83A162628B.jpg"></p><h4 id="往返时延-RTT"><a href="#往返时延-RTT" class="headerlink" title="往返时延(RTT)"></a>往返时延(RTT)</h4><p><img src="/img/2022-11-01-16-52-14-19A79321B3691039C8B3A1299272E9E9.jpg"></p><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p><img src="/img/2022-11-01-16-52-50-9EC79158BA03129E45268804CD8E23C4.jpg"></p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p><img src="/img/2022-11-01-16-53-06-97A69B81EA752F8D6718CE034960CC99.jpg"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/2022-11-01-16-50-00-0A4B2C90143BB6F2C712B2AF5088A66F.jpg"></p><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><h4 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h4><p>  (1）发起通信的计算机必须将数据通信的通路进行激活。<br>（2）要告诉网络如何识别目的主机。<br>（3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。<br>（4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。<br>（5）确保差错和意外可以解决。</p><h4 id="分层结构-1"><a href="#分层结构-1" class="headerlink" title="分层结构"></a>分层结构</h4><p><img src="/img/2022-11-01-16-54-19-235EDC6CCF591FBBC27221CA4E4ACDC6.jpg"></p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/2022-11-01-16-54-33-9BE5D9E08077BF8D6ECD96DCA3592EFE.jpg"></p><h2 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h2><h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><h5 id="OSI模型-1"><a href="#OSI模型-1" class="headerlink" title="OSI模型"></a>OSI模型</h5><p><img src="/img/2022-11-01-20-37-41-image.png"></p><p><img src="/img/2022-11-01-20-40-18-1F7B8111F6697A1D6AFA766D3C37A580.jpg"></p><h5 id="OSI流程简介"><a href="#OSI流程简介" class="headerlink" title="OSI流程简介"></a>OSI流程简介</h5><p>网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部）<br>数据链路层不仅需要加头部，还需要加尾部<br>物理层什么都不加，只管发送数据（比特流）</p><p><img src="https://img-blog.csdnimg.cn/20200626205152756.png?xshadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h4><p><img src="https://img-blog.csdnimg.cn/20200626205911885.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="五层参考模型及其传输过程简介"><a href="#五层参考模型及其传输过程简介" class="headerlink" title="五层参考模型及其传输过程简介"></a>五层参考模型及其传输过程简介</h4><p><img src="https://img-blog.csdnimg.cn/20200626210125977.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200626210211625.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。<br>这就叫做”实体层”，逼格高一点的叫法就是物理层。它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。<br>至于0和1的信号是什么，还轮不到物理层还决定。<br><img src="https://img-blog.csdnimg.cn/20200626212252286.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="数据通路基本知识"><a href="#数据通路基本知识" class="headerlink" title="数据通路基本知识"></a>数据通路基本知识</h3><h4 id="一个数据通信例子"><a href="#一个数据通信例子" class="headerlink" title="一个数据通信例子"></a>一个数据通信例子</h4><img src="https://img-blog.csdnimg.cn/20200626212614182.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" title="" alt="在这里插入图片描述" width="673"><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><img src="https://img-blog.csdnimg.cn/20200626212816152.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" title="" alt="在这里插入图片描述" width="660"><h4 id="三种通讯方式"><a href="#三种通讯方式" class="headerlink" title="三种通讯方式"></a>三种通讯方式</h4><p><img src="/img/2022-11-01-21-13-25-image.png"></p><h4 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h4><p><img src="/img/2022-11-01-21-14-16-image.png"></p><img title="" src="https://img-blog.csdnimg.cn/20200626213810764.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" data-align="inline"><h4 id="码元-Symbol"><a href="#码元-Symbol" class="headerlink" title="码元(Symbol)"></a>码元(Symbol)</h4><p>定义：码元是指用一个固定时长的信号波形（数字脉冲），代表离散数值的基本波形。当有多个离散状态时，成为M进制码元<br>一个码元可以携带多个比特的信息<br>个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的</p><h4 id="波特（Baud）"><a href="#波特（Baud）" class="headerlink" title="波特（Baud）"></a>波特（Baud）</h4><p>用来指一秒可以传输多少个码元</p><h4 id="速率-1"><a href="#速率-1" class="headerlink" title="速率"></a>速率</h4><p>分为码元传输速率和信息传输速率.</p><p>信息传输速率就是b&#x2F;s，就是我们平常说的网速 </p><p>码元可以理解为几个比特的集合，所以信息传输速率（网速）&#x3D;码元传输速率x码元所带信息量（多少比特） </p><p>码元所带信息量（比特数）&#x3D;log2（码元进制数）</p><h4 id="带宽（Band-Width）"><a href="#带宽（Band-Width）" class="headerlink" title="带宽（Band Width）"></a>带宽（Band Width）</h4><p>用来表示最高数据速率</p><h4 id="奈式准则（Nyquist）"><a href="#奈式准则（Nyquist）" class="headerlink" title="奈式准则（Nyquist）"></a>奈式准则（Nyquist）</h4><p>是在<strong>理想状态下</strong>得出的结论</p><p><img src="https://img-blog.csdnimg.cn/20200626222053679.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="香农公式（Shannon）"><a href="#香农公式（Shannon）" class="headerlink" title="香农公式（Shannon）"></a>香农公式（Shannon）</h4><p>是在<strong>有噪声的信道中</strong>得出的结论</p><p><img src="https://img-blog.csdnimg.cn/20200626225409541.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200626225547833.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="基带信号和宽带-x2F-带通信号（Base-band，pass-band"><a href="#基带信号和宽带-x2F-带通信号（Base-band，pass-band" class="headerlink" title="基带信号和宽带&#x2F;带通信号（Base band，pass band)"></a>基带信号和宽带&#x2F;带通信号（Base band，pass band)</h4><p>计算机网络中用的基带信号是<strong>数字信号</strong></p><p><img src="https://img-blog.csdnimg.cn/20200626225921565.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>将数据转化为<strong>数字信号</strong><br>数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal)</p><p><img src="https://img-blog.csdnimg.cn/20200626154459852.png" alt="在这里插入图片描述"></p><p>模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal)</p><p><img src="https://img-blog.csdnimg.cn/20200626154431937.png" alt="在这里插入图片描述"></p><blockquote><p><strong>单极性不归零编码</strong>：只使用一个电压值，高电平表示1，低电平表示0.</p><p><strong>双极性不归零编码</strong>：用幅值相等的正负电平表示二进制数1和0.</p><p><strong>单极性归零编码</strong>：发送码1时高电平在整个码元期间只持续一段时间，其余时间返回零电平。</p><p><strong>双极性归零编码</strong>：正负零三个电平，信号本身携带同步信息。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200626163610563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><strong>曼彻斯特编码</strong>：单极性编码的缺点是没有办法区分此时是没有信号，还是有信号，但是信号是0.<br>这种编码方式是bit中间有信号，低-高跳转表示0，高-低跳转表示1，一个时钟周期只可以表示一个bit，并且必须通过两次采样才能得到一个bit。它能携带时钟信号，而且能区分此时是没有信号还是信号为0.<br><strong>差分曼彻斯特编码</strong>：抗干扰能力比曼彻斯特编码更强。bit与bit之间有信号跳变，表示下一个bit为0，bit与bit之间没有信号跳变，表示下一个bit为1。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200626165018277.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="数据转化为模拟信号"><a href="#数据转化为模拟信号" class="headerlink" title="数据转化为模拟信号"></a>数据转化为模拟信号</h4><p>常用的调制方法：调频(AM)，调频(FM)，调相(PM)</p><p><img src="https://img-blog.csdnimg.cn/20200626165059865.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>模拟数据(analog data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)<br><img src="https://img-blog.csdnimg.cn/20200626154409879.png" alt="在这里插入图片描述"></p><p>数字数据(digtal data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)<br><img src="https://img-blog.csdnimg.cn/20200626154455793.png" alt="在这里插入图片描述"></p><h3 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h3><p>传输介质分为<strong>导向性</strong>传输介质和<strong>非导向性</strong>传输介质</p><p><img src="/img/2022-11-02-12-45-59-image.png"></p><h4 id="常见的导向性传输介质"><a href="#常见的导向性传输介质" class="headerlink" title="常见的导向性传输介质"></a>常见的导向性传输介质</h4><h6 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h6><p>根据有无屏蔽层分为<strong>屏蔽双绞线(STP)  和 无屏蔽双绞线（UTP）</strong></p><p><img src="https://img-blog.csdnimg.cn/20200627110148375.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="同轴电缆（Coaxial-Cable）"><a href="#同轴电缆（Coaxial-Cable）" class="headerlink" title="同轴电缆（Coaxial Cable）"></a>同轴电缆（Coaxial Cable）</h6><p><img src="https://img-blog.csdnimg.cn/20200627110353962.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="光纤（Optical-fiber）"><a href="#光纤（Optical-fiber）" class="headerlink" title="光纤（Optical fiber）"></a>光纤（Optical fiber）</h6><p><img src="https://img-blog.csdnimg.cn/20200627110509407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>根据<strong>入射角</strong>不同，又分为单模光纤和多模光纤</p><p><img src="https://img-blog.csdnimg.cn/20200627110700437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="常见的非导向性传输介质"><a href="#常见的非导向性传输介质" class="headerlink" title="常见的非导向性传输介质"></a>常见的非导向性传输介质</h4><p>包括<strong>无线电波</strong>，<strong>微波</strong>，<strong>红外线</strong>和<strong>激光</strong>等</p><p><img src="https://img-blog.csdnimg.cn/20200627110843264.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h3><h4 id="中继器（RP-repeater）"><a href="#中继器（RP-repeater）" class="headerlink" title="中继器（RP repeater）"></a>中继器（RP repeater）</h4><p>释：5-4-3规则是为了限制中继器使用次数的，理由可见图<br>5是指不能超过5个网段<br>4是指在这些网段中的物理层网络设备（中继器，集线器）最多不超过4个<br>3是指这些网段中最多只有三个网段挂有计算机</p><p><img src="https://img-blog.csdnimg.cn/20200627111139163.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="集线器（Hub）"><a href="#集线器（Hub）" class="headerlink" title="集线器（Hub）"></a>集线器（Hub）</h4><p>集线器是个大的冲突域，同时<strong>只能有两个设备进行通讯</strong>，只会传输信号，没有智能。</p><p><img src="https://img-blog.csdnimg.cn/20200627111545392.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://img-blog.csdnimg.cn/6c92a14c127f4cb8af79bf6e2d4cfac2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5saW5LQw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><h2 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>物理层为我们传输01电信号做出了不少贡献。但是在物理层也提到，物理层自己不知道自己传输的信号有什么意义。<br>这就是”链接层”的功能，它规定了解读方式：多少个电信号算一组？每个信号位有何意义？<br><img src="https://img-blog.csdnimg.cn/20200627112630722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="链路层编址"><a href="#链路层编址" class="headerlink" title="链路层编址"></a>链路层编址</h3><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。<br><strong>“标头”包含数据包的一些说明项</strong>，比如发送者、接受者、数据类型等等；</p><p><strong>”数据”则是数据包的具体内容。</strong><br>“标头”的长度，固定为<strong>18字节</strong>。”数据”的长度，<strong>最短为46字节，最长为1500字节</strong>。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？<br>以太网规定，连入网络的所有设备，都必须<strong>具有”网卡”接口</strong>。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做<strong>MAC地址</strong>。<strong>长度为6字节，共48比特</strong>，通常用十六进制表示法，地址的<strong>每个字节被表示为一对十六进制数</strong></p><p>每个适配器具有一个<strong>唯一</strong>的MAC地址，不随位置发生变化（就像人的身份证，而IP则像人的邮政地址）<br>一台路由器的每个接口都有一个ARP模块和一个适配器；<br>MAC地址分配：当一个公司要生产适配器时，它支付象征性的费用购买一块MAC地址空间，IEEE分配这块地址时，固定前24比特，让公司自己为每个适配器生成后24比特的唯一组合</p><h4 id="ARP协议-地址解析协议"><a href="#ARP协议-地址解析协议" class="headerlink" title="ARP协议(地址解析协议)"></a>ARP协议(地址解析协议)</h4><p>通过MAC，我们定义了地址。但是我们紧接着就有一个问题，那就是<strong>一块网卡怎么会知道另一块网卡的MAC地址？</strong><br>答案就是<strong>ARP协议</strong>。<br><strong>每个节点的ARP模块都在它的RAM中有一个ARP表，包含IP地址到MAC地址的映射关系，每个表项还包含TTL字段，表示表项过期时间</strong>（ARP表是自动创建的，如果某节点与子网断开连接，它的表项最终会从留在子网中的节点的表中删除。通常一个表项的过期时间是20分钟）<br>主机向其ARP模块提供一个IP地址，ARP模块返回IP地址对应的MAC地址<br>（注释：在OSI七层模型中，ARP属于链路层模型，所以这里也先简单介绍一下，构建知识体系）<br><img src="https://img-blog.csdnimg.cn/2020062822274549.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="广播的概念"><a href="#广播的概念" class="headerlink" title="广播的概念"></a>广播的概念</h4><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是<strong>向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方</strong>。</p><p><img src="https://img-blog.csdnimg.cn/b2decf161641498c85ae847f02beca8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5saW5LQw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”<strong>标头</strong>”，<strong>找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包</strong>，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”<strong>广播</strong>”（broadcasting）。<br>有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p><h3 id="封装成帧与透明传输"><a href="#封装成帧与透明传输" class="headerlink" title="封装成帧与透明传输"></a>封装成帧与透明传输</h3><p><strong>封装成帧</strong>就是加将网络数据报加头加尾，相当于将数据打包<br><strong>透明传输</strong>就是为了防止<strong>特殊的数据无法正常传输</strong>的的情况的发生，比如说在封装成帧的过程中，可能出现数据中的某些标记符与开始&#x2F;结束标记符恰巧重复的情况，如果不加以处理，那么会导致无法判定帧的开始于结束。</p><p><img src="https://img-blog.csdnimg.cn/20200627121353485.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="透明传输的实现方法"><a href="#透明传输的实现方法" class="headerlink" title="透明传输的实现方法"></a>透明传输的实现方法</h4><h5 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h5><p>就是在帧的首部做计数，这个字符记录了当前帧有多少个字符。<br>缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧<br>比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误</p><p><img src="https://img-blog.csdnimg.cn/20200627122122260.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h5><p>就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，<strong>开始和结束的对应的字符不一样</strong><br>但有可能出现数据内某段比特流数据正好<strong>与标记字段重复</strong>，从而导致误判断的情况</p><p><img src="https://img-blog.csdnimg.cn/20200627122415229.png?xshadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><p>添加转义字符。即对于那些与标记字符重复的数据流，在它们的前面添加一段转义字符，这样接收方在解析帧时，看到这些转义字符就不会认为那些特殊的数据当成帧的开始&#x2F;结束了。</p><p><img src="https://img-blog.csdnimg.cn/20200627122642435.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h5><p><img src="https://img-blog.csdnimg.cn/20200627122934743.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h5><p>因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就<strong>不会与数据冲突</strong></p><p><img src="https://img-blog.csdnimg.cn/20200627123050151.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><h4 id="差错是什么，从哪来的"><a href="#差错是什么，从哪来的" class="headerlink" title="差错是什么，从哪来的"></a>差错是什么，从哪来的</h4><p><strong>数据链路层</strong>的差错检测的是<strong>比特</strong>的错误<br>需要注意的是，即使采用差错检测比特，也还是可能有未检出比特差错的情况。<br>因此，主要是选择一个差错检测方案，使得这种事件发生的概率很小</p><p><img src="https://img-blog.csdnimg.cn/2020062712365377.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="为什么要在数据链路层进行差错控制？"><a href="#为什么要在数据链路层进行差错控制？" class="headerlink" title="为什么要在数据链路层进行差错控制？"></a>为什么要在数据链路层进行差错控制？</h4><p>因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费</p><h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><h5 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h5><p>奇偶校验：只需包含1个附加比特。<br>对于偶校验，选择一个值，使得所有比特中1出现偶数次。<br>对于奇校验，选择一个值，使得所有比特中1出现奇数次。接收方通过检测1出现的次数判断是否出现差错。如果出现偶数个比特差错，则检验不出<br>缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%<br><img src="https://img-blog.csdnimg.cn/20200627130921199.png" alt="在这里插入图片描述"></p><h5 id="循环冗余码CRC"><a href="#循环冗余码CRC" class="headerlink" title="循环冗余码CRC"></a>循环冗余码CRC</h5><p>发送方和接收方协商一个r+1比特的生成多项式(G)，要起其最高比特位为1。发送方通过在d比特的数据后附加r比特，使得整个(d+r)比特的值能够被G整除。接收方用G去除(d+r)比特，如果余数非0，则出现差错</p><p><img src="https://img-blog.csdnimg.cn/2020062713153254.png" alt="在这里插入图片描述"></p><p>实际例子<br>注释：<br>1.阶数就是最高位是哪位，然后位数-1，如10011就是5-1&#x3D;4,1011就是4-1&#x3D;3<br>2.异或运算就是相同得0，不同得1，比如100和101做异或，结果就是001<br>3.出书和最后的余数添加到要发送的数据后面，称为<strong>帧检验序列FCS</strong></p><p><img src="https://img-blog.csdnimg.cn/20200627131633434.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>接收方收到数据后进行检测</p><p><img src="https://img-blog.csdnimg.cn/20200627132107709.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>需要注意的地方</p><p><img src="https://img-blog.csdnimg.cn/20200627132214691.png" alt="在这里插入图片描述"></p><h4 id="纠错编码（海明码）"><a href="#纠错编码（海明码）" class="headerlink" title="纠错编码（海明码）"></a>纠错编码（海明码）</h4><p>分为四步</p><h5 id="第一步-确认校验码位数r"><a href="#第一步-确认校验码位数r" class="headerlink" title="第一步 确认校验码位数r"></a>第一步 确认校验码位数r</h5><p><img src="https://img-blog.csdnimg.cn/20200627132546766.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="第二步-确定校验码和数据的位置"><a href="#第二步-确定校验码和数据的位置" class="headerlink" title="第二步 确定校验码和数据的位置"></a>第二步 确定校验码和数据的位置</h5><p>注释：<br>1.为什么是10为数据位？因为4位校验码+6位信息位&#x3D;10位<br>2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位</p><p><img src="https://img-blog.csdnimg.cn/20200627132725336.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="第三步-求出校验码的值"><a href="#第三步-求出校验码的值" class="headerlink" title="第三步 求出校验码的值"></a>第三步 求出校验码的值</h5><p>注释<br>1.先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注<br>2.然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位<br>这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5<br><img src="https://img-blog.csdnimg.cn/20200627133356420.png" alt="在这里插入图片描述"></p><p>然后计算异或值，比如说这里D1&#x3D;1,D2&#x3D;0,D4&#x3D;1,D5&#x3D;0,就是p1要同时和0,1，0,1进行异或之后得到0，为了标识我加粗原始计算数据<br>举例：0和1异或得1,1和0异或得1,1和1异或得0，那么p1和0异或得0，p1就是0了<br>3.其他同理，按顺序计算出P2,P3,P4,然后填入表格</p><p><img src="https://img-blog.csdnimg.cn/20200627133056623.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="第四步-检测并纠错"><a href="#第四步-检测并纠错" class="headerlink" title="第四步 检测并纠错"></a>第四步 检测并纠错</h5><p>就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位</p><p><img src="https://img-blog.csdnimg.cn/20200627134416184.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="数据链路层的流量控制和可靠传输"><a href="#数据链路层的流量控制和可靠传输" class="headerlink" title="数据链路层的流量控制和可靠传输"></a>数据链路层的流量控制和可靠传输</h3><h4 id="流量控制与可靠传输"><a href="#流量控制与可靠传输" class="headerlink" title="流量控制与可靠传输"></a>流量控制与可靠传输</h4><p>流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费<br>可靠传输是发送端发送什么，接收端就要受到什么</p><h4 id="停止等待协议（Stop-and-Wait）"><a href="#停止等待协议（Stop-and-Wait）" class="headerlink" title="停止等待协议（Stop-and-Wait）"></a>停止等待协议（Stop-and-Wait）</h4><p><img src="https://img-blog.csdnimg.cn/20200627150624453.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p>全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。<strong>全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）</strong>。指A→B的同时B→A，是瞬时同步的。</p><p>单工就是在只允许甲方向乙方传送信息，而乙方不能向甲方传送 。（比喻汽车的单行道。）</p><p>停止等待协议的<strong>无差错</strong>情况<br>注释：因为一次就一个，所以用0和1标记ack（确认序号）就行</p><p><img src="https://img-blog.csdnimg.cn/20200627150810912.png?xshadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>停止等待协议的<strong>有差错</strong>情况：<br>使用一个超时计时器，每发一帧就开始计时，设置时间略长于一个RTT（往返时延）。</p><blockquote><p>发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延<br><strong>RTT</strong>&#x3D;传播时延x2+处理时间(有时可能直接忽略)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200627151008798.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200627151301222.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200627151343650.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>停止等待协议的特点<br>1.简单<br>2.信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费</p><p><img src="https://img-blog.csdnimg.cn/20200627151529667.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200627151615649.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h4><p>因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率<br>注释：<br>累计确认：就是收到一个确认帧，那么<strong>它和它之前的所有帧</strong>都默认已收到，反之，如果某个确认帧没收到，那么<strong>它和它之后的所有帧</strong>都默认丢失（即使收到了也丢掉），进行重传</p><p><img src="https://img-blog.csdnimg.cn/2020062715251276.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>图是一个实例<br>注释：此图发送2帧时丢失，所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK，直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧<br>如果所示，GBN的形式就像排队，接收端为所有帧“预定”了接收位置，如果接收端发送的数据因为某些原因没有接收到，即使收到了这一帧后面所有的帧，这些“排在后面的”帧也要被丢弃<br><img src="https://img-blog.csdnimg.cn/20200627153111466.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>发送窗口不能无限大，与使用的编号的比特数有关，二进制表示。<br>很简单，就是1比特编号0和1,<br>同理2比特编号0-3，二进制表示就是00，01，10，11。<br>如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了<br>GBN的优缺点也显而易见，优点是相对于上面的停止等待协议，明显提高了信道利用率，缺点是因为重传机制的原因，导致已经收到数据却需要强行丢弃，进而造成浪费</p><h4 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h4><p>吸取了GBN协议的教训，我们打算尝试只重传错误的帧，这样的话就不用浪费资源把已经收到的帧再重传一次了。<br>在GBN中，仅有接收端有一个窗口来存放数据帧，在SR中，两者都有窗口了。<br>和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（注释：缓存不可能无限大）<br><strong>SR运行过程</strong>:<br>注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口；它可以继续接受窗口范围内排在2帧后面的数据帧，直至最后2帧收到后一次性确认窗口内的所有已经收到的帧，再移动窗口。</p><p><img src="https://img-blog.csdnimg.cn/20200627155019851.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>同样的，因为编号的问题，发送窗口不能无限大<br>当发送窗口最后和接受窗口<strong>大小相同</strong>时，利用率比较高</p><h3 id="介质访问控制技术"><a href="#介质访问控制技术" class="headerlink" title="介质访问控制技术"></a>介质访问控制技术</h3><p>就是让节点之间的通信不会进行相互干扰</p><p><img src="https://img-blog.csdnimg.cn/20200627160903721.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><p>虽然使用一条共享信道，但是通过多路复用技术组合进行传输，提高了信道的利用率</p><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h5><p><img src="https://img-blog.csdnimg.cn/2020062716134134.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h5><p>TDM的缺点就是利用率低，所以又衍生出了STDM<br><img src="https://img-blog.csdnimg.cn/20200627161416465.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h5><p>STDM的原则是先到先走，满了就发，相对于TDM提高了利用率<br><img src="https://img-blog.csdnimg.cn/20200627161525107.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h5><p>每个节点分配一种不同的编码，每个节点使用其唯一的编码来对发送的数据进行编码（如果精心选择编码，不同节点能同时传输）</p><p><img src="https://img-blog.csdnimg.cn/20200627161726662.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h4><p>所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快</p><h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h5><p>帧到达节点时，立刻传输。如果发生碰撞，节点将立即(在完全传输碰撞帧后)以概率p重传。否则，等待一个帧传输时间，再以概率p重传。信道有效传输速率实际不是R bps，而是时隙ALOHA的一半</p><p><img src="https://img-blog.csdnimg.cn/20200627162357969.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h5><p>时间被划分为时隙，每个节点的时间同步，帧的传输只在时隙的开始时进行。如果发生碰撞，在下一个时隙开始时以概率p重传，否则等待一个时隙再以概率p重传…（信道有效传输速率实际不是R bps，而是0.37R bps）   </p><h5 id="CSMA协议-载波侦听多路访问"><a href="#CSMA协议-载波侦听多路访问" class="headerlink" title="CSMA协议(载波侦听多路访问)"></a>CSMA协议(载波侦听多路访问)</h5><p><img src="https://img-blog.csdnimg.cn/20200627163031462.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="/img/2022-11-04-01-15-05-image.png"></p><h5 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h5><h6 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h6><p>因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞。 先侦听信道，如果没有其它节点在使用信道，则传输数据。但是有碰撞检测，如果发生碰撞，会停止传输剩下的数据，等待一个随机时间(通常比传输一帧短)后，再进行尝试。 知道自己发生碰撞的最长时间是2τ（两倍的传播时延），就是一去一回</p><p><img src="https://img-blog.csdnimg.cn/20200627172333977.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>图示传播时延对载波监听的影响</p><p><img src="https://img-blog.csdnimg.cn/20200627183458233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200627182153577.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="CSMA-x2F-CA协议"><a href="#CSMA-x2F-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h5><p><img src="https://img-blog.csdnimg.cn/20200627184714796.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200627184823659.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="CSMA-x2F-CD-与-CSMA-x2F-CA的区别"><a href="#CSMA-x2F-CD-与-CSMA-x2F-CA的区别" class="headerlink" title="CSMA&#x2F;CD 与 CSMA&#x2F;CA的区别"></a>CSMA&#x2F;CD 与 CSMA&#x2F;CA的区别</h5><p><img src="https://img-blog.csdnimg.cn/2020062718532038.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h4><p>主要包括两大类，一个是<strong>轮询协议</strong>，另一个是<strong>令牌传递协议</strong></p><h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h5><p>就是选出一个代表，让他控制所有的传输 </p><p>注释： 轮询开销在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销 等待延迟就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应. 单点故障很好理解，就是代表挂了 </p><p><img src="https://img-blog.csdnimg.cn/20200627190229529.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h5><p>注释：在节点之间没有收发数据的需求时，令牌在节点之间循环。</p><p> <strong>发送数据的流程:</strong></p><p>—-&gt;当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&gt;占用） </p><p>—-&gt;再将令牌与数据帧结合，让其在节点构成的环之间流动 </p><p>—-&gt;不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌 </p><p>—-&gt;最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍 问题基本和轮询协议相同</p><p><img src="https://img-blog.csdnimg.cn/20200627205055826.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><h4 id="局域网的概念"><a href="#局域网的概念" class="headerlink" title="局域网的概念"></a>局域网的概念</h4><p>概括：范围小，速度快，延迟低，节点平等<br><img src="https://img-blog.csdnimg.cn/20200627210439299.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="局域网的网络拓扑结构-96"><a href="#局域网的网络拓扑结构-96" class="headerlink" title="局域网的网络拓扑结构&#96;"></a>局域网的网络拓扑结构&#96;</h5><p>常用的是<strong>总线型拓扑</strong></p><p><img src="https://img-blog.csdnimg.cn/20200627210700283.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="局域网的传播介质"><a href="#局域网的传播介质" class="headerlink" title="局域网的传播介质"></a>局域网的传播介质</h5><p><img src="/img/2022-11-04-01-22-00-image.png"></p><h5 id="局域网介质访问方法"><a href="#局域网介质访问方法" class="headerlink" title="局域网介质访问方法"></a>局域网介质访问方法</h5><p><img src="https://img-blog.csdnimg.cn/20200627210926529.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h4><p><img src="https://img-blog.csdnimg.cn/20200627211026206.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="IEEE802标准"><a href="#IEEE802标准" class="headerlink" title="IEEE802标准"></a>IEEE802标准</h4><p><img src="https://img-blog.csdnimg.cn/20200627211306397.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="IEEE802描述的局域网参考模型"><a href="#IEEE802描述的局域网参考模型" class="headerlink" title="IEEE802描述的局域网参考模型"></a>IEEE802描述的局域网参考模型</h5><p><img src="https://img-blog.csdnimg.cn/20200627211401404.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><h5 id="以太网概念"><a href="#以太网概念" class="headerlink" title="以太网概念"></a>以太网概念</h5><p><img src="https://img-blog.csdnimg.cn/20200627211606200.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200627211721247.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="以太网的发展"><a href="#以太网的发展" class="headerlink" title="以太网的发展"></a>以太网的发展</h5><p><img src="https://img-blog.csdnimg.cn/20200627224030441.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="适配器和MAC地址"><a href="#适配器和MAC地址" class="headerlink" title="适配器和MAC地址"></a>适配器和MAC地址</h5><p><img src="https://img-blog.csdnimg.cn/20200627224149350.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h5><p>注释： </p><p>1.这里的mac层指的是数据链路层 </p><p>2.之前说过数据链路层将上一层ip数据包加头加尾:</p><p>    头就是目标地址（6字节），源地址（6字节），类型（2字节） </p><p>    尾就是FCS（帧检验序列），（4字节） </p><p>3.前导码不是MAC帧的一部分，目的是使时钟同步 </p><p>4.为什么数据长度时46~1500？ 因为有最小传输字节64字节，mac占用6+6+2+4&#x3D;18，所以数据最小为64-18&#x3D;46，1500则是规定的默认最大字节，没有理由</p><p><img src="https://img-blog.csdnimg.cn/20200627224520210.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a>10BASE-T以太网</h5><p><img src="https://img-blog.csdnimg.cn/20200627225136362.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h5><p><img src="https://img-blog.csdnimg.cn/20200627224252903.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h4><p><img src="https://img-blog.csdnimg.cn/20200627230045240.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200627230109894.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="两种无线局域网"><a href="#两种无线局域网" class="headerlink" title="两种无线局域网"></a>两种无线局域网</h5><p><img src="https://img-blog.csdnimg.cn/20200627230151259.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200627230158897.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><h4 id="广域网的概述"><a href="#广域网的概述" class="headerlink" title="广域网的概述"></a>广域网的概述</h4><p>概括一下，一个字大<br><img src="https://img-blog.csdnimg.cn/20200627230316639.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="PPP协议（Point-to-Point-Protocol）"><a href="#PPP协议（Point-to-Point-Protocol）" class="headerlink" title="PPP协议（Point-to-Point Protocol）"></a>PPP协议（Point-to-Point Protocol）</h4><p>PPP协议是目前<strong>使用最广泛</strong>的数据链路层协议，拨号基本都是PPP协议<br>PPP协议<strong>仅支持全双工</strong>链路</p><h5 id="PPP协议需要满足的要求"><a href="#PPP协议需要满足的要求" class="headerlink" title="PPP协议需要满足的要求"></a>PPP协议需要满足的要求</h5><p><img src="https://img-blog.csdnimg.cn/20200627230948785.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="PPP协议不需要满足的要求"><a href="#PPP协议不需要满足的要求" class="headerlink" title="PPP协议不需要满足的要求"></a>PPP协议不需要满足的要求</h5><p><img src="https://img-blog.csdnimg.cn/20200627230916385.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="PPP协议组成成分以及功能"><a href="#PPP协议组成成分以及功能" class="headerlink" title="PPP协议组成成分以及功能"></a>PPP协议组成成分以及功能</h5><p><img src="https://img-blog.csdnimg.cn/20200627231054259.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h5><p><img src="https://img-blog.csdnimg.cn/2020062723121486.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="HDLC协议（High-Level-Data-Link-Control）"><a href="#HDLC协议（High-Level-Data-Link-Control）" class="headerlink" title="HDLC协议（High-Level Data Link Control）"></a>HDLC协议（High-Level Data Link Control）</h4><h5 id="HDLC协议概述"><a href="#HDLC协议概述" class="headerlink" title="HDLC协议概述"></a>HDLC协议概述</h5><p><img src="https://img-blog.csdnimg.cn/20200627231345512.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="HDLC的三种站"><a href="#HDLC的三种站" class="headerlink" title="HDLC的三种站"></a>HDLC的三种站</h5><p><img src="https://img-blog.csdnimg.cn/202006272314286.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h5><p><img src="https://img-blog.csdnimg.cn/20200627231635817.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="PPP协议和HDLC协议对比"><a href="#PPP协议和HDLC协议对比" class="headerlink" title="PPP协议和HDLC协议对比"></a>PPP协议和HDLC协议对比</h4><p>为什么HDLC协议更可靠，但是我们使用PPP协议？<br>因为现在网络要求高，<strong>数据链路层本来就是不可靠的尽力传输</strong>，差错控制这些复杂的交给了TCP等<br><img src="https://img-blog.csdnimg.cn/2020062723171761.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h3><h4 id="网桥（Bridge）"><a href="#网桥（Bridge）" class="headerlink" title="网桥（Bridge）"></a>网桥（Bridge）</h4><p>使用网桥时，由于网桥会根据mac地址进行过滤，所以不会形成冲突域</p><h5 id="两种网桥"><a href="#两种网桥" class="headerlink" title="两种网桥"></a>两种网桥</h5><h6 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h6><p>通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时数据对应的地址和网桥自己的接口，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要传数据包就知道要往哪个接口发送数据包了</p><h6 id="原路由网桥"><a href="#原路由网桥" class="headerlink" title="原路由网桥"></a>原路由网桥</h6><p>在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式向目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快了</p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p> 网桥接口越来越多，网桥就变成了交换机 </p><p>交换机的任务是接收入链路层帧并将它们转发到出链路 </p><p>交换机自身对节点透明：某节点向另一节点寻址一个帧，顺利地将该帧发送进LAN，而不知道这个帧经过了某个交换机的接收与转发</p><p><strong>1）交换机转发与过滤</strong><br>过滤：交换机决定一个帧是应该转发还是应该丢弃<br>转发：决定一个帧应该被导向哪个接口</p><p><strong>2）自学习(即插即用)</strong><br>交换机表是自动、动态、自治地建立的，没有来自网络管理员或配置协议的任何干预。换句话说，交换机是自学习的<br>交换机表初始为空<br>源地址为DD-DD-DD-DD-DD-DD的帧从接口x到达时，如果不存在则新建一项；存在则更新当前时间<br>如果一段时间后，在x接口没有来自DD-DD-DD-DD-DD-DD的帧，则将该表项删除<br><img src="https://img-blog.csdnimg.cn/2020062800263617.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h4><p><img src="https://img-blog.csdnimg.cn/20200628001124492.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/bd79ce61be7d4a8189e287512664be38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5saW5LQw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><h4 id="网络层的由来"><a href="#网络层的由来" class="headerlink" title="网络层的由来"></a>网络层的由来</h4><p>在数据链路层中，我们提到了<strong>MAC地址这个唯一的身份编址</strong>。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>因此，必须找到一种方法，<strong>能够区分哪些MAC地址属于同一个子网络</strong>，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。<br>这就导致了”网络层”的诞生。它的作用是<strong>引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络</strong>。这套地址就叫做”<strong>网络地址</strong>”，简称”网址”。于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><h4 id="网络层的主要功能"><a href="#网络层的主要功能" class="headerlink" title="网络层的主要功能"></a>网络层的主要功能</h4><p>TCP&#x2F;IP体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。<strong>网络层不提供服务质量的承诺</strong>，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。<strong>进程之间通信的可靠性由运输层负责</strong>。</p><p>注释：<br>数据报和分组的关系：数据报是一段比较长的数据，将它进行切割成一段段之后就得到分组<br>功能一就是让数据在路由器之间走最佳的路径<br>功能二就是让不同的设备（手机，电脑，平板等）都能正常连接<br>功能三见图中解释<br>开环控制就是在拥塞之前就提前设计解决<br>闭环控制就是在拥塞时自动调整解决问题<br><img src="https://img-blog.csdnimg.cn/20200628100232914.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="/img/2022-11-04-18-08-10-image.png"></p><h3 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h3><p>什么要进行数据交换？因为每个节点之间都拉网线太麻烦了也不实际，所以通过大量交换设备互联进行数据交换<br><img src="https://img-blog.csdnimg.cn/20200628101240749.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>常见的例子：打电话<br>注释：<br>链路支持多路复用（可参考数据链路层的TDM等）<br>特点是独占资源，因为两者建立了连接</p><p><img src="https://img-blog.csdnimg.cn/20200628134105730.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><p>注释：报文发送的过程 </p><p>1.源先根据报文加上ip地址，物理地址等，通过物理层发送 </p><p>2.交换机收到报文之后，先进行存储，等待链路空闲之后进行转发，但是转发的路径不是固定的，是比较随机的 </p><p>3.最后通过许多交换机最终到达目的地</p><p><img src="https://img-blog.csdnimg.cn/20200628134558218.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>分组交换和报文交换基本相同，就是将报文切割之后再进行发送 </p><p><img src="https://img-blog.csdnimg.cn/20200628135456570.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="分组交换和报文交换的具体计算对比"><a href="#分组交换和报文交换的具体计算对比" class="headerlink" title="分组交换和报文交换的具体计算对比"></a>分组交换和报文交换的具体计算对比</h3><p>注释：是怎么计算的？ </p><p>报文交换：一共三段，每段都需要10000bit&#x2F;1000bps&#x3D;10s，三段就是3x10&#x3D;30s </p><p>分组交换：可以分为两段，一个是第一个数据开始发到最后一个数据从源发出，一段是最后一个数据到达目的地。第一段总时间是10000bit&#x2F;1000bps&#x3D;10s，第二段总时间是（10&#x2F;1000）*2&#x3D;0.02s，所以总时间是10.02s。 </p><p>理解一下，这里就是报文交换的时候，由于报文没有分割，所以即使先到的数据也不能先发走，只能等到最后一段报文全部到了之后才能一起走，相对于分组交换明显拖慢了前面数据的速度，所以导致报文交换明显慢于分组交换 </p><p>可以看到分组交换明显快于报文交换，所以我们通常使用分组交换</p><p><img src="https://img-blog.csdnimg.cn/20200628140059520.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="分组传输的两种传输方式-数据报与虚电路"><a href="#分组传输的两种传输方式-数据报与虚电路" class="headerlink" title="分组传输的两种传输方式-数据报与虚电路"></a>分组传输的两种传输方式-数据报与虚电路</h4><h5 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h5><p><img src="https://img-blog.csdnimg.cn/20200628141302754.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200628151011994.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h5><p><img src="https://img-blog.csdnimg.cn/20200628150810177.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h5><p><img src="https://img-blog.csdnimg.cn/20200628150941414.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="路由算法和路由协议概述"><a href="#路由算法和路由协议概述" class="headerlink" title="路由算法和路由协议概述"></a>路由算法和路由协议概述</h3><p>路由算法就是让路由知道收到报文之后下一步怎么走<br><img src="https://img-blog.csdnimg.cn/2020062815165630.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>AS就是多个路由器之间构成的单独的小圈子，圈子内使用自己的协议，<strong>圈子和圈子之间用的是BGP协议</strong></p><p><img src="https://img-blog.csdnimg.cn/2020062815185760.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="RIP协议和距离向量算法"><a href="#RIP协议和距离向量算法" class="headerlink" title="RIP协议和距离向量算法"></a>RIP协议和距离向量算法</h4><h5 id="RIP协议概述"><a href="#RIP协议概述" class="headerlink" title="RIP协议概述"></a>RIP协议概述</h5><p>通过交换信息构建路由表<br><img src="https://img-blog.csdnimg.cn/20200629105637285.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="如何建立路由表"><a href="#如何建立路由表" class="headerlink" title="如何建立路由表"></a>如何建立路由表</h5><p><img src="https://img-blog.csdnimg.cn/20200629105916914.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="RIP协议报文格式"><a href="#RIP协议报文格式" class="headerlink" title="RIP协议报文格式"></a>RIP协议报文格式</h5><p><img src="https://img-blog.csdnimg.cn/20200629111259211.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="RIP协议特点"><a href="#RIP协议特点" class="headerlink" title="RIP协议特点"></a>RIP协议特点</h5><p>就是来回更新路由表，错误信息被覆盖，导致直至达到距离上限强制错误时才可以得知出错</p><p><img src="https://img-blog.csdnimg.cn/20200629111526974.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629111637786.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629111700886.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629111718198.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h5><p>注释： </p><p>为什么改地址？因为图中是从x得到的信息 </p><p>为什么距离固定+1？因为路由器只从相邻路由器之间获取RIP报文，举例只会是1 </p><p>为什么下一跳是x就要替换？因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的 </p><p>为什么下一跳不是x时有更新和不处理两种手段？因为这样可以提高效率，比原来快就换，比原来慢就保留原来的，也可以理解</p><p><img src="https://img-blog.csdnimg.cn/20200629110232985.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020062911085927.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629111155473.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="OSPF协议和链路状态算法"><a href="#OSPF协议和链路状态算法" class="headerlink" title="OSPF协议和链路状态算法"></a>OSPF协议和链路状态算法</h4><h5 id="OSPF协议概述"><a href="#OSPF协议概述" class="headerlink" title="OSPF协议概述"></a>OSPF协议概述</h5><p><img src="https://img-blog.csdnimg.cn/20200629111933218.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="OSPF的其他特点"><a href="#OSPF的其他特点" class="headerlink" title="OSPF的其他特点"></a>OSPF的其他特点</h5><p>为什么OSPF收敛速度快？因为它只是刷新一下链路状态，得知其是否连通，不需要和RIP一样进行对照，而是直接通过Dijilstra算法来自己算出路径</p><p><img src="https://img-blog.csdnimg.cn/20200629115353647.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h5><p>了解即可<br><img src="https://img-blog.csdnimg.cn/20200629115012290.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="OSPF区域"><a href="#OSPF区域" class="headerlink" title="OSPF区域"></a>OSPF区域</h5><p>了解即可</p><p><img src="https://img-blog.csdnimg.cn/20200629115212801.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h5><p>了解即可<br><img src="https://img-blog.csdnimg.cn/20200629115305114.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h4><h5 id="BGP协议简介"><a href="#BGP协议简介" class="headerlink" title="BGP协议简介"></a>BGP协议简介</h5><p><img src="https://img-blog.csdnimg.cn/20200629202605883.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="BGP协议交换信息的过程"><a href="#BGP协议交换信息的过程" class="headerlink" title="BGP协议交换信息的过程"></a>BGP协议交换信息的过程</h5><p>了解即可，只需要知道BGP交换协议里面交换的是一组路径向量<br><img src="https://img-blog.csdnimg.cn/20200629203846439.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629202751648.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629202816442.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a>BGP协议报文格式</h5><p><strong>BGP是应用层协议</strong><br><img src="https://img-blog.csdnimg.cn/2020062920290996.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="BGP协议特点"><a href="#BGP协议特点" class="headerlink" title="BGP协议特点"></a>BGP协议特点</h5><p><img src="https://img-blog.csdnimg.cn/20200629203255760.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="BGP的四种报文"><a href="#BGP的四种报文" class="headerlink" title="BGP的四种报文"></a>BGP的四种报文</h5><p><img src="https://img-blog.csdnimg.cn/20200629203720460.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a>三种路由协议的比较</h4><p><img src="https://img-blog.csdnimg.cn/20200629204214191.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629204241177.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><h4 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><p>注释：</p><p><img src="/img/2022-11-04-18-21-07-image.png"></p><p><img src="https://img-blog.csdnimg.cn/20200628163753975.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200628163922707.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>计算偏移量时记住是以0开始的就行，以每一篇最开始的除以8得到的数值就是偏移量<br>MF和DF的定义见上图<br><img src="https://img-blog.csdnimg.cn/20200628164237523.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><h4 id="ipv4地址"><a href="#ipv4地址" class="headerlink" title="ipv4地址"></a>ipv4地址</h4><p><strong>全球唯一的</strong>表示某一个主机或者路由器接口的编码</p><h5 id="ip地址分类"><a href="#ip地址分类" class="headerlink" title="ip地址分类"></a>ip地址分类</h5><p><img src="https://img-blog.csdnimg.cn/20200628165300355.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="特殊ip地址"><a href="#特殊ip地址" class="headerlink" title="特殊ip地址"></a>特殊ip地址</h5><p><img src="https://img-blog.csdnimg.cn/2020062816534040.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="私有ip地址"><a href="#私有ip地址" class="headerlink" title="私有ip地址"></a>私有ip地址</h5><p><img src="https://img-blog.csdnimg.cn/20200628165703918.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解释一下</p><p>为什么A类最大是126.xxx.xxx.xxx？<br>因为网络号最开始第一位是0，一共八位，所以二进制表示位0xxxxxxx，最大就是2^7-1&#x3D;127，但是因为127.xxx.xxx.xxx是特殊ip地址，所以将其去掉<br>为什么B类最大是191.255.xxx.xxx？<br>因为网络号最开始第一位是10，一共八位，所以二进制表示位10xxxxxx，最大就是10111111&#x3D;191，最小就是10000000&#x3D;128，无特殊ip地址<br>为什么C类最大是223.255.xxx.xxx？<br>因为网络号最开始第一位是110，一共八位，所以二进制表示位110xxxxx，最大就是11011111&#x3D;223，最小就是10000000&#x3D;192，无特殊ip地址</p><p><img src="https://img-blog.csdnimg.cn/20200628173140760.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>注释：连接内网和外网，就是找个代理的用它的ip地址与外面收发数据<br>NAT需要构建NAT转换表，既要存广域网（WAN，外网）也要存局域网（LAN，内网）的ip地址和端口号<br><img src="https://img-blog.csdnimg.cn/20200628203040212.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h4><h5 id="为什么需要子网划分"><a href="#为什么需要子网划分" class="headerlink" title="为什么需要子网划分"></a>为什么需要子网划分</h5><p>总结一下，就是ip不够用，所以需要额外整个子网扩展ip<br><img src="https://img-blog.csdnimg.cn/20200628203445257.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注释：<br>为什么子网好能全0或者全1：因为CIDR编址（可见下一段）<br>为什么主机号不能全0或者全1：因为全0代表本网络，全1代表广播分组</p><p><img src="https://img-blog.csdnimg.cn/20200628203628674.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p><strong>子网掩码就是用来和ip地址一起计算子网的地址的</strong><br>方法就是将子网掩码逐位写成二进制然后和原来ip地址进行与运算，就可以得到子网ip地址<br>因为255是11111111，所以如果写着255的话，ip地址和子网ip地址对应的地方的数值就相同<br><img src="https://img-blog.csdnimg.cn/20200628204154511.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这道题可以看出来，即使子网掩码不同，相同ip地址对应的子网ip地址也可能相同<br>但是子网掩码不同，划分的子网数目不同<br>为什么划分的子网数目不同？或者说怎么算划分的子网位数目？<br>以255.255.192.0为例，255是11111111即八个1,192是11000000即2个1，一共是82+2&#x3D;18个1，一共有32位地址，所以剩余有32-18&#x3D;14位<br>以255.255.224.0为例，255是11111111即八个1,224是11100000即3个1，一共是82+3&#x3D;19个1，一共有32位地址，所以剩余有32-19&#x3D;13位</p><p><img src="https://img-blog.csdnimg.cn/20200628204442714.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这道题先将255.255.252.0计算出一共有8+8+6&#x3D;22位网络号位<br>所以就有32-22&#x3D;10位主机号位<br>将180.80.77.55解析，可以知道在77部分某部分开始会用来表示主机号位<br>77的二进制是0100 1101，因为一共有22位网络号位，所以010011 （此处分开） 01，从这个01开始是主机号位。<br>所以用来表示子网ip地址的应该是180.80.76（010011 00）.xxx PS注意76括号内后两位二进制00<br>但是本体是发布广播地址，所以主机号全部都要是1<br>所以应该是180.80.79（010011 11）.255（11111111）注意79括号内后两位二进制11<br><img src="https://img-blog.csdnimg.cn/2020062821061359.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注释：<br>1.这里特定主机路由就是指找特定的处理这里这个ip地址的路由<br>2.默认路由会将这个数据报发给另一个路由，直至找到对应的路由，或者TTL耗尽被丢弃<br><img src="https://img-blog.csdnimg.cn/20200628212251576.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="无分类编制CIDR"><a href="#无分类编制CIDR" class="headerlink" title="无分类编制CIDR"></a>无分类编制CIDR</h4><p><img src="https://img-blog.csdnimg.cn/20200628213057516.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用CIDR可以聚合网络<br>如图，通过缩短前缀，R1和R2就可以合并在206.1.0.0&#x2F;16的子网下<br>但是这样转发表之中就会有多个匹配结果，所以我们使用<strong>最长前缀匹配</strong></p><p><img src="https://img-blog.csdnimg.cn/20200628214310460.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最长前缀匹配就是在计算后符合同一子网的时候，选前缀越长的<br>这道题选B</p><p><img src="https://img-blog.csdnimg.cn/20200628214654941.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>因为本网络是192.168.5.0&#x2F;24，就是192.168.5.（0000 0000）&#x2F;24，将248写成二进制是11111 000，有五个1，所以前五位都可以作为子网的编号，剩下的三位就是用来分配子网内剩余的地址了，因为不能全0或者全1，所以还要减2<br><img src="https://img-blog.csdnimg.cn/20200628220204999.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p><img src="https://img-blog.csdnimg.cn/2020062822274549.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200628222947367.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h4><p><img src="https://img-blog.csdnimg.cn/20200628223418552.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><h5 id="ICMP协议概述"><a href="#ICMP协议概述" class="headerlink" title="ICMP协议概述"></a>ICMP协议概述</h5><p>ICMP，IGMP处于网络层和传输层之间，就是为了更好地转发ip数据报和提高交互成功的几率<br><img src="https://img-blog.csdnimg.cn/20200628223751853.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h5><h6 id="ICMP差错报告报文如何与IP数据报结合"><a href="#ICMP差错报告报文如何与IP数据报结合" class="headerlink" title="ICMP差错报告报文如何与IP数据报结合"></a>ICMP差错报告报文如何与IP数据报结合</h6><p><img src="https://img-blog.csdnimg.cn/20200629094024680.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="五种ICMP差错报文"><a href="#五种ICMP差错报文" class="headerlink" title="五种ICMP差错报文"></a>五种ICMP差错报文</h6><p>其中源点抑制已废弃不用</p><p><img src="https://img-blog.csdnimg.cn/20200629083834897.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="四种不发送ICMP差错报文的情况"><a href="#四种不发送ICMP差错报文的情况" class="headerlink" title="四种不发送ICMP差错报文的情况"></a>四种不发送ICMP差错报文的情况</h6><p>注释：组播是指由一点到多点，但不是无脑发到所有点，无脑发到所有点的是广播，组播有筛选条件</p><p><img src="https://img-blog.csdnimg.cn/20200629094235772.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h5><h6 id="四种ICMP询问报文"><a href="#四种ICMP询问报文" class="headerlink" title="四种ICMP询问报文"></a>四种ICMP询问报文</h6><p>后两种是掩码地址请求和回答报文，路由器询问和通告报文，这两个已经废弃不再使用<br><img src="https://img-blog.csdnimg.cn/20200629094521489.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h5><p>1.ping命令：测试两个主机之间连通性，使用了<strong>ICMP回送请求和回答报文</strong><br>2.traceroute命令：跟踪一个分组从原点到终点的路径，使用了<strong>ICMP时间超过差错报告报文</strong></p><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><h4 id="为什么会有IPV6"><a href="#为什么会有IPV6" class="headerlink" title="为什么会有IPV6"></a>为什么会有IPV6</h4><p>就是IPV4地址用完了，从根本上增加ip地址数目，之前讲的NAT和CIDR也只是在IPV4的基础上扩展了IPV4地址数目，治标不治本<br><img src="https://img-blog.csdnimg.cn/20200629095311686.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="IPV6地址表示形式"><a href="#IPV6地址表示形式" class="headerlink" title="IPV6地址表示形式"></a>IPV6地址表示形式</h4><p><img src="https://img-blog.csdnimg.cn/20200629102621942.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="IPV6数据报格式"><a href="#IPV6数据报格式" class="headerlink" title="IPV6数据报格式"></a>IPV6数据报格式</h4><p><img src="/img/2022-11-04-18-29-56-image.png"></p><p><img src="https://img-blog.csdnimg.cn/20200629095626140.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="IPV4和IPV6的区别"><a href="#IPV4和IPV6的区别" class="headerlink" title="IPV4和IPV6的区别"></a>IPV4和IPV6的区别</h4><p><img src="https://img-blog.csdnimg.cn/20200629102457217.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="IPV6基本地址类型"><a href="#IPV6基本地址类型" class="headerlink" title="IPV6基本地址类型"></a>IPV6基本地址类型</h4><p><img src="/img/2022-11-04-18-30-35-image.png"></p><h4 id="IPV4和IPV6之间的过渡"><a href="#IPV4和IPV6之间的过渡" class="headerlink" title="IPV4和IPV6之间的过渡"></a>IPV4和IPV6之间的过渡</h4><p>如果是ipv6的数据报到了ipv4，就用ipv4重新封装，把ipv6数据报前面加上ipv4伪装成ipv4数据报继续传输，直至到了ipv6路由再解开ipv4伪装<br><img src="https://img-blog.csdnimg.cn/20200629103250467.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="IP组播（多播）"><a href="#IP组播（多播）" class="headerlink" title="IP组播（多播）"></a>IP组播（多播）</h3><h4 id="什么是组播"><a href="#什么是组播" class="headerlink" title="什么是组播"></a>什么是组播</h4><p>单播只能一对一，广播必须一对全部，组播就可以是一对全部中的一部分<br><img src="https://img-blog.csdnimg.cn/20200629205037734.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>辅助理解：单播所占资源多</p><p><img src="https://img-blog.csdnimg.cn/20200629210027661.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>组播明显减轻了压力<br><img src="https://img-blog.csdnimg.cn/20200629210108353.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h4><p><img src="https://img-blog.csdnimg.cn/20200629210330405.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="硬件组播"><a href="#硬件组播" class="headerlink" title="硬件组播"></a>硬件组播</h4><p>就像全F的mac地址代表广播一样，00-10-5E打头的MAC地址就代表组播<br>7为什么最大是00-10-5E-7F-FF-FF？因为只有最后23位决定</p><p><img src="https://img-blog.csdnimg.cn/20200629210827844.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="IGMP协议与组播路由选择协议"><a href="#IGMP协议与组播路由选择协议" class="headerlink" title="IGMP协议与组播路由选择协议"></a>IGMP协议与组播路由选择协议</h4><h5 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h5><p>注释：IGMP只能知道有没有组播组成员，对有几个组播组成员，成员在哪个地方都不知道<br><img src="https://img-blog.csdnimg.cn/20200629211352630.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629211613284.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a>组播路由选择协议</h5><p>有了这个，成员可以自行找到转发组，自行决定参加哪个组播（就像电视机选台一样）<br><img src="https://img-blog.csdnimg.cn/20200629211740525.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629211913501.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h3><p>移动IP<strong>不等于</strong>动态IP（DHCP获得的）<br>移动IP的可以让用户因为地理原因等等，即使不在内网也可以访问内网的东西</p><h4 id="移动IP的相关术语"><a href="#移动IP的相关术语" class="headerlink" title="移动IP的相关术语"></a>移动IP的相关术语</h4><p><img src="https://img-blog.csdnimg.cn/20200629212218336.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h4><p><img src="https://img-blog.csdnimg.cn/20200629212604875.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629220550874.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h3><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><h5 id="路由器的构造"><a href="#路由器的构造" class="headerlink" title="路由器的构造"></a>路由器的构造</h5><p><img src="https://img-blog.csdnimg.cn/20200629220712123.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="路由器的输入输出端口构造"><a href="#路由器的输入输出端口构造" class="headerlink" title="路由器的输入输出端口构造"></a>路由器的输入输出端口构造</h5><p><img src="https://img-blog.csdnimg.cn/20200629221015438.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200629221022561.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="集线器，网桥，路由表几层设备比较"><a href="#集线器，网桥，路由表几层设备比较" class="headerlink" title="集线器，网桥，路由表几层设备比较"></a>集线器，网桥，路由表几层设备比较</h5><p><img src="https://img-blog.csdnimg.cn/20200629221130818.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="路由器的路由表和转发表"><a href="#路由器的路由表和转发表" class="headerlink" title="路由器的路由表和转发表"></a>路由器的路由表和转发表</h5><p>这里实际上就是对前面知识的复习了<br><img src="https://img-blog.csdnimg.cn/20200629221253590.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/7d1c95c25a074eaeb8321331f90eda02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5saW5LQw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><h4 id="传输层的意义"><a href="#传输层的意义" class="headerlink" title="传输层的意义"></a>传输层的意义</h4><h5 id="传输层的由来"><a href="#传输层的由来" class="headerlink" title="传输层的由来"></a>传输层的由来</h5><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。 接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是<strong>每一个使用网卡的程序的编号</strong>。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 “端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。 </p><p>“传输层”的功能，就是<strong>建立”端口到端口”的通信</strong>。相比之下，<strong>”网络层”的功能是建立”主机到主机”的通信</strong>。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把<strong>主机+端口，叫做”套接字”（socket）</strong>。有了它，就可以进行网络应用程序开发了。</p><p>网络层可以把数据从一个主机传送到另一个主机，但是没有和进程建立联系；传输层就是讲进程和收到的数据联系到一起，使数据能够为应用服务<br>所以说<strong>传输层是主机才有的层次</strong></p><p><img src="https://img-blog.csdnimg.cn/20200630094441510.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="传输层的两个协议"><a href="#传输层的两个协议" class="headerlink" title="传输层的两个协议"></a>传输层的两个协议</h4><p><img src="https://img-blog.csdnimg.cn/20200630094727731.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="传输层的寻址和端口"><a href="#传输层的寻址和端口" class="headerlink" title="传输层的寻址和端口"></a>传输层的寻址和端口</h4><p>端口号只用于计算机分辨本地进程，总共有2^16&#x3D;65536种端口号，端口号有很多种，不能随便使用</p><p><img src="https://img-blog.csdnimg.cn/20200630095024127.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="常见的应用程序端口号"><a href="#常见的应用程序端口号" class="headerlink" title="常见的应用程序端口号"></a>常见的应用程序端口号</h5><p><img src="https://img-blog.csdnimg.cn/20200630095258962.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h4><p>因为UDP一次发送一个完整报文不会分片，所以需要应用层传输过来的数据不能太大，否则网络层分片任务就很重，但是也不能太小，不然效率较低 </p><p>UDP适合一些实时应用，因为实时应用延迟要求高，需要立即响应</p><p><img src="https://img-blog.csdnimg.cn/20200630095616466.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h4><p><img src="https://img-blog.csdnimg.cn/2020063010003161.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="UDP的校验位构成"><a href="#UDP的校验位构成" class="headerlink" title="UDP的校验位构成"></a>UDP的校验位构成</h5><p>这里的伪首部只是用来计算检验和的，计算完了就丢弃，可以见下UDP的校验方式</p><p><img src="https://img-blog.csdnimg.cn/20200630105441329.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="UDP校验方式"><a href="#UDP校验方式" class="headerlink" title="UDP校验方式"></a>UDP校验方式</h5><h6 id="在发送端："><a href="#在发送端：" class="headerlink" title="在发送端："></a>在发送端：</h6><p>就是将每一行（4字节）拆成两部分，左右平均2字节大小，将这两字节数据写成二进制，那么2字节一共就需要2*8&#x3D;16位。此时检验和没有计算，默认填充0，同时如果数据字段不整齐，则用0补齐，这样就可以写出几十行二进制数，如图中所示 </p><h6 id="在接收端"><a href="#在接收端" class="headerlink" title="在接收端:"></a>在接收端:</h6><p>与发送端的时候不同的是，此时检验和字段不是0了 按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和 </p><p>如果最后得到结果全1就是没问题，否则丢弃</p><p><img src="https://img-blog.csdnimg.cn/20200630105526400.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-3-UDP补充"><a href="#2-3-UDP补充" class="headerlink" title="2.3 UDP补充"></a>2.3 UDP补充</h4><h5 id="1-UDP怎么保证能收到数据？"><a href="#1-UDP怎么保证能收到数据？" class="headerlink" title="1.UDP怎么保证能收到数据？"></a>1.UDP怎么保证能收到数据？</h5><p>UDP将可靠传输的实现放到了应用层，然后类似于TCP，实现确认机制，重传机制 UDP不属于连接型协议，因而具有消耗资源小，处理速度快等优点，所以<strong>通常音频、视频通话在传送时使用UDP比较多</strong>，因为它们即使丢失一两个数据包也不会对结果产生太大影响 </p><p>目前有如下开源程序利用UDP实现了可靠的数据传输；分别有RUDP, RTP, UDT</p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><p>TCP必须要建立连接之后才可以进行数据交换，所以TCP是面向连接的</p><p><img src="https://img-blog.csdnimg.cn/20200630194247441.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>TCP传输数据是随机切割数据的</strong></p><p><img src="https://img-blog.csdnimg.cn/2020063020421472.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="TCP报文段的首部"><a href="#TCP报文段的首部" class="headerlink" title="TCP报文段的首部"></a>TCP报文段的首部</h4><p>见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以 序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号 </p><p>确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据 </p><p>偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度</p><p><img src="https://img-blog.csdnimg.cn/20200630210441410.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据<br>紧急指针就是告诉TCP从哪里到哪里是紧急数据</p><p><img src="https://img-blog.csdnimg.cn/20200630212601599.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="TCP的六个控制位"><a href="#TCP的六个控制位" class="headerlink" title="TCP的六个控制位"></a>TCP的六个控制位</h5><h6 id="紧急位URG"><a href="#紧急位URG" class="headerlink" title="紧急位URG"></a>紧急位URG</h6><p>URG的特点就是让数据插队，URG&#x3D;1的就会在缓存中被提前到第一个传输</p><p><img src="https://img-blog.csdnimg.cn/20200630211126589.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200630211151331.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="确认位ACK"><a href="#确认位ACK" class="headerlink" title="确认位ACK"></a>确认位ACK</h6><p><img src="https://img-blog.csdnimg.cn/20200630211354251.png" alt="在这里插入图片描述"></p><h6 id="推送位PSH"><a href="#推送位PSH" class="headerlink" title="推送位PSH"></a>推送位PSH</h6><p>就是接收端的URG，将PSH&#x3D;1的数据尽快接收 </p><p>如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机</p><p><img src="https://img-blog.csdnimg.cn/20200630212045298.png" alt="在这里插入图片描述"></p><h6 id="复位RST"><a href="#复位RST" class="headerlink" title="复位RST"></a>复位RST</h6><p><img src="https://img-blog.csdnimg.cn/20200630212049447.png" alt="在这里插入图片描述"></p><h6 id="同步位SYN"><a href="#同步位SYN" class="headerlink" title="同步位SYN"></a>同步位SYN</h6><p>A和B主机要建立连接，就A先发一个报文，其中SYN&#x3D;1 </p><p>B收到之后也回复一个SYN&#x3D;1的报文，代表接受连接</p><p><img src="https://img-blog.csdnimg.cn/20200630212152221.png" alt="在这里插入图片描述"></p><h6 id="终止位FIN"><a href="#终止位FIN" class="headerlink" title="终止位FIN"></a>终止位FIN</h6><p><img src="https://img-blog.csdnimg.cn/20200630212056958.png" alt="在这里插入图片描述"></p><h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><h5 id="TCP三次握手（建立连接）"><a href="#TCP三次握手（建立连接）" class="headerlink" title="TCP三次握手（建立连接）"></a>TCP三次握手（建立连接）</h5><p><img src="/img/2022-11-06-12-21-32-image.png"></p><h6 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h6><p>ROUND1的意思是 </p><p>SYN同步序号&#x3D;1：(A)要建立连接了！ </p><p>seq序号&#x3D;x（随机）：因为还没有数据，所以写什么都无所谓</p><p>ROUND2的意思是<br>SYN同步序号&#x3D;1：我(B)同意你(A)建立连接！<br>ACK确认序号&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq序号&#x3D;y（随机）：因为还没有数据，所以写什么都无所谓<br>ack确认号&#x3D;x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据</p><p>ROUND3的意思是<br>SYN&#x3D;0：SYN只有在建立连接时才为1，其他时候均设为0<br>ACK&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq&#x3D;x+1：我(A)发送的报文段的第一个字节就是x+1<br>ack&#x3D;y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据</p><p>注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方</p><p><img src="https://img-blog.csdnimg.cn/20200630213814996.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="TCP三次握手特定导致的SYN洪泛攻击"><a href="#TCP三次握手特定导致的SYN洪泛攻击" class="headerlink" title="TCP三次握手特定导致的SYN洪泛攻击"></a>TCP三次握手特定导致的SYN洪泛攻击</h6><p><img src="https://img-blog.csdnimg.cn/20200630214925395.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="TCP四次挥手（连接释放）"><a href="#TCP四次挥手（连接释放）" class="headerlink" title="TCP四次挥手（连接释放）"></a>TCP四次挥手（连接释放）</h5><p><img src="/img/2022-11-06-12-20-16-image.png"></p><h6 id="TCP的连续释放"><a href="#TCP的连续释放" class="headerlink" title="TCP的连续释放"></a>TCP的连续释放</h6><p>ROUND1的意思是 </p><p>FIN&#x3D;1：(A)要释放连接了！ </p><p>seq&#x3D;u：发了好多数据，这里只是用u指代一下，这里u是有确定值的</p><p>ROUND2的意思是<br>ACK&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq&#x3D;v：发了好多数据，这里只是用v指代一下，这里v是有确定值的<br>ack&#x3D;u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）</p><p>ROUND3的意思是<br>FIN&#x3D;1：(B)要释放连接了！<br>ACK&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq&#x3D;w：发了好多数据，这里只是用w指代一下，这里w是有确定值的<br>ack&#x3D;u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）</p><p>ROUND4的意思是<br>ACK&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq&#x3D;u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据<br>ack&#x3D;w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据</p><p>为什么需要等待计时2MSL？<br>因为这样可以保证B可以收到A的终止报文段进而进入关闭状态<br>比如说如果A的第四段报文丢失，那么等待1MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接</p><p><img src="https://img-blog.csdnimg.cn/20200630215522825.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h4><p>TCP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了</p><p><img src="https://img-blog.csdnimg.cn/20200630220542461.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号</p><img src="https://img-blog.csdnimg.cn/20200630221424853.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" title="" alt="在这里插入图片描述" width="414"><h5 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h5><p>发送方每一次发送数据之后都需要接收方进行确认。 TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4</p><p><img src="https://img-blog.csdnimg.cn/20200630221636424.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h5><p>为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs</p><p><img src="https://img-blog.csdnimg.cn/20200630222205619.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>简单来说就是接收方可以动态地发送信息告诉发送方发送窗口的大小。<br>接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了<br>接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了</p><p><img src="https://img-blog.csdnimg.cn/202006302226272.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h5><p>在本例子中，使用的累计确认机制（一次回复收到ack&#x3D;201）和三次流量控制机制。<br>但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象<br>解决方法：使用计时器</p><p><img src="https://img-blog.csdnimg.cn/20200630223616929.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>流量控制是对单独一个来说的，拥塞控制是一群</p><p><img src="https://img-blog.csdnimg.cn/20200630224242515.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="拥塞控制四种算法"><a href="#拥塞控制四种算法" class="headerlink" title="拥塞控制四种算法"></a>拥塞控制四种算法</h5><p>这里虽然是四种算法，但是通常是两两结合进行使用</p><p><img src="https://img-blog.csdnimg.cn/20200630232411944.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h5><p>这里开始时以指数形式增长，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。<br>之后一段都是线性增长，每次增加1，直至达到网络拥塞状态<br>瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1&#x2F;2,（这里是24降到12）<br>重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了</p><p><img src="https://img-blog.csdnimg.cn/20200630232910475.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h5><p>这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。<br>不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始</p><p><img src="https://img-blog.csdnimg.cn/20200630233701386.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="传输层常见题目收集"><a href="#传输层常见题目收集" class="headerlink" title="传输层常见题目收集"></a>传输层常见题目收集</h3><h4 id="TCP、UDP区别及使用场景"><a href="#TCP、UDP区别及使用场景" class="headerlink" title="TCP、UDP区别及使用场景"></a>TCP、UDP区别及使用场景</h4><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;  UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。<br>TCP对系统资源要求较多，UDP对系统资源要求较少。</p><h4 id="TCP两次握手可以吗？"><a href="#TCP两次握手可以吗？" class="headerlink" title="TCP两次握手可以吗？"></a>TCP两次握手可以吗？</h4><p>第三次握手主要为了防止已失效的连接请求报文段突然又传输到了服务端，导致产生问题。<br>比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。<br>连接成功，等待数据传输完毕后，就释放了连接。<br>然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。<br>如果不采用三次握手，只要B发出确认，就建立新的连接了，此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。</p><h4 id="第四次挥手为什么要等待2MSL？"><a href="#第四次挥手为什么要等待2MSL？" class="headerlink" title="第四次挥手为什么要等待2MSL？"></a>第四次挥手为什么要等待2MSL？</h4><p>1.保证A发送的最后一个ACK报文段能够到达B。<br>这个ACK报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到CLOSED状态。<br>2.防止已失效的连接请求报文段出现在本连接中。<br>A在发送完最后一个ACK报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</p><h4 id="如果-1、2、3-次握手分别丢包了，会发生什么？"><a href="#如果-1、2、3-次握手分别丢包了，会发生什么？" class="headerlink" title="如果 1、2、3 次握手分别丢包了，会发生什么？"></a>如果 1、2、3 次握手分别丢包了，会发生什么？</h4><p>第一次客户端发的 SYN 丢了：<br>客户端迟迟接不到响应，超时重传。</p><p>第二次服务端发的 SYN 和 ACK 丢了<br>客户端迟迟接不到响应，超时重传</p><p>第三次客户端发的 ACK 丢了？<br>因为第三次发完 ACK 之后，随时接下来会继续往服务端发数据，我看过一篇博客里写的是发数据时会带上 ACK，所以客户端响应的 ACK 包丢了，服务器也能够通过之后的包来建立连接。</p><p>第三次故意不发送 ACK 呢？<br>洪水攻击，服务器在等待第三次握手时是处于半连接状态，也是需要耗费资源的，如果有攻击者故意不发送第三次 ACK，让大量连接处于半连接状态，那么会把服务器资源耗尽，洪水攻击的目的就达到了。</p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/e333c3fbb3934e04b4a34ab03d80c743.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5saW5LQw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>因为不同的网络应用之间需要有一个确定的通信规则</p><p><img src="https://img-blog.csdnimg.cn/20200702215803534.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="两种常用的网络应用模型"><a href="#两种常用的网络应用模型" class="headerlink" title="两种常用的网络应用模型"></a>两种常用的网络应用模型</h4><h5 id="客户-x2F-服务器模型（Client-x2F-Server）"><a href="#客户-x2F-服务器模型（Client-x2F-Server）" class="headerlink" title="客户&#x2F;服务器模型（Client&#x2F;Server）"></a>客户&#x2F;服务器模型（Client&#x2F;Server）</h5><p><img src="https://img-blog.csdnimg.cn/20200702220439646.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="P2P模型（Peer-to-Peer）"><a href="#P2P模型（Peer-to-Peer）" class="headerlink" title="P2P模型（Peer-to-Peer）"></a>P2P模型（Peer-to-Peer）</h5><p>网络健壮性指的是P2P模型不容易坏掉，即使一个节点坏了也没问题，可以有其他节点代替</p><p><img src="https://img-blog.csdnimg.cn/20200702220544850.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="域名系统协议（DNS）"><a href="#域名系统协议（DNS）" class="headerlink" title="域名系统协议（DNS）"></a>域名系统协议（DNS）</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>DNS就是将打在地址栏的域名转化为IP地址的东西</p><p><img src="https://img-blog.csdnimg.cn/20200702220920296.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><p>域名就是<a href="http://www.xxx.com,当然这是最简单的一种/">www.xxx.com，当然这是最简单的一种</a><br>.com之后还可以有东西，称之为根<br>域名从左向右，级别逐渐增高</p><p><img src="https://img-blog.csdnimg.cn/20200702221601437.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200702221626114.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="域名服务器（DNS服务器）"><a href="#域名服务器（DNS服务器）" class="headerlink" title="域名服务器（DNS服务器）"></a>域名服务器（DNS服务器）</h4><p>DNS服务器有很多台，根据层次结构分为三层，根域名服务器，顶级域名服务器，权限域名服务器<br>本地域名服务器不算层次结构，特点是里主机比较近，当主机和另一台比较近的主机通信时，就不用走那些更高级的服务器了<br>根域名服务器并不是一个域名只有一台，而是一个域名对应多台域名服务器，全世界一共有13个这样的域名，分别是a.rootservers.net，b.rootservers.net，c.rootservers.net，~m.rootservers.net<br>在权限域名服务器中，虽然看似abc.com比y.abc.com少了一位，但是他们的<strong>地位仍是对等的</strong>，对应的两台权限域名服务器</p><p><img src="https://img-blog.csdnimg.cn/20200702222254726.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p><img src="https://img-blog.csdnimg.cn/20200702223128655.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200702223220720.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h5><p>在上图中<br>主机先是想本地域名服务器发送请求，如果查不到的话，<br>本地域名服务器向根域名服务器发送请求（找别人），如果还是查不到的话，<br>根域名域名服务器向顶级域名服务器发送请求（找别人），如果还是查不到的话，<br>顶级域名服务器向权限域名服务器发送请求（找别人）<br>可以看到每一次向下一个查询的服务器都变了，不是主机一个个去问，而是服务器自己一个个问下去</p><h5 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h5><p>在上图中<br>主机先是想本地域名服务器发送请求，如果查不到的话，<br>本地域名服务器就让主机去向根域名服务器发送请求（主机去找，本地域名给目标根域名服务器的IP地址），如果还是查不到的话，<br>根域名域名服务器让主机去向对应的顶级域名服务器发送请求（主机去找，根域名给目标顶级域名服务器的IP地址），如果还是查不到的话，<br>顶级域名服务器让主机去向权限域名服务器发送请求（主机去找，顶级域名给目标权限域名服务器的IP地址）<br>可以看到这里是主机一个个挨个问的地址</p><h5 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h5><p>为了减少多次查询同一个域名的资源浪费，本地域名服务器会存储最近使用的ip地址解析，下次再访问同一个域名就不需要这么多查询步骤了。同时这个高速缓存主机本身也有存储<br>同时本地域名服务器还可以对顶级域名服务器，权限域名服务器的地址进行缓存，下一次即使是不知道的ip地址，查询也可以更快<br>高速缓存为了保持正确性，需要定时更新</p><h3 id="文件传输协议（FTP，TFTP）"><a href="#文件传输协议（FTP，TFTP）" class="headerlink" title="文件传输协议（FTP，TFTP）"></a>文件传输协议（FTP，TFTP）</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>TFTP是一个轻量的，比较容易实现的，面对小文件的，UDP的文件传输协议<br>这里我们重点是FTP协议</p><p><img src="https://img-blog.csdnimg.cn/20200702224616787.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="FTP的服务端和客户端"><a href="#FTP的服务端和客户端" class="headerlink" title="FTP的服务端和客户端"></a>FTP的服务端和客户端</h4><p><img src="https://img-blog.csdnimg.cn/20200702224816512.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="FTP的工作原理"><a href="#FTP的工作原理" class="headerlink" title="FTP的工作原理"></a>FTP的工作原理</h4><p>为什么有匿名登陆：对于一些公共服务器来说，增加验证阶段就是增加资源开销，减少验证阶段就可以节省资源来更好地服务<br>主进程和从属进程的区别：主进程是打开端口，让外部发送的数据可以进来，并且将这些数据逐个分配各从属进程。从属进程则是单独为这些数据服务</p><p><img src="https://img-blog.csdnimg.cn/20200702225039138.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>先注释一下这里的主进程被忽略掉了，只是没标在上面，不是没有啊<br>这里客户端和服务器端先建立TCP连接，端口是21，称为控制连接<br>然后看情况是主动建立连接还是被动建立连接<br>主动建立连接是指服务器端主动发送请求和客户端进行连接，此时端口号固定是20<br>被动连接是指客户端发送请求和服务器端建立数据传送连接，此时端口号是不确定，有两者协商得到<br>数据传输完成之后，数据连接断开，控制连接继续保持，直至两边发送断开请求</p><p><img src="https://img-blog.csdnimg.cn/20200703000401174.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>FTP的两种传输模式</p><p><img src="https://img-blog.csdnimg.cn/20200703000905460.png" alt="在这里插入图片描述"></p><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><h5 id="电子邮件的格式"><a href="#电子邮件的格式" class="headerlink" title="电子邮件的格式"></a>电子邮件的格式</h5><p><img src="https://img-blog.csdnimg.cn/20200703001117831.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h5><p><strong>用户代理的四个功能解释</strong>： </p><p>撰写就是给用户编辑信件的环境 </p><p>显示就是可以看到自己写的和自己收的信件内容 </p><p>处理就是对信件进行操作，包括删除，打印，转发等等 </p><p>通信就是可以将邮件发送到邮件服务器当中，同时可以从邮件服务器当中读取邮件</p><p><strong>邮件服务器的功能注释</strong>:<br>邮件服务器端的发送和接受是指从自己的用户代理处接收邮件，之后向对面的邮件服务器发送邮件<br>邮件服务器的报告邮件发送结果就是投递是否成功这种情况<br>邮件服务器既可以作为客户端又可以作为服务器端，使用的是C&#x2F;S方式</p><p><strong>协议的功能注释</strong>:<br>发邮件用的是SMTP<br>收邮件的是POP3或者IMAP</p><p><img src="https://img-blog.csdnimg.cn/20200703001436566.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200703002119799.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="几个邮件协议"><a href="#几个邮件协议" class="headerlink" title="几个邮件协议"></a>几个邮件协议</h4><h5 id="简单邮件传送协议SMTP"><a href="#简单邮件传送协议SMTP" class="headerlink" title="简单邮件传送协议SMTP"></a>简单邮件传送协议SMTP</h5><p>注意一下，这里STMP客户和服务器不是固定死的，用户可以成为服务器，服务器也可以成为用户，由发送方和接收方决定，发送方就是客户，接收方就是服务器</p><p><img src="https://img-blog.csdnimg.cn/20200703002319315.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">220</span> service ready</span><br><span class="line"><span class="number">250</span> OK</span><br><span class="line"><span class="number">421</span> service not available</span><br><span class="line"><span class="number">550</span> xxx</span><br><span class="line"><span class="number">354</span> xxx</span><br></pre></td></tr></table></figure><p>都是应答信息</p><p>这里RCPT能有多条命令的原因是，电子邮件可以有多个收件人，就是群发，所以允许多个RCPT</p><p><strong>再强调一下，这里服务器和客户端可以互换，视具体情况而定，发送方是客户端，接收方是服务器端</strong></p><p><img src="https://img-blog.csdnimg.cn/20200703002844133.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="改进SMTP缺点的MIME协议"><a href="#改进SMTP缺点的MIME协议" class="headerlink" title="改进SMTP缺点的MIME协议"></a>改进SMTP缺点的MIME协议</h5><p>MIME改善SMTP发送数据的缺点，是SMTP的功能性扩展<br>MIME协议已经逐渐开始应用到浏览器当中，通过对不同文件类型用不同的标识符标识，来让浏览器读取通过MIME的相关文件</p><p><img src="https://img-blog.csdnimg.cn/20200703003639358.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="邮局协议POP3"><a href="#邮局协议POP3" class="headerlink" title="邮局协议POP3"></a>邮局协议POP3</h5><p>这里接收方是客户端，邮件服务器是服务器端<br>POP3确实很简单，但是有不少缺点，比较难受的就是邮件一旦下载就自动删除了</p><p><img src="https://img-blog.csdnimg.cn/20200703003942969.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="比较复杂的读取邮件的协议——IMAP协议"><a href="#比较复杂的读取邮件的协议——IMAP协议" class="headerlink" title="比较复杂的读取邮件的协议——IMAP协议"></a>比较复杂的读取邮件的协议——IMAP协议</h5><p><img src="https://img-blog.csdnimg.cn/20200703004334235.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h4><p>与之前的不同的地方就是，基于万维网的电子邮件的邮件服务器端可以不同</p><p>同时，发送邮件使用的SMTP&#x2F;MIME和收邮件时的POP3&#x2F;IMAP协议都换成了HTTP协议</p><p><img src="https://img-blog.csdnimg.cn/2020070300482031.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="万维网和HTTP协议"><a href="#万维网和HTTP协议" class="headerlink" title="万维网和HTTP协议"></a>万维网和HTTP协议</h3><h4 id="万维网概述"><a href="#万维网概述" class="headerlink" title="万维网概述"></a>万维网概述</h4><p>URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置</p><p>HTTP用来将这些资源传送给用户</p><p>HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示</p><p><img src="https://img-blog.csdnimg.cn/20200703005114701.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="HTTP协议的过程"><a href="#HTTP协议的过程" class="headerlink" title="HTTP协议的过程"></a>HTTP协议的过程</h5><p>这张图里讲了HTTP的具体过程</p><p>服务器通过TCP 80端口来监听HTTP请求</p><p>注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分，其他音频视频等待用户下一步请求之后再传输</p><p><img src="https://img-blog.csdnimg.cn/20200703005650472.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="HTTP协议的特点"><a href="#HTTP协议的特点" class="headerlink" title="HTTP协议的特点"></a>HTTP协议的特点</h5><p><img src="https://img-blog.csdnimg.cn/20200703010043691.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="HTTP的连接方式——持久连接和非持久连接"><a href="#HTTP的连接方式——持久连接和非持久连接" class="headerlink" title="HTTP的连接方式——持久连接和非持久连接"></a>HTTP的连接方式——持久连接和非持久连接</h5><p>非持久连接在TCP三次握手的第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。<br>缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始</p><p>持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了</p><p><img src="https://img-blog.csdnimg.cn/2020070301065437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>持久连接的两种方式——非流水线和流水线<br>非流水线就是发一个，确认一个，才能再发下一个<br>流水线就是一个个连着发，然后多个确认<br>和之前说过的停止等待协议，后退N帧协议和选择重传协议很像，忘了的话可以去复习一下</p><h5 id="HTTP的报文结构"><a href="#HTTP的报文结构" class="headerlink" title="HTTP的报文结构"></a>HTTP的报文结构</h5><p>开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样</p><p>请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取&#x2F;删除等等<br>URL就是之间说的资源标识符<br>版本是指使用的是什么版本的HTTP协议</p><p>CRLF相当于我们程序里面的<code>；</code>，标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF</p><p><img src="https://img-blog.csdnimg.cn/20200703011608294.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里举了请求报文的例子，和一些常用的状态码</p><p><img src="https://img-blog.csdnimg.cn/20200703012144697.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/b185d96114d14b88a104b2efe8bccd87.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5saW5LQw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/posts/1079.html"/>
      <url>/posts/1079.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="中断-amp-异常"><a href="#中断-amp-异常" class="headerlink" title="中断 &amp; 异常"></a>中断 &amp; 异常</h2><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p><img src="/img/2022-10-29-12-54-51-96A8A7FA93179F0CA22DC221AF6605D8.jpg"></p><h4 id="中断的概念与与作用"><a href="#中断的概念与与作用" class="headerlink" title="中断的概念与与作用"></a>中断的概念与与作用</h4><p><img src="/img/2022-10-29-12-56-34-3DE5597A07EE2A98ECC1365B562FC472.jpg"></p><h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h4><p><img src="/img/2022-10-29-12-57-15-D84DFE5F99542AA2D96BDFE8DAFC5FE1.jpg"></p><p><strong>【中断源—处理器硬件故障中断事件】</strong></p><ul><li><p>由处理器、内存储器、总线等硬件故障引起</p></li><li><p>处理原则为：保护现场，停止设备，停止CPU，向操作员报告，等待人工干预</p></li></ul><p><strong>【中断源—程序性中断事件】</strong></p><ul><li><p>处理器执行机器指令引起</p><ol><li><p>除数为零、操作数溢出等算术异常：简单处理，报告用户；也可以由用户编写中断续元程序处理</p></li><li><p>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程</p></li><li><p>终止进程指令：终止进程</p></li><li><p>虚拟地址异常：调整内存后重新执行指令</p></li></ol></li></ul><p><strong>【中断源—自愿性中断事件】</strong></p><ul><li><p>处理器执行陷入指令请求OS服务引起；在操作系统中，它一般又被称作系统调用</p><ol><li><p>请求分配外设、请求I&#x2F;O、等等</p></li><li><p>处理流程是：陷入OS，保护现场，根据功能号查入口地址，跳转具体处理程序</p></li></ol></li></ul><p><strong>【中断源—I&#x2F;O中断事件】</strong></p><ul><li><p>来源于外围设备报告I&#x2F;O状态的中断事件</p><ol><li><p>I&#x2F;O完成：调整进程状态，释放等待进程</p></li><li><p>I&#x2F;O出错：等到人工干预</p></li><li><p>I&#x2F;O异常：等待人工干预</p></li></ol></li></ul><p><strong>【中断源—外部中断事件】</strong></p><ul><li><p>由外围设备发出的信号引起的中断事件</p><ol><li><p>时钟中断、间隔时钟中断：<strong>记时</strong>与<strong>时间片</strong>处理</p></li><li><p>设备报到与结束中断：调整设备表</p></li><li><p>键盘&#x2F;鼠标信号中断：根据信号做出相应反映</p></li><li><p>关机&#x2F;重启动中断：写回文件，停止设备与CPU</p></li></ol></li></ul><h4 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a>外中断的处理过程</h4><p><img src="/img/2022-10-29-12-57-45-0AD616DA7824000F7ABDD62AA74DCF80.jpg"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/2022-10-29-12-55-54-6E90E335F082D2FDC1B431F4FBB42C22.jpg"></p><h2 id="基本分段储存管理"><a href="#基本分段储存管理" class="headerlink" title="基本分段储存管理"></a>基本分段储存管理</h2><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p><img src="/img/2022-10-27-22-45-05-42628A8C3557D367CE69F0C6AE46D21C.jpg"></p><p><img src="/img/2022-10-27-22-48-06-1C4B0A70A36F53663D34428A8DC37CAC.jpg"></p><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p><img src="/img/2022-10-27-22-48-11-3DD7ECA695C4266B66472E3DA43D5D9B.jpg"></p><h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><p><img src="/img/2022-10-27-22-53-58-EDA89B5CECBF60DF9921B54DAF2CEB21.jpg"></p><h4 id="分段-VS-分页"><a href="#分段-VS-分页" class="headerlink" title="分段 VS 分页"></a>分段 VS 分页</h4><p><img src="/img/2022-10-27-22-56-03-D1E46B42565CF7F4F272796745647185.jpg"></p><p><img src="/img/2022-10-27-22-56-15-0BE6B67D971461400586C82582C2B981.jpg"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/2022-10-27-22-45-57-0E78C1167E70424AFCD04CC960C462D9.jpg"></p><h2 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h2><h4 id="分段-分页"><a href="#分段-分页" class="headerlink" title="分段+分页"></a>分段+分页</h4><p><img src="/img/2022-10-27-23-12-07-0142AD542B2D2A74F6332EC8EBE0454B.jpg"></p><h4 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h4><p><img src="/img/2022-10-27-23-09-56-9AB7546D264633BC94F1244BF7830693.jpg"></p><h4 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h4><p><img src="/img/2022-10-27-23-13-57-49D2D13FB466D1D301A3DDAC0D30BBE9.jpg"></p><p>图中页表存放块号为页表始址.</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/2022-10-27-21-42-37-C83B8AE34C179A14B440ECF9723818E2.png"></p><h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><h4 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h4><p> 100多G的大表哥是怎么运行在4G内存的电脑上的呢?虚拟内存技术.</p><p><img src="/img/2022-10-27-21-38-49-27A5430195B5A8DBCDA3317F490A33D9.png"></p><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p><img src="/img/2022-10-27-21-49-46-B8599FAD03B0828445E9EC886791EBAA.png"></p><h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>需要访问页号为0的页面,此时该页面不在内存中</p><p><img src="/img/2022-10-27-22-03-10-1E26D825E1DA897B874D2E67498D0392.png"></p><p>①若此时内存中<strong>有空闲内存块</strong>,将页面放入内存的a号块,同时<strong>页表</strong>中的<strong>内存块号</strong>更改为a,<strong>状态位</strong>为1</p><p><img src="/img/2022-10-27-22-03-44-1EFBC8F69EADBD74FC6608C2E6E4F752.png"></p><p>②若此时内存中<strong>无空闲内存块</strong>,在内存中选择页号为2的页面<strong>淘汰后执行①</strong>.若页号为2的页面在内存期间<strong>被修改过</strong>,则要将其<strong>写回外存</strong>,未修改过则不用.</p><p><img src="/img/2022-10-27-22-09-32-8E4CF3EE91DAE5372E779BA4A8B172E6.png"></p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="/img/2022-10-27-23-14-25-306DBEA717AF759C1A15A92776F3D0A9.jpg"></p><p><img src="/img/2022-10-27-22-27-57-A4A1246FEEAE03811A4161B6E61918AE.png"></p><p><img src="/img/2022-10-27-23-17-26-0143FDF23D84F59E234F810168AB700C.jpg"></p><p><img src="/img/2022-10-27-23-17-36-D9F1BB8E741C5FF20AD36369415F0E3F.jpg"></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><img src="file:///C:/Users/篮网总冠军/AppData/Roaming/marktext/images/2022-10-27-21-45-53-A89C2F787177A725D39221086D64D4C4.png" title="" alt="" width="701"><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h4 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h4><p><img src="/img/2022-10-28-14-19-14-BA998AE79F113BC49CF75679F5AF3C92.jpg"></p><h4 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h4><p>需要将页面2放入内存块中, 因为该进程的内存块已满, 需要从已存在于内存块中的页面[0,1,7]中选择<strong>以后永不使用</strong>或<strong>最长时间内不再被访问</strong>的页面换出内存块.</p><p>因为页面7是最长时间内不再被访问的页面, 因此将页面7从内存块1中换出.</p><p><img src="/img/2022-10-28-14-21-21-912A26A5F62398CF59BE94695C761685.jpg"></p><p>此时需要访问页面3, 将最长时间内不再被访问的页面1从内存块3中换出</p><p><img src="/img/2022-10-28-14-22-28-E93D1BB4D8D20E6685BFD837F81C274A.jpg"></p><p><img src="/img/2022-10-28-14-30-52-25A9F6FB5A7A5B0EBF46CC1643CB3FE5.jpg"></p><h4 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h4><p>页面[3,2,1]需要依次访问内存块, 此时有空闲内存块, 队列为[3,2,1]</p><p><img src="/img/2022-10-28-14-51-58-A213A86FC51122437AEBC2C7986CC536.jpg"></p><p>此时需要访问页面0, 从队列中换出最先进入的页面3, <strong>队列更新</strong>为[2,1,0]</p><p><img src="/img/2022-10-28-14-52-11-F56BC12796B8FD08CF1C98CE29DC27E2.jpg"></p><p>此时需要访问页面3, 从队列中换出最先进入内存的页面2, 队列更新为[1,0,3]</p><p><img src="/img/2022-10-28-14-56-41-B1C4CC42C2033D9A17834193CD3B0D23.jpg"></p><h4 id="最近最久未使用置换算法-LRU"><a href="#最近最久未使用置换算法-LRU" class="headerlink" title="最近最久未使用置换算法(LRU)"></a>最近最久未使用置换算法(LRU)</h4><p>页面[1,8,7,2]依次需要被访问, 此时有空闲内存块.</p><p>需要访问页面3, 无空闲内存块, 页面7<strong>最近最久未使用</strong>, 因此被换出内存块3</p><p><img src="/img/2022-10-28-15-03-36-D1B2F5EDC6150488CEC0CCF50436EAD1.jpg"></p><p>需要访问页面7, 从已在内存中的页面[1,8,3,2]中将最近最久未被使用的页面8换出内存块2</p><p><img src="/img/2022-10-28-15-06-49-21013C743DAC953B7A5111C12ABF080A.jpg"></p><h4 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法(CLOCK)"></a>时钟置换算法(CLOCK)</h4><p>已在内存中的页面[1,3,4,2,5], 访问位均为0,</p><p>循环队列为: <em>1(0) -&gt; 3(0) -&gt; 4(0) -&gt; 2(0) -&gt; 5(0) -&gt; 1(0)</em>  ,    <strong>1(0)表示一号页访问位为0</strong></p><p><img src="/img/2022-10-28-15-08-40-B989E50A0F97C26CC6CDDEA47FC04188.jpg"></p><p>需要访问页面6, 因为<em>1(0)</em>, 将1号页从内存中换出</p><p>循环队列更新为: <em>6(1) -&gt; 3(0) -&gt; 4(0) -&gt; 2(0) -&gt; 5(0) -&gt; 6(1)</em></p><p><img src="/img/2022-10-28-15-09-21-F5B3F3E7EF418F2CF703EF546700E8F2.jpg"></p><p>接下来需要访问页面[3,4], 因为页面[3,4]均已在内存中, 将访问位更新为1</p><p>循环队列更新为: <em>6(1) -&gt; 3(1) -&gt; 4(1) -&gt; 2(0) -&gt; 5(0) -&gt; 6(1)</em></p><p><img src="/img/2022-10-28-15-25-24-03D5F3DFC5E1C893370745C985731842.jpg"></p><p>接下来需要访问页面7, 将页面[3,4]的访问位更新为3, 因为<em>2(0)</em>, 所以将页面2换出</p><p>循环队列更新为: <em>6(1) -&gt; 3(1) -&gt; 4(1) -&gt; 7(1) -&gt; 5(0) -&gt; 6(1)</em></p><p><img src="/img/2022-10-28-15-25-54-AE17F8110A818E357DF7AB73D787B29F.jpg"></p><p><img src="/img/2022-10-28-15-30-39-DA75365DB38DF0268298E7889E85AE05.jpg"></p><h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h4><p><img src="/img/2022-10-28-15-32-33-F17F813FDABADBDA130217C843372DE6.jpg"></p><h6 id="只需要扫描1轮的情况"><a href="#只需要扫描1轮的情况" class="headerlink" title="只需要扫描1轮的情况"></a>只需要扫描1轮的情况</h6><p><img src="/img/2022-10-28-15-33-27-358827C0581D49AE0D44CA4D4A0B7A86.jpg"></p><p><img src="/img/2022-10-28-15-35-00-12E4A17F1BB702CB221CE26886E9A821.jpg"></p><h6 id="需要扫描2轮的情况"><a href="#需要扫描2轮的情况" class="headerlink" title="需要扫描2轮的情况"></a>需要扫描2轮的情况</h6><p><strong>第一轮</strong>没有找到 <em>(0,0)</em></p><p><img src="/img/2022-10-28-15-35-48-19F4AD2DAD18BA2E6E946FBF70E24E07.jpg"></p><p><strong>第二轮</strong>, 将 <em>(0,0)</em> 更新为 <em>(0,1)</em>, 找到第一个更新前是 <em>(0,1)</em> 的帧</p><p><img src="/img/2022-10-28-15-36-24-0D7016EA4BC3730DF51B79016FC156B6.jpg"></p><h6 id="需要扫描3轮的情况"><a href="#需要扫描3轮的情况" class="headerlink" title="需要扫描3轮的情况"></a>需要扫描3轮的情况</h6><p><strong>第一轮</strong>没有找到 <em>(0,0)</em></p><p><img src="/img/2022-10-28-15-37-15-A5918FA693EA1B7DADA08E3F5E52457F.jpg"></p><p><strong>第二轮</strong>将所有扫描过的帧的访问位更新为0, 没有找到更新前是 <em>(0,1)</em> 的帧</p><p><img src="/img/2022-10-28-15-37-22-00963084E556765DC097118EC39345E5.jpg"></p><p><strong>第三轮</strong>找到第一个 <em>(0,0)</em> 帧</p><p><img src="/img/2022-10-28-15-37-28-6EBE4E71CB7A8F1F12CC813883CD2102.jpg"></p><h6 id="需要4轮的情况"><a href="#需要4轮的情况" class="headerlink" title="需要4轮的情况"></a>需要4轮的情况</h6><p><strong>第一轮</strong></p><p><img src="/img/2022-10-28-15-45-58-7EB9B47FF4CF554762F6204167A993C9.jpg"></p><p><strong>第二轮</strong></p><p><img src="/img/2022-10-28-15-46-06-7AF9C263F511640EA5ACF8D1B1B0F6EF.jpg"></p><p><strong>第三轮</strong></p><p><img src="/img/2022-10-28-15-46-15-50A3A7740D71BDC67C1B1E7396F100C1.jpg"></p><p><strong>第四轮</strong></p><p><img src="/img/2022-10-28-15-46-27-165FED08B19B3AA4FC4BC6BBE7DC81D1.jpg"></p><p><img src="/img/2022-10-28-15-46-34-F8F05B4628EE9A3C4ECE43F911FB36F2.jpg"></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/2022-10-28-16-06-22-2586324E4CA6785F5C519D58BAA01501.jpg"></p><h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><h4 id="总览-2"><a href="#总览-2" class="headerlink" title="总览"></a>总览</h4><p><img src="/img/2022-10-28-16-09-32-32B8A3016C0DA3725F1A0892B636281C.jpg"></p><h4 id="页面分配-amp-置换策略"><a href="#页面分配-amp-置换策略" class="headerlink" title="页面分配 &amp; 置换策略"></a>页面分配 &amp; 置换策略</h4><p><img src="/img/2022-10-28-16-10-02-E53362650FC2DC6EF8E690691FAF7DBC.jpg"></p><p><img src="/img/2022-10-28-16-12-11-BCBB657C256B8AC0BC09933631863531.jpg"></p><h4 id="调入页面时机"><a href="#调入页面时机" class="headerlink" title="调入页面时机"></a>调入页面时机</h4><p><img src="/img/2022-10-28-16-13-01-AD89833AC48A3EFDE30F2E84261E48F8.jpg"></p><h4 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h4><p><img src="/img/2022-10-28-16-12-51-C51660A7DA259A37A40939A8AB84C5C6.jpg"></p><p><img src="/img/2022-10-28-16-13-12-D19038C63035A7D551C74FD9D89FA403.jpg"></p><p><img src="/img/2022-10-28-16-14-18-B0EE37777178CAD2B19924918BD765EB.jpg"></p><h4 id="抖动颠簸现象"><a href="#抖动颠簸现象" class="headerlink" title="抖动颠簸现象"></a>抖动颠簸现象</h4><p><img src="/img/2022-10-28-16-16-29-DC26DA85702F741CBDCB08742C9D20ED.jpg"></p><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p><img src="/img/2022-10-28-16-16-44-D75E080E4A68E89EBA70CA0A95890E93.jpg"></p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/2022-10-28-16-17-14-049D0007C82A8226E0A561CABE98D3A9.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据结构</title>
      <link href="/posts/60592.html"/>
      <url>/posts/60592.html</url>
      
        <content type="html"><![CDATA[<h1 id="java数据结构"><a href="#java数据结构" class="headerlink" title="java数据结构"></a>java数据结构</h1><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><h4 id="将一个二维数组chess-转换成稀疏数组sparseArray-3"><a href="#将一个二维数组chess-转换成稀疏数组sparseArray-3" class="headerlink" title="将一个二维数组chess[][] 转换成稀疏数组sparseArray[][3]:"></a>将一个二维数组chess[][] 转换成稀疏数组sparseArray[][3]:</h4><ol><li><p>sparseArray[0][0]和sparseArray[0][1]分别存放chess的<strong>行数</strong>和<strong>列数</strong>, sparseArray[0][2]存放<strong>有效值的个数</strong>.</p></li><li><p>sparseArray[m][0]和sparseArray[m][1] 表示有效值的<strong>行数</strong>和<strong>列数</strong>,sparseArray[m][2]存放<strong>有效值的值</strong></p></li></ol><p>   如图:</p><p>     原始数组chess[][]:                                                    稀疏数组sparseArray[][3]:</p><p>   <img src="/img/2022-10-21-23-29-16-image.png">                                                            <img title="" src="/img/2022-10-21-23-29-58-image.png" alt="" data-align="inline"></p><h4 id="普通数组转稀疏数组代码实现"><a href="#普通数组转稀疏数组代码实现" class="headerlink" title="普通数组转稀疏数组代码实现:"></a>普通数组转稀疏数组代码实现:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通数组转换成稀疏数组, invalid表示无效值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] sparse(<span class="type">int</span>[][] array, <span class="type">int</span> invalid) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> traverse(array, invalid);<span class="comment">//遍历原始数组的同时计算出有效值个数sum</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] sparseArray = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    sparseArray[<span class="number">0</span>][<span class="number">0</span>] = array.length;</span><br><span class="line"></span><br><span class="line">    sparseArray[<span class="number">0</span>][<span class="number">1</span>] = array[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    sparseArray[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心步骤</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(array[i][j] != invalid) &#123;</span><br><span class="line"></span><br><span class="line">                sparseArray[count][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">                sparseArray[count][<span class="number">1</span>] = j;</span><br><span class="line"></span><br><span class="line">                sparseArray[count][<span class="number">2</span>] = array[i][j];</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sparseArray;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="稀疏数组转普通数组代码实现"><a href="#稀疏数组转普通数组代码实现" class="headerlink" title="稀疏数组转普通数组代码实现:"></a>稀疏数组转普通数组代码实现:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//稀疏数组转普通数组, invalid表示无效值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] chess(<span class="type">int</span>[][] array, <span class="type">int</span> invalid) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] chessArray = <span class="keyword">new</span> <span class="title class_">int</span>[array[<span class="number">0</span>][<span class="number">0</span>]][array[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断无效值是否为0, 若为零则不需要赋初值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用array[0][]代替.length(), 提高代码运行速度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(invalid != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array[<span class="number">0</span>][<span class="number">0</span>]; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[<span class="number">0</span>][<span class="number">1</span>]; j++) &#123;</span><br><span class="line"></span><br><span class="line">                chessArray[i][j] = invalid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心步骤</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用array[0][2]代替.length(), 提高代码运行速度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= array[<span class="number">0</span>][<span class="number">2</span>]; i++) &#123;</span><br><span class="line"></span><br><span class="line">        chessArray[array[i][<span class="number">0</span>]][array[i][<span class="number">1</span>]] = array[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chessArray;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种特殊的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fromModule=lemma_inlink">线性表</a>，特殊之处在于它只允许在表的<strong>前端（front）进行删除操作</strong>，而在表的<strong>后端（rear）进行插入操作</strong>,<em>先进先出</em>.</p><img title="" src="http://data.biancheng.net/uploads/allimg/170719/2-1FG91032244Y.png" alt="" data-align="center"><p>称进入队列的一端为“队尾”；出队列的一端为“队头”。数据元素全部由队尾陆续进队列，由队头陆续出队列。</p><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><h4 id="用数组实现顺序队列-用数组索引代替c-中的指针"><a href="#用数组实现顺序队列-用数组索引代替c-中的指针" class="headerlink" title="用数组实现顺序队列(用数组索引代替c++中的指针):"></a>用数组实现顺序队列(用数组索引代替c++中的指针):</h4><blockquote><p><strong>初始化队</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;  <span class="comment">//队列的最大长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;     <span class="comment">//队尾索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;    <span class="comment">//队首索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;  <span class="comment">//队数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造函数初始化队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueArray</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.rear = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.front = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>判断队列是否为空</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> front == rear;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>判断是否队列已满</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否以满</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>入队</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;队列已满,入队失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rear++; <span class="comment">//队尾索引后移</span></span><br><span class="line"></span><br><span class="line">    array[rear] = data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>出队</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leave</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空,出队失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        front++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array[front];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>遍历队</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front+<span class="number">1</span>; i &lt;= rear; i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>主函数对代码进行测试</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">QueueArray</span> <span class="variable">queueArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueueArray</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loop) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;入队:in, 出队:out, 判空:empty, 判满:full, 查看:check, 退出:exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (next) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;in&quot;</span> :</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;请输入数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">                queueArray.enter(scanner.nextInt());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;out&quot;</span> :</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;出队数据为: &quot;</span> + queueArray.leave());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;empty&quot;</span> :</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(queueArray.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                     System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;队列非空&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;full&quot;</span> :</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(queueArray.isFull()) &#123;</span><br><span class="line"></span><br><span class="line">                      System.out.println(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;队列未满&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;check&quot;</span> :</span><br><span class="line"></span><br><span class="line">                queueArray.traverse();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span> :</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;已退出&quot;</span>);</span><br><span class="line"></span><br><span class="line">                loop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   scanner.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}:root {  --trans-light: rgba(255, 255, 255, 0.88);  --trans-dark: rgba(25, 25, 25, 0.88);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}/* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  -webkit-animation: ccc 4s linear infinite;  animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}@keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #ef50a8;  margin-left: -1.55rem;  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #fb7061;  margin-left: -1.35rem;  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #ffbf00;  margin-left: -1.22rem;  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #a9e000;  margin-left: -1.05rem;  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #57c850;  margin-left: -0.9rem;  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #5ec1e0;  margin-left: -0.9rem;  font-size: 0.66rem;  margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {  color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  color: var(--theme-color);  -webkit-animation: ccc 6s linear infinite;  animation: ccc 6s linear infinite;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/js2.js"/>
      <url>/js/js2.js</url>
      
        <content type="html"><![CDATA[/*! * Zdog v1.1.1 * Round, flat, designer-friendly pseudo-3D engine * Licensed MIT * https://zzz.dog * Copyright 2019 Metafizzy *//** * Boilerplate & utils */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory();  } else {    // browser global    root.Zdog = factory();  }}( this, function factory() {var Zdog = {};Zdog.TAU = Math.PI * 2;Zdog.extend = function( a, b ) {  for ( var prop in b ) {    a[ prop ] = b[ prop ];  }  return a;};Zdog.lerp = function( a, b, alpha ) {  return ( b - a ) * alpha + a;};Zdog.modulo = function( num, div ) {  return ( ( num % div ) + div ) % div;};var powerMultipliers = {  2: function( a ) {    return a * a;  },  3: function( a ) {    return a * a * a;  },  4: function( a ) {    return a * a * a * a;  },  5: function( a ) {    return a * a * a * a * a;  },};Zdog.easeInOut = function( alpha, power ) {  if ( power == 1 ) {    return alpha;  }  alpha = Math.max( 0, Math.min( 1, alpha ) );  var isFirstHalf = alpha < 0.5;  var slope = isFirstHalf ? alpha : 1 - alpha;  slope /= 0.5;  // make easing steeper with more multiples  var powerMultiplier = powerMultipliers[ power ] || powerMultipliers[2];  var curve = powerMultiplier( slope );  curve /= 2;  return isFirstHalf ? curve : 1 - curve;};return Zdog;}));/** * CanvasRenderer */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory();  } else {    // browser global    root.Zdog.CanvasRenderer = factory();  }}( this, function factory() {var CanvasRenderer = { isCanvas: true };CanvasRenderer.begin = function( ctx ) {  ctx.beginPath();};CanvasRenderer.move = function( ctx, elem, point ) {  ctx.moveTo( point.x, point.y );};CanvasRenderer.line = function( ctx, elem, point ) {  ctx.lineTo( point.x, point.y );};CanvasRenderer.bezier = function( ctx, elem, cp0, cp1, end ) {  ctx.bezierCurveTo( cp0.x, cp0.y, cp1.x, cp1.y, end.x, end.y );};CanvasRenderer.closePath = function( ctx ) {  ctx.closePath();};CanvasRenderer.setPath = function() {};CanvasRenderer.renderPath = function( ctx, elem, pathCommands, isClosed ) {  this.begin( ctx, elem );  pathCommands.forEach( function( command ) {    command.render( ctx, elem, CanvasRenderer );  });  if ( isClosed ) {    this.closePath( ctx, elem );  }};CanvasRenderer.stroke = function( ctx, elem, isStroke, color, lineWidth ) {  if ( !isStroke ) {    return;  }  ctx.strokeStyle = color;  ctx.lineWidth = lineWidth;  ctx.stroke();};CanvasRenderer.fill = function( ctx, elem, isFill, color ) {  if ( !isFill ) {    return;  }  ctx.fillStyle = color;  ctx.fill();};CanvasRenderer.end = function() {};return CanvasRenderer;}));/** * SvgRenderer */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory();  } else {    // browser global    root.Zdog.SvgRenderer = factory();  }}( this, function factory() {var SvgRenderer = { isSvg: true };// round path coordinates to 3 decimalsvar round = SvgRenderer.round = function( num ) {  return Math.round( num * 1000 ) / 1000;};function getPointString( point ) {  return round( point.x ) + ',' + round( point.y ) + ' ';}SvgRenderer.begin = function() {};SvgRenderer.move = function( svg, elem, point ) {  return 'M' + getPointString( point );};SvgRenderer.line = function( svg, elem, point ) {  return 'L' + getPointString( point );};SvgRenderer.bezier = function( svg, elem, cp0, cp1, end ) {  return 'C' + getPointString( cp0 ) + getPointString( cp1 ) +    getPointString( end );};SvgRenderer.closePath = function(/* elem */) {  return 'Z';};SvgRenderer.setPath = function( svg, elem, pathValue ) {  elem.setAttribute( 'd', pathValue );};SvgRenderer.renderPath = function( svg, elem, pathCommands, isClosed ) {  var pathValue = '';  pathCommands.forEach( function( command ) {    pathValue += command.render( svg, elem, SvgRenderer );  });  if ( isClosed ) {    pathValue += this.closePath( svg, elem );  }  this.setPath( svg, elem, pathValue );};SvgRenderer.stroke = function( svg, elem, isStroke, color, lineWidth ) {  if ( !isStroke ) {    return;  }  elem.setAttribute( 'stroke', color );  elem.setAttribute( 'stroke-width', lineWidth );};SvgRenderer.fill = function( svg, elem, isFill, color ) {  var fillColor = isFill ? color : 'none';  elem.setAttribute( 'fill', fillColor );};SvgRenderer.end = function( svg, elem ) {  svg.appendChild( elem );};return SvgRenderer;}));/** * Vector */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Vector = factory( Zdog );  }}( this, function factory( utils ) {function Vector( position ) {  this.set( position );}var TAU = utils.TAU;// 'pos' = 'position'Vector.prototype.set = function( pos ) {  this.x = pos && pos.x || 0;  this.y = pos && pos.y || 0;  this.z = pos && pos.z || 0;  return this;};// set coordinates without sanitizing// vec.write({ y: 2 }) only sets y coordVector.prototype.write = function( pos ) {  if ( !pos ) {    return this;  }  this.x = pos.x != undefined ? pos.x : this.x;  this.y = pos.y != undefined ? pos.y : this.y;  this.z = pos.z != undefined ? pos.z : this.z;  return this;};Vector.prototype.rotate = function( rotation ) {  if ( !rotation ) {    return;  }  this.rotateZ( rotation.z );  this.rotateY( rotation.y );  this.rotateX( rotation.x );  return this;};Vector.prototype.rotateZ = function( angle ) {  rotateProperty( this, angle, 'x', 'y' );};Vector.prototype.rotateX = function( angle ) {  rotateProperty( this, angle, 'y', 'z' );};Vector.prototype.rotateY = function( angle ) {  rotateProperty( this, angle, 'x', 'z' );};function rotateProperty( vec, angle, propA, propB ) {  if ( !angle || angle % TAU === 0 ) {    return;  }  var cos = Math.cos( angle );  var sin = Math.sin( angle );  var a = vec[ propA ];  var b = vec[ propB ];  vec[ propA ] = a*cos - b*sin;  vec[ propB ] = b*cos + a*sin;}Vector.prototype.isSame = function( pos ) {  if ( !pos ) {    return false;  }  return this.x === pos.x && this.y === pos.y && this.z === pos.z;};Vector.prototype.add = function( pos ) {  if ( !pos ) {    return this;  }  this.x += pos.x || 0;  this.y += pos.y || 0;  this.z += pos.z || 0;  return this;};Vector.prototype.subtract = function( pos ) {  if ( !pos ) {    return this;  }  this.x -= pos.x || 0;  this.y -= pos.y || 0;  this.z -= pos.z || 0;  return this;};Vector.prototype.multiply = function( pos ) {  if ( pos == undefined ) {    return this;  }  // multiple all values by same number  if ( typeof pos == 'number' ) {    this.x *= pos;    this.y *= pos;    this.z *= pos;  } else {    // multiply object    this.x *= pos.x != undefined ? pos.x : 1;    this.y *= pos.y != undefined ? pos.y : 1;    this.z *= pos.z != undefined ? pos.z : 1;  }  return this;};Vector.prototype.transform = function( translation, rotation, scale ) {  this.multiply( scale );  this.rotate( rotation );  this.add( translation );  return this;};Vector.prototype.lerp = function( pos, alpha ) {  this.x = utils.lerp( this.x, pos.x || 0, alpha );  this.y = utils.lerp( this.y, pos.y || 0, alpha );  this.z = utils.lerp( this.z, pos.z || 0, alpha );  return this;};Vector.prototype.magnitude = function() {  var sum = this.x*this.x + this.y*this.y + this.z*this.z;  return getMagnitudeSqrt( sum );};function getMagnitudeSqrt( sum ) {  // PERF: check if sum ~= 1 and skip sqrt  if ( Math.abs( sum - 1 ) < 0.00000001 ) {    return 1;  }  return Math.sqrt( sum );}Vector.prototype.magnitude2d = function() {  var sum = this.x*this.x + this.y*this.y;  return getMagnitudeSqrt( sum );};Vector.prototype.copy = function() {  return new Vector( this );};return Vector;}));/** * Anchor */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate'), require('./vector'),        require('./canvas-renderer'), require('./svg-renderer') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Anchor = factory( Zdog, Zdog.Vector, Zdog.CanvasRenderer,        Zdog.SvgRenderer );  }}( this, function factory( utils, Vector, CanvasRenderer, SvgRenderer ) {var TAU = utils.TAU;var onePoint = { x: 1, y: 1, z: 1 };function Anchor( options ) {  this.create( options || {} );}Anchor.prototype.create = function( options ) {  this.children = [];  // set defaults & options  utils.extend( this, this.constructor.defaults );  this.setOptions( options );  // transform  this.translate = new Vector( options.translate );  this.rotate = new Vector( options.rotate );  this.scale = new Vector( onePoint ).multiply( this.scale );  // origin  this.origin = new Vector();  this.renderOrigin = new Vector();  if ( this.addTo ) {    this.addTo.addChild( this );  }};Anchor.defaults = {};Anchor.optionKeys = Object.keys( Anchor.defaults ).concat([  'rotate',  'translate',  'scale',  'addTo',]);Anchor.prototype.setOptions = function( options ) {  var optionKeys = this.constructor.optionKeys;  for ( var key in options ) {    if ( optionKeys.indexOf( key ) != -1 ) {      this[ key ] = options[ key ];    }  }};Anchor.prototype.addChild = function( shape ) {  if ( this.children.indexOf( shape ) != -1 ) {    return;  }  shape.remove(); // remove previous parent  shape.addTo = this; // keep parent reference  this.children.push( shape );};Anchor.prototype.removeChild = function( shape ) {  var index = this.children.indexOf( shape );  if ( index != -1 ) {    this.children.splice( index, 1 );  }};Anchor.prototype.remove = function() {  if ( this.addTo ) {    this.addTo.removeChild( this );  }};// ----- update ----- //Anchor.prototype.update = function() {  // update self  this.reset();  // update children  this.children.forEach( function( child ) {    child.update();  });  this.transform( this.translate, this.rotate, this.scale );};Anchor.prototype.reset = function() {  this.renderOrigin.set( this.origin );};Anchor.prototype.transform = function( translation, rotation, scale ) {  this.renderOrigin.transform( translation, rotation, scale );  // transform children  this.children.forEach( function( child ) {    child.transform( translation, rotation, scale );  });};Anchor.prototype.updateGraph = function() {  this.update();  this.updateFlatGraph();  this.flatGraph.forEach( function( item ) {    item.updateSortValue();  });  // z-sort  this.flatGraph.sort( Anchor.shapeSorter );};Anchor.shapeSorter = function( a, b ) {  return a.sortValue - b.sortValue;};// custom getter to check for flatGraph before using itObject.defineProperty( Anchor.prototype, 'flatGraph', {  get: function() {    if ( !this._flatGraph ) {      this.updateFlatGraph();    }    return this._flatGraph;  },  set: function( graph ) {    this._flatGraph = graph;  },});Anchor.prototype.updateFlatGraph = function() {  this.flatGraph = this.getFlatGraph();};// return Array of self & all child graph itemsAnchor.prototype.getFlatGraph = function() {  var flatGraph = [ this ];  return this.addChildFlatGraph( flatGraph );};Anchor.prototype.addChildFlatGraph = function( flatGraph ) {  this.children.forEach( function( child ) {    var childFlatGraph = child.getFlatGraph();    Array.prototype.push.apply( flatGraph, childFlatGraph );  });  return flatGraph;};Anchor.prototype.updateSortValue = function() {  this.sortValue = this.renderOrigin.z;};// ----- render ----- //Anchor.prototype.render = function() {};// TODO refactor out CanvasRenderer so its not a dependency within anchor.jsAnchor.prototype.renderGraphCanvas = function( ctx ) {  if ( !ctx ) {    throw new Error( 'ctx is ' + ctx + '. ' +      'Canvas context required for render. Check .renderGraphCanvas( ctx ).' );  }  this.flatGraph.forEach( function( item ) {    item.render( ctx, CanvasRenderer );  });};Anchor.prototype.renderGraphSvg = function( svg ) {  if ( !svg ) {    throw new Error( 'svg is ' + svg + '. ' +      'SVG required for render. Check .renderGraphSvg( svg ).' );  }  this.flatGraph.forEach( function( item ) {    item.render( svg, SvgRenderer );  });};// ----- misc ----- //Anchor.prototype.copy = function( options ) {  // copy options  var itemOptions = {};  var optionKeys = this.constructor.optionKeys;  optionKeys.forEach( function( key ) {    itemOptions[ key ] = this[ key ];  }, this );  // add set options  utils.extend( itemOptions, options );  var ItemClass = this.constructor;  return new ItemClass( itemOptions );};Anchor.prototype.copyGraph = function( options ) {  var clone = this.copy( options );  this.children.forEach( function( child ) {    child.copyGraph({      addTo: clone,    });  });  return clone;};Anchor.prototype.normalizeRotate = function() {  this.rotate.x = utils.modulo( this.rotate.x, TAU );  this.rotate.y = utils.modulo( this.rotate.y, TAU );  this.rotate.z = utils.modulo( this.rotate.z, TAU );};// ----- subclass ----- //function getSubclass( Super ) {  return function( defaults ) {    // create constructor    function Item( options ) {      this.create( options || {} );    }    Item.prototype = Object.create( Super.prototype );    Item.prototype.constructor = Item;    Item.defaults = utils.extend( {}, Super.defaults );    utils.extend( Item.defaults, defaults );    // create optionKeys    Item.optionKeys = Super.optionKeys.slice(0);    // add defaults keys to optionKeys, dedupe    Object.keys( Item.defaults ).forEach( function( key ) {      if ( !Item.optionKeys.indexOf( key ) != 1 ) {        Item.optionKeys.push( key );      }    });    Item.subclass = getSubclass( Item );    return Item;  };}Anchor.subclass = getSubclass( Anchor );return Anchor;}));/** * Dragger */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory();  } else {    // browser global    root.Zdog.Dragger = factory();  }}( this, function factory() {// quick & dirty drag event stuff// messes up if multiple pointers/touches// check for browser window #85var hasWindow = typeof window != 'undefined';// event support, default to mouse eventsvar downEvent = 'mousedown';var moveEvent = 'mousemove';var upEvent = 'mouseup';if ( hasWindow ) {  if ( window.PointerEvent ) {    // PointerEvent, Chrome    downEvent = 'pointerdown';    moveEvent = 'pointermove';    upEvent = 'pointerup';  } else if ( 'ontouchstart' in window ) {    // Touch Events, iOS Safari    downEvent = 'touchstart';    moveEvent = 'touchmove';    upEvent = 'touchend';  }}function noop() {}function Dragger( options ) {  this.create( options || {} );}Dragger.prototype.create = function( options ) {  this.onDragStart = options.onDragStart || noop;  this.onDragMove = options.onDragMove || noop;  this.onDragEnd = options.onDragEnd || noop;  this.bindDrag( options.startElement );};Dragger.prototype.bindDrag = function( element ) {  element = this.getQueryElement( element );  if ( !element ) {    return;  }  // disable browser gestures #53  element.style.touchAction = 'none';  element.addEventListener( downEvent, this );};Dragger.prototype.getQueryElement = function( element ) {  if ( typeof element == 'string' ) {    // with string, query selector    element = document.querySelector( element );  }  return element;};Dragger.prototype.handleEvent = function( event ) {  var method = this[ 'on' + event.type ];  if ( method ) {    method.call( this, event );  }};Dragger.prototype.onmousedown =Dragger.prototype.onpointerdown = function( event ) {  this.dragStart( event, event );};Dragger.prototype.ontouchstart = function( event ) {  this.dragStart( event, event.changedTouches[0] );};Dragger.prototype.dragStart = function( event, pointer ) {  event.preventDefault();  this.dragStartX = pointer.pageX;  this.dragStartY = pointer.pageY;  if ( hasWindow ) {    window.addEventListener( moveEvent, this );    window.addEventListener( upEvent, this );  }  this.onDragStart( pointer );};Dragger.prototype.ontouchmove = function( event ) {  // HACK, moved touch may not be first  this.dragMove( event, event.changedTouches[0] );};Dragger.prototype.onmousemove =Dragger.prototype.onpointermove = function( event ) {  this.dragMove( event, event );};Dragger.prototype.dragMove = function( event, pointer ) {  event.preventDefault();  var moveX = pointer.pageX - this.dragStartX;  var moveY = pointer.pageY - this.dragStartY;  this.onDragMove( pointer, moveX, moveY );};Dragger.prototype.onmouseup =Dragger.prototype.onpointerup =Dragger.prototype.ontouchend =Dragger.prototype.dragEnd = function(/* event */) {  window.removeEventListener( moveEvent, this );  window.removeEventListener( upEvent, this );  this.onDragEnd();};return Dragger;}));/** * Illustration */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate'), require('./anchor'),        require('./dragger') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Illustration = factory( Zdog, Zdog.Anchor, Zdog.Dragger );  }}( this, function factory( utils, Anchor, Dragger ) {function noop() {}var TAU = utils.TAU;var Illustration = Anchor.subclass({  element: undefined,  centered: true,  zoom: 1,  dragRotate: false,  resize: false,  onPrerender: noop,  onDragStart: noop,  onDragMove: noop,  onDragEnd: noop,  onResize: noop,});utils.extend( Illustration.prototype, Dragger.prototype );Illustration.prototype.create = function( options ) {  Anchor.prototype.create.call( this, options );  Dragger.prototype.create.call( this, options );  this.setElement( this.element );  this.setDragRotate( this.dragRotate );  this.setResize( this.resize );};Illustration.prototype.setElement = function( element ) {  element = this.getQueryElement( element );  if ( !element ) {    throw new Error( 'Zdog.Illustration element required. Set to ' + element );  }  var nodeName = element.nodeName.toLowerCase();  if ( nodeName == 'canvas' ) {    this.setCanvas( element );  } else if ( nodeName == 'svg' ) {    this.setSvg( element );  }};Illustration.prototype.setSize = function( width, height ) {  width = Math.round( width );  height = Math.round( height );  if ( this.isCanvas ) {    this.setSizeCanvas( width, height );  } else if ( this.isSvg ) {    this.setSizeSvg( width, height );  }};Illustration.prototype.setResize = function( resize ) {  this.resize = resize;  // create resize event listener  if ( !this.resizeListener ) {    this.resizeListener = this.onWindowResize.bind( this );  }  // add/remove event listener  if ( resize ) {    window.addEventListener( 'resize', this.resizeListener );    this.onWindowResize();  } else {    window.removeEventListener( 'resize', this.resizeListener );  }};// TODO debounce this?Illustration.prototype.onWindowResize = function() {  this.setMeasuredSize();  this.onResize( this.width, this.height );};Illustration.prototype.setMeasuredSize = function() {  var width, height;  var isFullscreen = this.resize == 'fullscreen';  if ( isFullscreen ) {    width = window.innerWidth;    height = window.innerHeight;  } else {    var rect = this.element.getBoundingClientRect();    width = rect.width;    height = rect.height;  }  this.setSize( width, height );};// ----- render ----- //Illustration.prototype.renderGraph = function( item ) {  if ( this.isCanvas ) {    this.renderGraphCanvas( item );  } else if ( this.isSvg ) {    this.renderGraphSvg( item );  }};// combo methodIllustration.prototype.updateRenderGraph = function( item ) {  this.updateGraph();  this.renderGraph( item );};// ----- canvas ----- //Illustration.prototype.setCanvas = function( element ) {  this.element = element;  this.isCanvas = true;  // update related properties  this.ctx = this.element.getContext('2d');  // set initial size  this.setSizeCanvas( element.width, element.height );};Illustration.prototype.setSizeCanvas = function( width, height ) {  this.width = width;  this.height = height;  // up-rez for hi-DPI devices  var pixelRatio = this.pixelRatio = window.devicePixelRatio || 1;  this.element.width = this.canvasWidth = width * pixelRatio;  this.element.height = this.canvasHeight = height * pixelRatio;  var needsHighPixelRatioSizing = pixelRatio > 1 && !this.resize;  if ( needsHighPixelRatioSizing ) {    this.element.style.width = width + 'px';    this.element.style.height = height + 'px';  }};Illustration.prototype.renderGraphCanvas = function( item ) {  item = item || this;  this.prerenderCanvas();  Anchor.prototype.renderGraphCanvas.call( item, this.ctx );  this.postrenderCanvas();};Illustration.prototype.prerenderCanvas = function() {  var ctx = this.ctx;  ctx.lineCap = 'round';  ctx.lineJoin = 'round';  ctx.clearRect( 0, 0, this.canvasWidth, this.canvasHeight );  ctx.save();  if ( this.centered ) {    var centerX = this.width/2 * this.pixelRatio;    var centerY = this.height/2 * this.pixelRatio;    ctx.translate( centerX, centerY );  }  var scale = this.pixelRatio * this.zoom;  ctx.scale( scale, scale );  this.onPrerender( ctx );};Illustration.prototype.postrenderCanvas = function() {  this.ctx.restore();};// ----- svg ----- //Illustration.prototype.setSvg = function( element ) {  this.element = element;  this.isSvg = true;  this.pixelRatio = 1;  // set initial size from width & height attributes  var width = element.getAttribute('width');  var height = element.getAttribute('height');  this.setSizeSvg( width, height );};Illustration.prototype.setSizeSvg = function( width, height ) {  this.width = width;  this.height = height;  var viewWidth = width / this.zoom;  var viewHeight = height / this.zoom;  var viewX = this.centered ? -viewWidth/2 : 0;  var viewY = this.centered ? -viewHeight/2 : 0;  this.element.setAttribute( 'viewBox', viewX + ' ' + viewY + ' ' +    viewWidth + ' ' + viewHeight );  if ( this.resize ) {    // remove size attributes, let size be determined by viewbox    this.element.removeAttribute('width');    this.element.removeAttribute('height');  } else {    this.element.setAttribute( 'width', width );    this.element.setAttribute( 'height', height );  }};Illustration.prototype.renderGraphSvg = function( item ) {  item = item || this;  empty( this.element );  this.onPrerender( this.element );  Anchor.prototype.renderGraphSvg.call( item, this.element );};function empty( element ) {  while ( element.firstChild ) {    element.removeChild( element.firstChild );  }}// ----- drag ----- //Illustration.prototype.setDragRotate = function( item ) {  if ( !item ) {    return;  } else if ( item === true ) {    /* eslint consistent-this: "off" */    item = this;  }  this.dragRotate = item;  this.bindDrag( this.element );};Illustration.prototype.dragStart = function(/* event, pointer */) {  this.dragStartRX = this.dragRotate.rotate.x;  this.dragStartRY = this.dragRotate.rotate.y;  Dragger.prototype.dragStart.apply( this, arguments );};Illustration.prototype.dragMove = function( event, pointer ) {  var moveX = pointer.pageX - this.dragStartX;  var moveY = pointer.pageY - this.dragStartY;  var displaySize = Math.min( this.width, this.height );  var moveRY = moveX / displaySize * TAU;  var moveRX = moveY / displaySize * TAU;  this.dragRotate.rotate.x = this.dragStartRX - moveRX;  this.dragRotate.rotate.y = this.dragStartRY - moveRY;  Dragger.prototype.dragMove.apply( this, arguments );};return Illustration;}));/** * PathCommand */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./vector') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.PathCommand = factory( Zdog.Vector );  }}( this, function factory( Vector ) {function PathCommand( method, points, previousPoint ) {  this.method = method;  this.points = points.map( mapVectorPoint );  this.renderPoints = points.map( mapNewVector );  this.previousPoint = previousPoint;  this.endRenderPoint = this.renderPoints[ this.renderPoints.length - 1 ];  // arc actions come with previous point & corner point  // but require bezier control points  if ( method == 'arc' ) {    this.controlPoints = [ new Vector(), new Vector() ];  }}function mapVectorPoint( point ) {  if ( point instanceof Vector ) {    return point;  } else {    return new Vector( point );  }}function mapNewVector( point ) {  return new Vector( point );}PathCommand.prototype.reset = function() {  // reset renderPoints back to orignal points position  var points = this.points;  this.renderPoints.forEach( function( renderPoint, i ) {    var point = points[i];    renderPoint.set( point );  });};PathCommand.prototype.transform = function( translation, rotation, scale ) {  this.renderPoints.forEach( function( renderPoint ) {    renderPoint.transform( translation, rotation, scale );  });};PathCommand.prototype.render = function( ctx, elem, renderer ) {  return this[ this.method ]( ctx, elem, renderer );};PathCommand.prototype.move = function( ctx, elem, renderer ) {  return renderer.move( ctx, elem, this.renderPoints[0] );};PathCommand.prototype.line = function( ctx, elem, renderer ) {  return renderer.line( ctx, elem, this.renderPoints[0] );};PathCommand.prototype.bezier = function( ctx, elem, renderer ) {  var cp0 = this.renderPoints[0];  var cp1 = this.renderPoints[1];  var end = this.renderPoints[2];  return renderer.bezier( ctx, elem, cp0, cp1, end );};var arcHandleLength = 9/16;PathCommand.prototype.arc = function( ctx, elem, renderer ) {  var prev = this.previousPoint;  var corner = this.renderPoints[0];  var end = this.renderPoints[1];  var cp0 = this.controlPoints[0];  var cp1 = this.controlPoints[1];  cp0.set( prev ).lerp( corner, arcHandleLength );  cp1.set( end ).lerp( corner, arcHandleLength );  return renderer.bezier( ctx, elem, cp0, cp1, end );};return PathCommand;}));/** * Shape */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate'), require('./vector'),        require('./path-command'), require('./anchor') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Shape = factory( Zdog, Zdog.Vector, Zdog.PathCommand, Zdog.Anchor );  }}( this, function factory( utils, Vector, PathCommand, Anchor ) {var Shape = Anchor.subclass({  stroke: 1,  fill: false,  color: '#333',  closed: true,  visible: true,  path: [ {} ],  front: { z: 1 },  backface: true,});Shape.prototype.create = function( options ) {  Anchor.prototype.create.call( this, options );  this.updatePath();  // front  this.front = new Vector( options.front || this.front );  this.renderFront = new Vector( this.front );  this.renderNormal = new Vector();};var actionNames = [  'move',  'line',  'bezier',  'arc',];Shape.prototype.updatePath = function() {  this.setPath();  this.updatePathCommands();};// place holder for Ellipse, Rect, etc.Shape.prototype.setPath = function() {};// parse path into PathCommandsShape.prototype.updatePathCommands = function() {  var previousPoint;  this.pathCommands = this.path.map( function( pathPart, i ) {    // pathPart can be just vector coordinates -> { x, y, z }    // or path instruction -> { arc: [ {x0,y0,z0}, {x1,y1,z1} ] }    var keys = Object.keys( pathPart );    var method = keys[0];    var points = pathPart[ method ];    // default to line if no instruction    var isInstruction = keys.length == 1 && actionNames.indexOf( method ) != -1;    if ( !isInstruction ) {      method = 'line';      points = pathPart;    }    // munge single-point methods like line & move without arrays    var isLineOrMove = method == 'line' || method == 'move';    var isPointsArray = Array.isArray( points );    if ( isLineOrMove && !isPointsArray ) {      points = [ points ];    }    // first action is always move    method = i === 0 ? 'move' : method;    // arcs require previous last point    var command = new PathCommand( method, points, previousPoint );    // update previousLastPoint    previousPoint = command.endRenderPoint;    return command;  });};// ----- update ----- //Shape.prototype.reset = function() {  this.renderOrigin.set( this.origin );  this.renderFront.set( this.front );  // reset command render points  this.pathCommands.forEach( function( command ) {    command.reset();  });};Shape.prototype.transform = function( translation, rotation, scale ) {  // calculate render points backface visibility & cone/hemisphere shapes  this.renderOrigin.transform( translation, rotation, scale );  this.renderFront.transform( translation, rotation, scale );  this.renderNormal.set( this.renderOrigin ).subtract( this.renderFront );  // transform points  this.pathCommands.forEach( function( command ) {    command.transform( translation, rotation, scale );  });  // transform children  this.children.forEach( function( child ) {    child.transform( translation, rotation, scale );  });};Shape.prototype.updateSortValue = function() {  // sort by average z of all points  // def not geometrically correct, but works for me  var pointCount = this.pathCommands.length;  var firstPoint = this.pathCommands[0].endRenderPoint;  var lastPoint = this.pathCommands[ pointCount - 1 ].endRenderPoint;  // ignore the final point if self closing shape  var isSelfClosing = pointCount > 2 && firstPoint.isSame( lastPoint );  if ( isSelfClosing ) {    pointCount -= 1;  }  var sortValueTotal = 0;  for ( var i = 0; i < pointCount; i++ ) {    sortValueTotal += this.pathCommands[i].endRenderPoint.z;  }  this.sortValue = sortValueTotal / pointCount;};// ----- render ----- //Shape.prototype.render = function( ctx, renderer ) {  var length = this.pathCommands.length;  if ( !this.visible || !length ) {    return;  }  // do not render if hiding backface  this.isFacingBack = this.renderNormal.z > 0;  if ( !this.backface && this.isFacingBack ) {    return;  }  if ( !renderer ) {    throw new Error( 'Zdog renderer required. Set to ' + renderer );  }  // render dot or path  var isDot = length == 1;  if ( renderer.isCanvas && isDot ) {    this.renderCanvasDot( ctx, renderer );  } else {    this.renderPath( ctx, renderer );  }};var TAU = utils.TAU;// Safari does not render lines with no size, have to render circle insteadShape.prototype.renderCanvasDot = function( ctx ) {  var lineWidth = this.getLineWidth();  if ( !lineWidth ) {    return;  }  ctx.fillStyle = this.getRenderColor();  var point = this.pathCommands[0].endRenderPoint;  ctx.beginPath();  var radius = lineWidth/2;  ctx.arc( point.x, point.y, radius, 0, TAU );  ctx.fill();};Shape.prototype.getLineWidth = function() {  if ( !this.stroke ) {    return 0;  }  if ( this.stroke == true ) {    return 1;  }  return this.stroke;};Shape.prototype.getRenderColor = function() {  // use backface color if applicable  var isBackfaceColor = typeof this.backface == 'string' && this.isFacingBack;  var color = isBackfaceColor ? this.backface : this.color;  return color;};Shape.prototype.renderPath = function( ctx, renderer ) {  var elem = this.getRenderElement( ctx, renderer );  var isTwoPoints = this.pathCommands.length == 2 &&    this.pathCommands[1].method == 'line';  var isClosed = !isTwoPoints && this.closed;  var color = this.getRenderColor();  renderer.renderPath( ctx, elem, this.pathCommands, isClosed );  renderer.stroke( ctx, elem, this.stroke, color, this.getLineWidth() );  renderer.fill( ctx, elem, this.fill, color );  renderer.end( ctx, elem );};var svgURI = 'http://www.w3.org/2000/svg';Shape.prototype.getRenderElement = function( ctx, renderer ) {  if ( !renderer.isSvg ) {    return;  }  if ( !this.svgElement ) {    // create svgElement    this.svgElement = document.createElementNS( svgURI, 'path');    this.svgElement.setAttribute( 'stroke-linecap', 'round' );    this.svgElement.setAttribute( 'stroke-linejoin', 'round' );  }  return this.svgElement;};return Shape;}));/** * Group */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./anchor') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Group = factory( Zdog.Anchor );  }}( this, function factory( Anchor ) {var Group = Anchor.subclass({  updateSort: false,  visible: true,});// ----- update ----- //Group.prototype.updateSortValue = function() {  var sortValueTotal = 0;  this.flatGraph.forEach( function( item ) {    item.updateSortValue();    sortValueTotal += item.sortValue;  });  // average sort value of all points  // def not geometrically correct, but works for me  this.sortValue = sortValueTotal / this.flatGraph.length;  if ( this.updateSort ) {    this.flatGraph.sort( Anchor.shapeSorter );  }};// ----- render ----- //Group.prototype.render = function( ctx, renderer ) {  if ( !this.visible ) {    return;  }  this.flatGraph.forEach( function( item ) {    item.render( ctx, renderer );  });};// actual group flatGraph only used inside groupGroup.prototype.updateFlatGraph = function() {  // do not include self  var flatGraph = [];  this.flatGraph = this.addChildFlatGraph( flatGraph );};// do not include children, group handles rendering & sorting internallyGroup.prototype.getFlatGraph = function() {  return [ this ];};return Group;}));/** * Rect */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./shape') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Rect = factory( Zdog.Shape );  }}( this, function factory( Shape ) {var Rect = Shape.subclass({  width: 1,  height: 1,});Rect.prototype.setPath = function() {  var x = this.width / 2;  var y = this.height / 2;  /* eslint key-spacing: "off" */  this.path = [    { x: -x, y: -y },    { x:  x, y: -y },    { x:  x, y:  y },    { x: -x, y:  y },  ];};return Rect;}));/** * RoundedRect */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./shape') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.RoundedRect = factory( Zdog.Shape );  }}( this, function factory( Shape ) {var RoundedRect = Shape.subclass({  width: 1,  height: 1,  cornerRadius: 0.25,  closed: false,});RoundedRect.prototype.setPath = function() {  /* eslint     id-length: [ "error", { "min": 2, "exceptions": [ "x", "y" ] }],     key-spacing: "off" */  var xA = this.width / 2;  var yA = this.height / 2;  var shortSide = Math.min( xA, yA );  var cornerRadius = Math.min( this.cornerRadius, shortSide );  var xB = xA - cornerRadius;  var yB = yA - cornerRadius;  var path = [    // top right corner    { x: xB, y: -yA },    { arc: [      { x: xA, y: -yA },      { x: xA, y: -yB },    ]},  ];  // bottom right corner  if ( yB ) {    path.push({ x: xA, y: yB });  }  path.push({ arc: [    { x: xA, y:  yA },    { x: xB, y:  yA },  ]});  // bottom left corner  if ( xB ) {    path.push({ x: -xB, y: yA });  }  path.push({ arc: [    { x: -xA, y:  yA },    { x: -xA, y:  yB },  ]});  // top left corner  if ( yB ) {    path.push({ x: -xA, y: -yB });  }  path.push({ arc: [    { x: -xA, y: -yA },    { x: -xB, y: -yA },  ]});  // back to top right corner  if ( xB ) {    path.push({ x: xB, y: -yA });  }  this.path = path;};return RoundedRect;}));/** * Ellipse */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./shape') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Ellipse = factory( Zdog.Shape );  }}( this, function factory( Shape ) {var Ellipse = Shape.subclass({  diameter: 1,  width: undefined,  height: undefined,  quarters: 4,  closed: false,});Ellipse.prototype.setPath = function() {  var width = this.width != undefined ? this.width : this.diameter;  var height = this.height != undefined ? this.height : this.diameter;  var x = width / 2;  var y = height / 2;  this.path = [    { x: 0, y: -y },    { arc: [ // top right      { x: x, y: -y },      { x: x, y: 0 },    ]},  ];  // bottom right  if ( this.quarters > 1 ) {    this.path.push({ arc: [      { x: x, y: y },      { x: 0, y: y },    ]});  }  // bottom left  if ( this.quarters > 2 ) {    this.path.push({ arc: [      { x: -x, y: y },      { x: -x, y: 0 },    ]});  }  // top left  if ( this.quarters > 3 ) {    this.path.push({ arc: [      { x: -x, y: -y },      { x: 0, y: -y },    ]});  }};return Ellipse;}));/** * Shape */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate'), require('./shape') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Polygon = factory( Zdog, Zdog.Shape );  }}( this, function factory( utils, Shape ) {var Polygon = Shape.subclass({  sides: 3,  radius: 0.5,});var TAU = utils.TAU;Polygon.prototype.setPath = function() {  this.path = [];  for ( var i=0; i < this.sides; i++ ) {    var theta = i/this.sides * TAU - TAU/4;    var x = Math.cos( theta ) * this.radius;    var y = Math.sin( theta ) * this.radius;    this.path.push({ x: x, y: y });  }};return Polygon;}));/** * Hemisphere composite shape */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate'), require('./vector'),        require('./anchor'), require('./ellipse') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Hemisphere = factory( Zdog, Zdog.Vector, Zdog.Anchor, Zdog.Ellipse );  }}( this, function factory( utils, Vector, Anchor, Ellipse ) {var Hemisphere = Ellipse.subclass({  fill: true,});var TAU = utils.TAU;Hemisphere.prototype.create = function(/* options */) {  // call super  Ellipse.prototype.create.apply( this, arguments );  // composite shape, create child shapes  this.apex = new Anchor({    addTo: this,    translate: { z: this.diameter/2 },  });  // vector used for calculation  this.renderCentroid = new Vector();};Hemisphere.prototype.updateSortValue = function() {  // centroid of hemisphere is 3/8 between origin and apex  this.renderCentroid.set( this.renderOrigin )    .lerp( this.apex.renderOrigin, 3/8 );  this.sortValue = this.renderCentroid.z;};Hemisphere.prototype.render = function( ctx, renderer ) {  this.renderDome( ctx, renderer );  // call super  Ellipse.prototype.render.apply( this, arguments );};Hemisphere.prototype.renderDome = function( ctx, renderer ) {  if ( !this.visible ) {    return;  }  var elem = this.getDomeRenderElement( ctx, renderer );  var contourAngle = Math.atan2( this.renderNormal.y, this.renderNormal.x );  var domeRadius = this.diameter/2 * this.renderNormal.magnitude();  var x = this.renderOrigin.x;  var y = this.renderOrigin.y;  if ( renderer.isCanvas ) {    // canvas    var startAngle = contourAngle + TAU/4;    var endAngle = contourAngle - TAU/4;    ctx.beginPath();    ctx.arc( x, y, domeRadius, startAngle, endAngle );  } else if ( renderer.isSvg ) {    // svg    contourAngle = (contourAngle - TAU/4) / TAU * 360;    this.domeSvgElement.setAttribute( 'd', 'M ' + -domeRadius + ',0 A ' +        domeRadius + ',' + domeRadius + ' 0 0 1 ' + domeRadius + ',0' );    this.domeSvgElement.setAttribute( 'transform',        'translate(' + x + ',' + y + ' ) rotate(' + contourAngle + ')' );  }  renderer.stroke( ctx, elem, this.stroke, this.color, this.getLineWidth() );  renderer.fill( ctx, elem, this.fill, this.color );  renderer.end( ctx, elem );};var svgURI = 'http://www.w3.org/2000/svg';Hemisphere.prototype.getDomeRenderElement = function( ctx, renderer ) {  if ( !renderer.isSvg ) {    return;  }  if ( !this.domeSvgElement ) {    // create svgElement    this.domeSvgElement = document.createElementNS( svgURI, 'path');    this.domeSvgElement.setAttribute( 'stroke-linecap', 'round' );    this.domeSvgElement.setAttribute( 'stroke-linejoin', 'round' );  }  return this.domeSvgElement;};return Hemisphere;}));/** * Cylinder composite shape */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate'),        require('./path-command'), require('./shape'), require('./group'),        require('./ellipse') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Cylinder = factory( Zdog, Zdog.PathCommand, Zdog.Shape,        Zdog.Group, Zdog.Ellipse );  }}( this, function factory( utils, PathCommand, Shape, Group, Ellipse ) {function noop() {}// ----- CylinderGroup ----- //var CylinderGroup = Group.subclass({  color: '#333',  updateSort: true,});CylinderGroup.prototype.create = function() {  Group.prototype.create.apply( this, arguments );  this.pathCommands = [    new PathCommand( 'move', [ {} ] ),    new PathCommand( 'line', [ {} ] ),  ];};CylinderGroup.prototype.render = function( ctx, renderer ) {  this.renderCylinderSurface( ctx, renderer );  Group.prototype.render.apply( this, arguments );};CylinderGroup.prototype.renderCylinderSurface = function( ctx, renderer ) {  if ( !this.visible ) {    return;  }  // render cylinder surface  var elem = this.getRenderElement( ctx, renderer );  var frontBase = this.frontBase;  var rearBase = this.rearBase;  var scale = frontBase.renderNormal.magnitude();  var strokeWidth = frontBase.diameter * scale + frontBase.getLineWidth();  // set path command render points  this.pathCommands[0].renderPoints[0].set( frontBase.renderOrigin );  this.pathCommands[1].renderPoints[0].set( rearBase.renderOrigin );  if ( renderer.isCanvas ) {    ctx.lineCap = 'butt'; // nice  }  renderer.renderPath( ctx, elem, this.pathCommands );  renderer.stroke( ctx, elem, true, this.color, strokeWidth );  renderer.end( ctx, elem );  if ( renderer.isCanvas ) {    ctx.lineCap = 'round'; // reset  }};var svgURI = 'http://www.w3.org/2000/svg';CylinderGroup.prototype.getRenderElement = function( ctx, renderer ) {  if ( !renderer.isSvg ) {    return;  }  if ( !this.svgElement ) {    // create svgElement    this.svgElement = document.createElementNS( svgURI, 'path');  }  return this.svgElement;};// prevent double-creation in parent.copyGraph()// only create in Cylinder.create()CylinderGroup.prototype.copyGraph = noop;// ----- CylinderEllipse ----- //var CylinderEllipse = Ellipse.subclass();CylinderEllipse.prototype.copyGraph = noop;// ----- Cylinder ----- //var Cylinder = Shape.subclass({  diameter: 1,  length: 1,  frontFace: undefined,  fill: true,});var TAU = utils.TAU;Cylinder.prototype.create = function(/* options */) {  // call super  Shape.prototype.create.apply( this, arguments );  // composite shape, create child shapes  // CylinderGroup to render cylinder surface then bases  this.group = new CylinderGroup({    addTo: this,    color: this.color,    visible: this.visible,  });  var baseZ = this.length/2;  var baseColor = this.backface || true;  // front outside base  this.frontBase = this.group.frontBase = new Ellipse({    addTo: this.group,    diameter: this.diameter,    translate: { z: baseZ },    rotate: { y: TAU/2 },    color: this.color,    stroke: this.stroke,    fill: this.fill,    backface: this.frontFace || baseColor,    visible: this.visible,  });  // back outside base  this.rearBase = this.group.rearBase = this.frontBase.copy({    translate: { z: -baseZ },    rotate: { y: 0 },    backface: baseColor,  });};// Cylinder shape does not render anythingCylinder.prototype.render = function() {};// ----- set child properties ----- //var childProperties = [ 'stroke', 'fill', 'color', 'visible' ];childProperties.forEach( function( property ) {  // use proxy property for custom getter & setter  var _prop = '_' + property;  Object.defineProperty( Cylinder.prototype, property, {    get: function() {      return this[ _prop ];    },    set: function( value ) {      this[ _prop ] = value;      // set property on children      if ( this.frontBase ) {        this.frontBase[ property ] = value;        this.rearBase[ property ] = value;        this.group[ property ] = value;      }    },  });});// TODO child property setter for backface, frontBaseColor, & rearBaseColorreturn Cylinder;}));/** * Cone composite shape */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate'), require('./vector'),        require('./path-command'), require('./anchor'), require('./ellipse') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Cone = factory( Zdog, Zdog.Vector, Zdog.PathCommand,        Zdog.Anchor, Zdog.Ellipse );  }}( this, function factory( utils, Vector, PathCommand, Anchor, Ellipse ) {var Cone = Ellipse.subclass({  length: 1,  fill: true,});var TAU = utils.TAU;Cone.prototype.create = function(/* options */) {  // call super  Ellipse.prototype.create.apply( this, arguments );  // composite shape, create child shapes  this.apex = new Anchor({    addTo: this,    translate: { z: this.length },  });  // vectors used for calculation  this.renderApex = new Vector();  this.renderCentroid = new Vector();  this.tangentA = new Vector();  this.tangentB = new Vector();  this.surfacePathCommands = [    new PathCommand( 'move', [ {} ] ), // points set in renderConeSurface    new PathCommand( 'line', [ {} ] ),    new PathCommand( 'line', [ {} ] ),  ];};Cone.prototype.updateSortValue = function() {  // center of cone is one third of its length  this.renderCentroid.set( this.renderOrigin )    .lerp( this.apex.renderOrigin, 1/3 );  this.sortValue = this.renderCentroid.z;};Cone.prototype.render = function( ctx, renderer ) {  this.renderConeSurface( ctx, renderer );  Ellipse.prototype.render.apply( this, arguments );};Cone.prototype.renderConeSurface = function( ctx, renderer ) {  if ( !this.visible ) {    return;  }  this.renderApex.set( this.apex.renderOrigin )    .subtract( this.renderOrigin );  var scale = this.renderNormal.magnitude();  var apexDistance = this.renderApex.magnitude2d();  var normalDistance = this.renderNormal.magnitude2d();  // eccentricity  var eccenAngle = Math.acos( normalDistance / scale );  var eccen = Math.sin( eccenAngle );  var radius = this.diameter/2 * scale;  // does apex extend beyond eclipse of face  var isApexVisible = radius * eccen < apexDistance;  if ( !isApexVisible ) {    return;  }  // update tangents  var apexAngle = Math.atan2( this.renderNormal.y, this.renderNormal.x ) +      TAU/2;  var projectLength = apexDistance / eccen;  var projectAngle = Math.acos( radius / projectLength );  // set tangent points  var tangentA = this.tangentA;  var tangentB = this.tangentB;  tangentA.x = Math.cos( projectAngle ) * radius * eccen;  tangentA.y = Math.sin( projectAngle ) * radius;  tangentB.set( this.tangentA );  tangentB.y *= -1;  tangentA.rotateZ( apexAngle );  tangentB.rotateZ( apexAngle );  tangentA.add( this.renderOrigin );  tangentB.add( this.renderOrigin );  this.setSurfaceRenderPoint( 0, tangentA );  this.setSurfaceRenderPoint( 1, this.apex.renderOrigin );  this.setSurfaceRenderPoint( 2, tangentB );  // render  var elem = this.getSurfaceRenderElement( ctx, renderer );  renderer.renderPath( ctx, elem, this.surfacePathCommands );  renderer.stroke( ctx, elem, this.stroke, this.color, this.getLineWidth() );  renderer.fill( ctx, elem, this.fill, this.color );  renderer.end( ctx, elem );};var svgURI = 'http://www.w3.org/2000/svg';Cone.prototype.getSurfaceRenderElement = function( ctx, renderer ) {  if ( !renderer.isSvg ) {    return;  }  if ( !this.surfaceSvgElement ) {    // create svgElement    this.surfaceSvgElement = document.createElementNS( svgURI, 'path');    this.surfaceSvgElement.setAttribute( 'stroke-linecap', 'round' );    this.surfaceSvgElement.setAttribute( 'stroke-linejoin', 'round' );  }  return this.surfaceSvgElement;};Cone.prototype.setSurfaceRenderPoint = function( index, point ) {  var renderPoint = this.surfacePathCommands[ index ].renderPoints[0];  renderPoint.set( point );};return Cone;}));/** * Box composite shape */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory( require('./boilerplate'), require('./anchor'),        require('./shape'), require('./rect') );  } else {    // browser global    var Zdog = root.Zdog;    Zdog.Box = factory( Zdog, Zdog.Anchor, Zdog.Shape, Zdog.Rect );  }}( this, function factory( utils, Anchor, Shape, Rect ) {// ----- BoxRect ----- //var BoxRect = Rect.subclass();// prevent double-creation in parent.copyGraph()// only create in Box.create()BoxRect.prototype.copyGraph = function() {};// ----- Box ----- //var TAU = utils.TAU;var faceNames = [  'frontFace',  'rearFace',  'leftFace',  'rightFace',  'topFace',  'bottomFace',];var boxDefaults = utils.extend( {}, Shape.defaults );delete boxDefaults.path;faceNames.forEach( function( faceName ) {  boxDefaults[ faceName ] = true;});utils.extend( boxDefaults, {  width: 1,  height: 1,  depth: 1,  fill: true,});var Box = Anchor.subclass( boxDefaults );Box.prototype.create = function( options ) {  Anchor.prototype.create.call( this, options );  this.updatePath();  // HACK reset fill to trigger face setter  this.fill = this.fill;};Box.prototype.updatePath = function() {  // reset all faces to trigger setters  faceNames.forEach( function( faceName ) {    this[ faceName ] = this[ faceName ];  }, this );};faceNames.forEach( function( faceName ) {  var _faceName = '_' + faceName;  Object.defineProperty( Box.prototype, faceName, {    get: function() {      return this[ _faceName ];    },    set: function( value ) {      this[ _faceName ] = value;      this.setFace( faceName, value );    },  });});Box.prototype.setFace = function( faceName, value ) {  var rectProperty = faceName + 'Rect';  var rect = this[ rectProperty ];  // remove if false  if ( !value ) {    this.removeChild( rect );    return;  }  // update & add face  var options = this.getFaceOptions( faceName );  options.color = typeof value == 'string' ? value : this.color;  if ( rect ) {    // update previous    rect.setOptions( options );  } else {    // create new    rect = this[ rectProperty ] = new BoxRect( options );  }  rect.updatePath();  this.addChild( rect );};Box.prototype.getFaceOptions = function( faceName ) {  return {    frontFace: {      width: this.width,      height: this.height,      translate: { z: this.depth/2 },    },    rearFace: {      width: this.width,      height: this.height,      translate: { z: -this.depth/2 },      rotate: { y: TAU/2 },    },    leftFace: {      width: this.depth,      height: this.height,      translate: { x: -this.width/2 },      rotate: { y: -TAU/4 },    },    rightFace: {      width: this.depth,      height: this.height,      translate: { x: this.width/2 },      rotate: { y: TAU/4 },    },    topFace: {      width: this.width,      height: this.depth,      translate: { y: -this.height/2 },      rotate: { x: -TAU/4 },    },    bottomFace: {      width: this.width,      height: this.depth,      translate: { y: this.height/2 },      rotate: { x: TAU/4 },    },  }[ faceName ];};// ----- set face properties ----- //var childProperties = [ 'color', 'stroke', 'fill', 'backface', 'front',  'visible' ];childProperties.forEach( function( property ) {  // use proxy property for custom getter & setter  var _prop = '_' + property;  Object.defineProperty( Box.prototype, property, {    get: function() {      return this[ _prop ];    },    set: function( value ) {      this[ _prop ] = value;      faceNames.forEach( function( faceName ) {        var rect = this[ faceName + 'Rect' ];        var isFaceColor = typeof this[ faceName ] == 'string';        var isColorUnderwrite = property == 'color' && isFaceColor;        if ( rect && !isColorUnderwrite ) {          rect[ property ] = value;        }      }, this );    },  });});return Box;}));/** * Index */( function( root, factory ) {  // module definition  if ( typeof module == 'object' && module.exports ) {    // CommonJS    module.exports = factory(        require('./boilerplate'),        require('./canvas-renderer'),        require('./svg-renderer'),        require('./vector'),        require('./anchor'),        require('./dragger'),        require('./illustration'),        require('./path-command'),        require('./shape'),        require('./group'),        require('./rect'),        require('./rounded-rect'),        require('./ellipse'),        require('./polygon'),        require('./hemisphere'),        require('./cylinder'),        require('./cone'),        require('./box')    );  } else if ( typeof define == 'function' && define.amd ) {    /* globals define */ // AMD    define( 'zdog', [], root.Zdog );  }})( this, function factory( Zdog, CanvasRenderer, SvgRenderer, Vector, Anchor,    Dragger, Illustration, PathCommand, Shape, Group, Rect, RoundedRect,    Ellipse, Polygon, Hemisphere, Cylinder, Cone, Box ) {      Zdog.CanvasRenderer = CanvasRenderer;      Zdog.SvgRenderer = SvgRenderer;      Zdog.Vector = Vector;      Zdog.Anchor = Anchor;      Zdog.Dragger = Dragger;      Zdog.Illustration = Illustration;      Zdog.PathCommand = PathCommand;      Zdog.Shape = Shape;      Zdog.Group = Group;      Zdog.Rect = Rect;      Zdog.RoundedRect = RoundedRect;      Zdog.Ellipse = Ellipse;      Zdog.Polygon = Polygon;      Zdog.Hemisphere = Hemisphere;      Zdog.Cylinder = Cylinder;      Zdog.Cone = Cone;      Zdog.Box = Box;      return Zdog;});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/twopeople.js"/>
      <url>/js/twopeople.js</url>
      
        <content type="html"><![CDATA[          // Made with Zdogvar BokehShape = Zdog.Shape.subclass({  bokehSize: 5,  bokehLimit: 64 });BokehShape.prototype.updateBokeh = function () {  // bokeh 0 -> 1  this.bokeh = Math.abs(this.sortValue) / this.bokehLimit;  this.bokeh = Math.max(0, Math.min(1, this.bokeh));  return this.bokeh;};BokehShape.prototype.getLineWidth = function () {  return this.stroke + this.bokehSize * this.bokeh * this.bokeh;};BokehShape.prototype.getBokehAlpha = function () {  var alpha = 1 - this.bokeh;  alpha *= alpha;  return alpha * 0.8 + 0.2;};BokehShape.prototype.renderCanvasDot = function (ctx) {  this.updateBokeh();  ctx.globalAlpha = this.getBokehAlpha(); // set opacity  Zdog.Shape.prototype.renderCanvasDot.apply(this, arguments);  ctx.globalAlpha = 1; // reset};BokehShape.prototype.renderPath = function (ctx, renderer) {  this.updateBokeh();  // set opacity  if (renderer.isCanvas) {    ctx.globalAlpha = this.getBokehAlpha();  }  Zdog.Shape.prototype.renderPath.apply(this, arguments);  // reset opacity  if (renderer.isCanvas) {    ctx.globalAlpha = 1;  }};var TAU = Zdog.TAU;function makeMadeline(isGood, colors, options) {  var rotor = new Zdog.Anchor(options);  var body = new Zdog.Group({    addTo: rotor,    rotate: { x: -TAU / 8 },    translate: { z: -48 },    updateSort: true });  var head = new Zdog.Anchor({    addTo: body,    translate: { y: -11, z: -2 },    rotate: { x: TAU / 8 } });  // face  var face = new Zdog.Ellipse({    diameter: 6,    addTo: head,    translate: { z: 4 },    stroke: 8,    color: colors.skin });  var eyeGroup = new Zdog.Group({    addTo: face,    translate: { z: face.stroke / 2 - 0.5 } });  // eyes  [-1, 1].forEach(function (xSide) {    // cheek blush    if (isGood) {      new Zdog.Ellipse({        width: 2,        height: 1.3,        addTo: eyeGroup,        translate: { x: 4.5 * xSide, y: 3, z: -1 },        rotate: { y: -TAU / 16 * xSide },        stroke: 1,        color: '#FA8',        fill: true });    }    var eyeX = 3.5 * xSide;    // eye    new Zdog.Ellipse({      width: 0.75,      height: 1.5,      addTo: eyeGroup,      color: colors.eye,      translate: { x: eyeX },      stroke: 2,      fill: true });    // eye brow    new Zdog.Ellipse({      addTo: eyeGroup,      height: 3,      width: 1.2,      quarters: 2,      translate: { x: eyeX, y: -3 },      rotate: { z: -TAU / 4 + 0.15 * xSide * (isGood ? 1 : -1) },      color: colors.hair,      stroke: 1,      fill: false,      closed: true });  });  // hair ball  new Zdog.Shape({    path: [    { x: -1 },    { x: 1 },    { z: -4 }],    addTo: head,    translate: { y: -4, z: -1 },    stroke: 18,    color: colors.hair });  var bang = new Zdog.Shape({    path: [    {},    { arc: [      { z: 4, y: 4 },      { z: 0, y: 8 }] }],    addTo: head,    translate: { x: 2, y: -7.5, z: 6 },    rotate: { x: 0.5, z: -0.5 },    stroke: 4,    color: colors.hair,    closed: false });  bang.copy({    translate: { x: 5, y: -6, z: 5 },    rotate: { x: -0.3, z: -0.5 } });  bang.copy({    translate: { x: 5, y: -6, z: 3 },    rotate: { y: -0.7, z: -1 } });  // left side  bang.copy({    translate: { x: -2, y: -7.5, z: 6 },    rotate: { x: 0, z: TAU / 16 * 6 } });  bang.copy({    translate: { x: -5, y: -6, z: 5 },    rotate: { x: 0, z: TAU / 4 } });  bang.copy({    translate: { x: -5, y: -6, z: 3 },    rotate: { y: 0.7, z: 1 } });  // hair cover  new Zdog.Shape({    path: [    { x: -3 },    { x: 3 }],    addTo: head,    stroke: 7,    translate: { y: -8, z: 5 },    color: colors.hair });  // trail locks  var trailLock = new Zdog.Shape({    path: [    { y: -4, z: 0 },    { bezier: [      { y: -10, z: -14 },      { y: 0, z: -16 },      { y: 0, z: -26 }] }],    addTo: head,    translate: { z: -4, y: 0 },    stroke: 10,    color: colors.hair,    closed: false });  trailLock.copy({    translate: { x: -3, z: -4 },    rotate: { z: -TAU / 8 },    stroke: 8 });  trailLock.copy({    translate: { x: 3, z: -4 },    rotate: { z: TAU / 8 },    stroke: 8 });  trailLock.copy({    translate: { y: 2 },    // rotate: { z: TAU/2 },    scale: { y: 0.5 },    stroke: 8 });  // ----- torso ----- //  // 2nd rib  var torsoRib = new Zdog.Ellipse({    width: 12,    height: 10,    addTo: body,    rotate: { x: -TAU / 4 },    translate: { y: -1 },    stroke: 6,    color: colors.parkaLight,    fill: true });  // neck rib  torsoRib.copy({    width: 6,    height: 6,    translate: { y: -5 } });  // 3rd rib  torsoRib.copy({    translate: { y: 3 } });  // 4th rib  torsoRib.copy({    translate: { y: 7 },    color: colors.parkaDark });  // waist  new Zdog.Ellipse({    width: 10,    height: 8,    addTo: body,    rotate: { x: -TAU / 4 },    translate: { y: 11 },    stroke: 4,    color: colors.tight,    fill: true });  // arms  [-1, 1].forEach(function (xSide) {    var isLeft = xSide == 1;    // shoulder ball    new Zdog.Shape({      addTo: body,      stroke: 6,      translate: { x: 6 * xSide, y: -5, z: -1 },      color: colors.parkaLight });    var shoulderJoint = new Zdog.Anchor({      addTo: body,      translate: { x: 9 * xSide, y: -3, z: -2 },      rotate: isLeft ? { x: TAU / 8 * 3, z: -TAU / 32 } : { z: TAU / 16 * 2, x: -TAU / 16 * 2 } });    // top shoulder rib    var armRib = new Zdog.Ellipse({      diameter: 2,      rotate: { x: -TAU / 4 },      addTo: shoulderJoint,      translate: { x: 0 * xSide },      stroke: 6,      color: colors.parkaLight,      fill: true });    armRib.copy({      translate: { y: 4 } });    var elbowJoint = new Zdog.Anchor({      addTo: shoulderJoint,      translate: { y: 8 },      rotate: isLeft ? {} : { z: TAU / 8 } });    armRib.copy({      addTo: elbowJoint,      translate: { x: 0, y: 0 } });    armRib.copy({      addTo: elbowJoint,      translate: { y: 4 },      color: colors.parkaDark });    // hand    new Zdog.Shape({      addTo: elbowJoint,      translate: { y: 9, z: -1 },      stroke: 8,      color: colors.skin });    // ----- legs ----- //    var knee = { y: 7 };    var thigh = new Zdog.Shape({      path: [{ y: 0 }, knee],      addTo: body,      translate: { x: 4 * xSide, y: 13 },      rotate: isLeft ? {} : { x: TAU / 16 * 3, z: TAU / 16 },      stroke: 8,      color: colors.tight });    var shin = new Zdog.Shape({      path: [{ y: 0 }, { y: 8 }],      addTo: thigh,      stroke: 6,      translate: knee,      rotate: isLeft ? {} : { x: -TAU / 16 * 5 },      color: colors.tight });  });  // butt  new Zdog.Shape({    path: [    { x: -3 },    { x: 3 }],    visible: false,    addTo: body,    translate: { y: 11, z: -2 },    stroke: 8,    color: colors.tight });}window.makeBird = function (options) {  var spin = options.spin || 0;  var arrow = new Zdog.Anchor({    addTo: options.addTo,    scale: 2 / 3,    rotate: { z: spin } });  var bird = new Zdog.Group({    addTo: arrow,    translate: { x: 87 },    rotate: { x: -spin } });  // bird body  new Zdog.Shape({    path: [    { x: -3, y: 0 },    { arc: [      { x: -2, y: 1.5 },      { x: 0, y: 1.5 }] },    { arc: [      { x: 2, y: 1.5 },      { x: 2, y: 0 }] }],    addTo: bird,    translate: { x: 0.5 },    stroke: 3,    color: options.color,    fill: true });  // bird head  new Zdog.Shape({    translate: { x: 4, y: -1 },    addTo: bird,    stroke: 4,    color: options.color });  // beak  new Zdog.Shape({    path: [    { x: 0, y: -1 },    { x: 3, y: 0 },    { x: 0, y: 1 }],    addTo: bird,    translate: { x: 5, y: -1 },    stroke: 1,    color: options.color,    fill: true });  // tail feather  new Zdog.Shape({    path: [    { x: -3, z: -2 },    { x: 0, z: 0 },    { x: -3, z: 2 }],    addTo: bird,    translate: { x: -4, y: 0 },    stroke: 2,    color: options.color,    fill: true });  var wing = new Zdog.Shape({    path: [    { x: 3, y: 0 },    { x: -1, y: -9 },    { arc: [      { x: -5, y: -4 },      { x: -3, y: 0 }] }],    addTo: bird,    translate: { z: -1.5 },    rotate: { x: TAU / 8 },    stroke: 1,    color: options.color,    fill: true });  wing.copy({    translate: { z: 1.5 },    scale: { z: -1 },    rotate: { x: -TAU / 8 } });};// -------------------------- demo -------------------------- //var illoElem = document.querySelector('.illo');var w = 160;var h = 160;var minWindowSize = Math.min(window.innerWidth, window.innerHeight);var zoom = Math.min(5, Math.floor(minWindowSize / w));illoElem.setAttribute('width', w * zoom);illoElem.setAttribute('height', h * zoom);var isSpinning = true;var TAU = Zdog.TAU;var illo = new Zdog.Illustration({  element: illoElem,  zoom: zoom,  rotate: { y: -TAU / 4 },  dragRotate: true,  onDragStart: function () {    isSpinning = false;  } });var madColor = {  skin: '#FD9',  hair: '#D53',  parkaLight: '#67F',  parkaDark: '#35D',  tight: '#742',  eye: '#333' };var badColor = {  skin: '#EBC',  hair: '#D4B',  parkaLight: '#85A',  parkaDark: '#527',  tight: '#412',  eye: '#D02' };var glow = 'hsla(60, 100%, 80%, 0.3)';var featherGold = '#FE5';// -- illustration shapes --- //makeMadeline(true, madColor, {  addTo: illo });makeMadeline(false, badColor, {  addTo: illo,  rotate: { y: TAU / 2 } });// ----- feather ----- //var feather = new Zdog.Group({  addTo: illo,  rotate: { y: -TAU / 4 } });(function () {  var featherPartCount = 8;  var radius = 12;  var angleX = TAU / featherPartCount / 2;  var sector = TAU * radius / 2 / featherPartCount;  for (var i = 0; i < featherPartCount; i++) {    var curve = Math.cos(i / featherPartCount * TAU * 3 / 4 + TAU * 1 / 4);    var x = 4 - curve * 2;    var y0 = sector / 2;    // var y2 = -sector/2;    var isLast = i == featherPartCount - 1;    var y3 = isLast ? sector * -1 : -y0;    var z1 = -radius + 2 + curve * -1.5;    var z2 = isLast ? -radius : -radius;    var barb = new Zdog.Shape({      path: [      { x: 0, y: y0, z: -radius },      { x: x, y: -sector / 2, z: z1 },      { x: x, y: -sector * 3 / 4, z: z1 },      { x: 0, y: y3, z: z2 }],      addTo: feather,      rotate: { x: angleX * -i + TAU / 8 },      stroke: 1,      color: featherGold,      fill: true });    barb.copy({      scale: { x: -1 } });  }  // rachis  var rachis = new Zdog.Ellipse({    addTo: feather,    diameter: radius * 2,    quarters: 2,    rotate: { y: -TAU / 4 },    stroke: 2,    color: featherGold });  rachis.copy({    stroke: 8,    color: glow,    rotate: { y: -TAU / 4, x: -0.5 } });})();// ----- rods ----- //(function () {  var rodCount = 14;  for (var i = 0; i < rodCount; i++) {    var zRotor = new Zdog.Anchor({      addTo: illo,      rotate: { z: TAU / rodCount * i } });    var y0 = 32;    var y1 = y0 + 2 + Math.random() * 24;    new BokehShape({      path: [      { y: y0 },      { y: y1 }],      addTo: zRotor,      rotate: { x: (Math.random() * 2 - 1) * TAU / 8 },      color: madColor.skin,      stroke: 1,      bokehSize: 6,      bokehLimit: 70 });  }})();// dots(function () {  var dotCount = 64;  for (var i = 0; i < dotCount; i++) {    var yRotor = new Zdog.Anchor({      addTo: illo,      rotate: { y: TAU / dotCount * i } });    new BokehShape({      path: [      { z: 40 * (1 - Math.random() * Math.random()) + 32 }],      addTo: yRotor,      rotate: { x: (Math.random() * 2 - 1) * TAU * 3 / 16 },      color: badColor.skin,      stroke: 1 + Math.random(),      bokehSize: 6,      bokehLimit: 74 });  }})();// ----- birds ----- //var birdRotor = new Zdog.Anchor({  addTo: illo,  rotate: { y: TAU * -1 / 8 } });makeBird({  addTo: birdRotor,  color: madColor.parkaLight,  spin: TAU / 2 });makeBird({  addTo: birdRotor,  color: featherGold,  spin: -TAU * 3 / 8 });makeBird({  addTo: birdRotor,  color: 'white',  spin: -TAU / 4 });makeBird({  addTo: birdRotor,  color: madColor.hair,  spin: -TAU / 8 });makeBird({  addTo: birdRotor,  color: madColor.parkaDark,  spin: TAU / 8 });// -- animate --- //var isSpinning = true;var rotateSpeed = -TAU / 60;var xClock = 0;var then = new Date() - 1 / 60;function animate() {  update();  illo.renderGraph();  requestAnimationFrame(animate);}animate();// -- update -- //function update() {  var now = new Date();  var delta = now - then;  // auto rotate  if (isSpinning) {    var theta = rotateSpeed / 60 * delta * -1;    illo.rotate.y += theta;    xClock += theta / 4;    illo.rotate.x = Math.sin(xClock) * TAU / 12;  }  illo.updateGraph();  then = now;}          //# sourceURL=pen.js]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/twopeople1.js"/>
      <url>/js/twopeople1.js</url>
      
        <content type="html"><![CDATA["use strict";"object"!=typeof window.CP&&(window.CP={}),window.CP.PenTimer={programNoLongerBeingMonitored:!1,timeOfFirstCallToShouldStopLoop:0,_loopExits:{},_loopTimers:{},START_MONITORING_AFTER:2e3,STOP_ALL_MONITORING_TIMEOUT:5e3,MAX_TIME_IN_LOOP_WO_EXIT:2200,exitedLoop:function(o){this._loopExits[o]=!0},shouldStopLoop:function(o){if(this.programKilledSoStopMonitoring)return!0;if(this.programNoLongerBeingMonitored)return!1;if(this._loopExits[o])return!1;var t=this._getTime();if(0===this.timeOfFirstCallToShouldStopLoop)return this.timeOfFirstCallToShouldStopLoop=t,!1;var i=t-this.timeOfFirstCallToShouldStopLoop;if(i<this.START_MONITORING_AFTER)return!1;if(i>this.STOP_ALL_MONITORING_TIMEOUT)return this.programNoLongerBeingMonitored=!0,!1;try{this._checkOnInfiniteLoop(o,t)}catch(e){return this._sendErrorMessageToEditor(),this.programKilledSoStopMonitoring=!0,!0}return!1},_sendErrorMessageToEditor:function(){try{if(this._shouldPostMessage()){var o={action:"infinite-loop",line:this._findAroundLineNumber()};parent.postMessage(o,"*")}else this._throwAnErrorToStopPen()}catch(t){this._throwAnErrorToStopPen()}},_shouldPostMessage:function(){return document.location.href.match(/boomerang/)},_throwAnErrorToStopPen:function(){throw"We found an infinite loop in your Pen. We've stopped the Pen from running. Please correct it or contact support@codepen.io."},_findAroundLineNumber:function(){var o=new Error,t=0;if(o.stack){var i=o.stack.match(/boomerang\S+:(\d+):\d+/);i&&(t=i[1])}return t},_checkOnInfiniteLoop:function(o,t){if(!this._loopTimers[o])return this._loopTimers[o]=t,!1;if(t-this._loopTimers[o]>this.MAX_TIME_IN_LOOP_WO_EXIT)throw"Infinite Loop found on loop: "+o},_getTime:function(){return+new Date}},window.CP.shouldStopExecution=function(o){var t=window.CP.PenTimer.shouldStopLoop(o);return!0===t&&console.warn("[CodePen]: An infinite loop (or a loop taking too long) was detected, so we stopped its execution. Sorry!"),t},window.CP.exitedLoop=function(o){window.CP.PenTimer.exitedLoop(o)};]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>message</title>
      <link href="/message/index.html"/>
      <url>/message/index.html</url>
      
        <content type="html"><![CDATA[<p>请给我留言</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
